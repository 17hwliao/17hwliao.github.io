<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="17hwliao"/><meta name="keyword" content="[]"/><meta name="description" content="第二十天学习集合工厂方法 List fruit &#x3D; Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);Set fruitSet &#x3D; Set.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);Map&lt;Int">
<meta property="og:type" content="article">
<meta property="og:title" content="java18">
<meta property="og:url" content="https://17hwliao.github.io/2026/01/24/java18/index.html">
<meta property="og:site_name" content="17hwliao的妙妙屋">
<meta property="og:description" content="第二十天学习集合工厂方法 List fruit &#x3D; Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);Set fruitSet &#x3D; Set.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);Map&lt;Int">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-01-24T08:31:36.000Z">
<meta property="article:modified_time" content="2026-01-24T08:32:08.939Z">
<meta property="article:author" content="17hwliao">
<meta name="twitter:card" content="summary"><title>java18 - 17hwliao的妙妙屋 - 带派不老铁</title><link rel="shortcut icon" href="/img/site-icon.png">
<link rel="stylesheet" href="/css/style.css" id="dm-light">


<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.2/css/all.min.css">

<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
<!-- 在 head.pug 文件末尾添加--><link rel="stylesheet" href="/css/video.css"/><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="top-nav" ondblclick="scrollToTop()"><div class="nav-info"><div class="nav-icon"><img id="nav-icon" src="/img/site-icon.png"/></div><div class="nav-title"><a id="nav-title" href="/" title="主页">17hwliao的妙妙屋</a></div></div><div class="nav-ribbon"><div class="top-menu-expanded"><a class="top-menu-item" href="/archives"><span>归档</span></a><a class="top-menu-item" href="/categories"><span>分类</span></a><a class="top-menu-item" href="/tags"><span>标签</span></a><a class="top-menu-item" href="/about"><span>关于</span></a></div><div class="top-search" onclick="toggleSearchWindow()"><div id="top-search-btn" title="搜索"><i class="icon fa-solid fa-magnifying-glass"></i><span>搜索</span></div></div><div id="top-menu-btn" onclick="openTopMenu()" title="打开菜单"><i class="fa-solid fa-bars fa-lg"></i></div></div></div></header><div id="top-menu-hidden"><div class="menu-hidden-content"><div class="menu-hidden-nav"><a class="menu-hidden-item" href="/archives"><i class="fa-solid fa-box-archive fa-sm"></i><span>归档</span></a><a class="menu-hidden-item" href="/categories"><i class="fa-regular fa-folder-open fa-sm"></i><span>分类</span></a><a class="menu-hidden-item" href="/tags"><i class="fa-solid fa-tags fa-sm"></i><span>标签</span></a><a class="menu-hidden-item" href="/about"><i class="fa-solid fa-paw fa-sm"></i><span>关于</span></a></div></div><div class="menu-hidden-blank" onclick="closeTopMenu()"></div></div>
<div class="blog-info"><div class="blog-pic"><img id="blog-pic" src="/img/site-icon.png"/></div><div class="blog-title"><i class="fa-solid fa-paw fa-2xs fa-rotate-by"></i><span>17hwliao的妙妙屋</span><i class="fa-solid fa-paw fa-2xs fa-rotate-by"></i></div><div class="blog-desc">这是我的地盘, 我想写啥写啥 , 要你问 .</div></div><div class="main"><div class="main-content"><article class="post"><div class="post-title"><h1><i class="fa-solid fa-paw"></i>java18</h1></div><div class="post-video-container"><div class="meow-video-container"><video controls="controls" width="100%" poster="/img/video-poster.jpg" preload="metadata"><source src="/videos/myvideo.mp4" type="video/mp4"/></video><div class="video-title">欢迎视频</div></div></div><div class="post-info"><div class="post-info-first-line"><div class="post-date"><i class="icon fa-regular fa-calendar-plus" title="发布日期"></i><time class="publish-time">2026-01-24</time><i class="icon fa-regular fa-calendar-check" title="更新日期"></i><time class="update-time">2026-01-24</time></div>

</div><div class="post-info-second-line"><div class="post-copyright"><i class="icon fa-brands fa-creative-commons" title="版权声明"></i><span>版权声明: </span><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans" title="CC BY-NC-ND 4.0">17hwliao-折磨自己使用-禁止模仿</a></div>
<div class="post-word-count"><i class="icon fa-solid fa-pen-to-square"></i><span>傻子码了约2.4K字</span></div><div class="pageview-post"><i class="icon fa-regular fa-eye"></i><span id="busuanzi_container_page_pv">阅读次数: <span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner"></i></span></span></div></div></div><div class="post-content"><p>第二十天学习<br>集合工厂方法<br> List<String> fruit &#x3D; Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);<br>Set<String> fruitSet &#x3D; Set.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);<br>Map&lt;Integer, String&gt; fruitMap &#x3D; Map.of(1, &quot;apple&quot;, 2, &quot;banana&quot;) ;<br>Map&lt;Integer , String&gt; map1 &#x3D; ofEntries(entry(1,&quot;aaas&quot;) ) ; &#x2F;&#x2F;静态创建<br>有序集合功能规范<br>List<String> list &#x3D; new ArrayList&lt;&gt;(List.of(&quot;aaas&quot;, &quot;ssdsa&quot;, &quot;qewq&quot;)) ;<br>我们向视图中进行的插入操作，最终作用到原本的列表上了，并且作用的效果也是相反的。因此，如果你只是单纯希望对列表内部元素进行倒序排序，可以考虑使用我们下面会讲解的Collections工具类，其中包含大量处理集合的操作。<br>而SequencedSet，它是对于Set的扩展，同样添加了头插尾插的操作，但是只有一部分Set集合类实现了此接口。<br>其中SequencedMap相关方法与上述内容类似，这里就不重复讲解了。<br>(Java 8) Stream流<br>效率低 , 传统 :<br>public  static  void  main(String[] args) { 	<br>&#x2F;&#x2F;这是普通的处理<br>List<String> list &#x3D; newArrayList&lt;&gt;();<br>list.add(&quot;A&quot;);<br>list.add(&quot;B&quot;);<br>list.add(&quot;C&quot;); 	<br>&#x2F;&#x2F;移除为B的元素 	<br>Iterator<String> iterator &#x3D; list.iterator();<br>while (iterator.hasNext()){<br>if(iterator.next().equals(&quot;B&quot;)) iterator.remove(); }<br>现代 ,流水线 :<br>&#x2F;&#x2F;这是通过Stream的处理<br> list &#x3D; list &#x2F;&#x2F;链式调用   &#x2F;&#x2F;这里必须要回收<br> .stream() &#x2F;&#x2F;获取流<br>.filter(e -&gt; !e.equals(&quot;B&quot;)) &#x2F;&#x2F;只允许所有不是B的元素通过流水线 收集Boolean元素卡数据<br>.collect(Collectors.toList()); &#x2F;&#x2F;将流水线中的元素重新收集起来，变回List   启动机器<br>System.out.println(list); }<br>区别:<br>传统:每一步需要等到上一步结束之后，拿到上一批数据才能开始下一步，每一个流程依次进行：<br>而Stream则是提前编排好流程，每一个元素依次独立走完流水线，无需按批次完成：<br>List<Integer> list &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6);<br> list.stream()<br>.map(x -&gt; {<br> System.out.println(&quot;我是第一步: &quot; + x); return x; })<br>&#x2F;&#x2F;map可以对实现接受一种类型的数据，转为同类型或另一类型的数据   除映射外可以进行简单的元素处理 ; 90哦<br>.map(x -&gt; {<br>System.out.println(&quot;我是第二步: &quot; + x); return x; })<br> .forEach(System.out::println);    &#x2F;&#x2F;机器启动<br>&#x2F;&#x2F;惰性的体现<br>要让stream流开动,必须使用collect(Collector.toList()) || forEach( 操作 );<br>由于filter中进行了过滤操作，很多元素在进入到第三步之前就被提前丢弃了。这在处理大量数据的时候非常有效，一次性处理全部数据会占用非常多的内存，而通过流水线一步一步进行，依次进行数据处理会省去很多内存开销。<br>常见操作<br>list &#x3D; list .stream() 			<br>.distinct() &#x2F;&#x2F;去重（使用equals判断）<br>.sorted((a, b) -&gt; b - a) &#x2F;&#x2F;进行倒序排列<br> .map(e -&gt; e+1) &#x2F;&#x2F;每个元素都要执行+1操作<br>.limit(2) &#x2F;&#x2F;只放行前两个元素<br> .collect(Collectors.toList());<br>Random   random&#x3D;  new   Random(); Random支持直接生成随机数的流<br>random<br>   .ints(-100, 100) &#x2F;&#x2F;生成-100~100之间的，随机int型数字（本质上是一个IntStream）<br> 		.limit(10) &#x2F;&#x2F;只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）<br>  .filter(i -&gt; i &lt; 0) &#x2F;&#x2F;只保留小于0的数字 .sorted() &#x2F;&#x2F;默认从小到大排序<br>  .forEach(System.out::println); &#x2F;&#x2F;依次打印<br>StreamAPI提供的快捷操作，我们可以创建一个IntSummaryStatistics统计实例对象来帮助我们快速进行统计：IntSummaryStatistics 是 Java 8 引入的一个统计工具类，专门用于对 int 类型的数据进行统计计算。它属于 java.util 包，通常与 Stream API 一起使用。<br>基本概念<br>IntSummaryStatistics 可以一次性地计算多个统计指标：<br>计数（count）<br>求和（sum）<br>最小值（min）<br>最大值（max）<br>平均值（average）<br>publicstaticvoidmain(String[] args) {<br>Random   random&#x3D;new   Random(); &#x2F;&#x2F;Random是一个随机数工具类<br>IntSummaryStatisticsstatistics&#x3D; random<br>.ints(0, 100)<br>.limit(100) .summaryStatistics(); &#x2F;&#x2F;获取语法统计实例<br>System.out.println(statistics.getMax()); &#x2F;&#x2F;快速获取最大值<br>System.out.println(statistics.getCount()); &#x2F;&#x2F;获取数量<br>System.out.println(statistics.getAverage()); &#x2F;&#x2F;获取平均值 }<br>java普通的List只需要一个方法：<br>通过flatMap来对整个流进行进一步细分：<br> List<String> list &#x3D; newArrayList&lt;&gt;();<br>list.add(&quot;A,B&quot;);<br>list.add(&quot;C,D&quot;);<br>list.add(&quot;E,F&quot;); &#x2F;&#x2F;我们想让每一个元素通过,进行分割，变成独立的6个元素<br>list &#x3D; list .stream() &#x2F;&#x2F;生成流<br> .flatMap(e -&gt; Arrays.stream(e.split(&quot;,&quot;))) &#x2F;&#x2F;&quot; , &quot;分割字符串并生成新的流<br>.max( Collectors.naturalOrder() ) 	&#x2F;&#x2F;实现按自然顺序排序<br>.collect(Collectors.toList()); &#x2F;&#x2F;汇成新的List<br>System.out.println(list); &#x2F;&#x2F;得到结果<br>只通过Stream来完成所有数字的和，使用reduce方法：<br> List<Integer> list &#x3D; newArrayList&lt;&gt;();<br>list.add(1); list.add(2); list.add(3);<br>int   sum&#x3D; list .stream()<br>.reduce((a, b) -&gt; a + b) &#x2F;&#x2F;计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和<br> .get(); &#x2F;&#x2F;我们发现得到的是一个Optional类实例，通过get方法返回得到的值<br>System.out.println(sum);<br>Stream增强方法<br>集合类可以很轻松地转换为Stream：<br>java<br>Java 8为我们提供了of方法用于快速将数组或单个元素包装为Steam对象：<br>java<br>Java 9之后，对于可能为null的元素，我们也可以使用ofNullable方法来包装，如果发现传入的为null则返回一个空的Stream。只能传单个元素判断 ;<br>takeWhile操作：<br>java<br>dropWhile会尝试不断丢弃，直到第一个不满足条件的出现，才开始依次把元素往下一个流水线输送。<br>针对于String类型，我们也可以使用流的形式处理其中的每一个字符：<br>java<br>lines()方法，它会自动对字符串按行分割，返回每一行的子串流。<br>在Java 16中，Stream中的操作被进一步强化，其中最有用的是常用的List收集被直接整合为了一个方法：<br>java复制代码<br>流聚集器<br>传统Stream操作是无状态的，每个元素处理的流程单独进行，而Gatherers可以在处理过程中的同时维护状态，让前面元素的处理结果影响后续元素的处理方式，<br>我们现在需要将包含[A, B, C, D]的流进行两两分组，得到[[A, B],[C, D]]然后再处理成每个分组内两个字符串合并的字符串，最后得到[AB, CD]<br>List<String> list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);<br>list.stream() &#x2F;&#x2F;需要使用Collectors的groupingBy工具进行分组，得到Map<br> .collect(Collectors.groupingBy(s -&gt; list.indexOf(s) &#x2F; 2)) 			<br>&#x2F;&#x2F;把Map的值全部取出来，在转为stream<br>.values() .stream() .map(group -&gt; group.get(0) + group.get(1))<br>.forEach(System.out::println);<br>又有了Gatherers之后，我们可以像这样写：windowFixed就实现了对元素的有状态操作，它不断接受到来的元素，并将其暂存，达到窗口大小之后作为一个新的元素打包返回。<br>List<String> list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);<br>list.stream()<br>        .gather(Gatherers.windowFixed(2))  &#x2F;&#x2F;使用Gatherers的windowFixed创建固定窗口，元素将按照窗口大小自动进行分组<br>        .map(item -&gt; item.getFirst() + item.getLast())<br>        .forEach(System.out::println);<br>当然，这里只是简单演示Gatherer的功能，Gatherer.of还包含更多参数选项。<br>此外，官方还为我们提供了一些其他的预设的工具，比如fold，它是一个多对一的有状态收集器，有点类似于reduce的感觉，比如我们想实现列表去重功能：<br>java复制代码<br>Java<br>List<String> list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;A&quot;, &quot;C&quot;);<br>list.stream()    &#x2F;&#x2F;让HashSet作为初始状态存储工具<br>        .gather(Gatherers.fold(HashSet::new, (set, item) -&gt; {<br>            set.add(item);   &#x2F;&#x2F;向Set中添加元素<br>            return set;   &#x2F;&#x2F;操作完成后需要返回set用于下一轮<br>        }))<br>        .flatMap(Collection::stream)  &#x2F;&#x2F;对得到的Set集合展平<br>        .forEach(System.out::println);<br>接着是scan，它会依次扫描流中每个元素，并会在下一轮中给出上一轮被扫描过的元素，这很适合那些需要用到上一轮计算结果的操作。比如我想让列表[A, B, C, D]变成[A, AB, ABC, ABCD]这种金字塔状，就可以使用这种操作完成：<br>List<String> list &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);<br>list.stream()<br>        .gather(Gatherers.scan(() -&gt; &quot;0&quot;, (current, item) -&gt; current + item))<br>        .forEach(System.out::println);</p>
</div><div class="post-end"><div class="post-prev"></div><div class="post-reward" onclick="openPostReward()" title="赞赏"><i class="fa-regular fa-thumbs-up fa-xl fa-beat-fade"></i></div><div id="reward-panel" onclick="closePostReward()"><div class="reward-container"><p>作者快被折磨死了，给点银子都给你了, 连我也给你了 &#128151;</p>
<div class="reward-nav"><div class="reward-item"><img class="reward-img" src="/img/reward/wechat.jpg" title="Wechat" alt="Wechat"/><span>Wechat</span></div><div class="reward-item"><img class="reward-img" src="/img/reward/alipay.jpg" title="Alipay" alt="Alipay"/><span>Alipay</span></div></div></div></div><div class="post-next"><a href="/2026/01/22/acwing37/" title="下一篇文章"><i class="fa-solid fa-chevron-right fa-lg"></i></a></div></div></article><div class="comment" id="comment"><script src="https://giscus.app/client.js" data-repo="17hwliao/17hwliao.github.io" data-repo-id="R_kgDOQgIQiw" data-category="Announcements" data-category-id="DIC_kwDOQgIQi84CznR2" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light_high_contrast" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async="async"></script></div><div id="post-toc"><aside class="toc-aside"><div class="toc-title"><span><i class="fa-solid fa-paw"></i>目录</span></div><div class="toc-container" id="toc-body"></div></aside><div class="toc-blank" onclick="tocToggle()"></div></div></div></div><div id="tool-bar"><div id="tool-bar-main"><div id="tool-toggle" onclick="toolToggle()" title="设置"><i class="fa-solid fa-gear"></i></div><div id="toc-toggle" onclick="tocToggle()" title="目录"><i class="fa-solid fa-list-ul"></i></div><div id="go-to-comment" onclick="gotoComment()" title="评论"><i class="fa-regular fa-message fa-flip-horizontal"></i></div><div id="back-to-top" onclick="scrollToTop()" title="返回顶部"><i class="fa-solid fa-chevron-up"></i></div></div><div id="tool-bar-more" style="display: none;"><div id="darkmode-switch" onclick="darkmodeSwitch()" title="深色模式"><i class="fa-solid fa-circle-half-stroke"></i></div><div id="font-size-increase" onclick="fontSizeIncrease()" title="放大字体"><i class="fa-solid fa-plus"></i></div><div id="font-size-decrease" onclick="fontSizeDecrease()" title="缩小字体"><i class="fa-solid fa-minus"></i></div></div></div><div id="search-panel"><div class="search-container"><div class="search-head"><div class="search-title"><span><i class="fa-solid fa-paw"></i>搜索</span></div><div class="search-close-btn" onclick="toggleSearchWindow()"><i class="fa-regular fa-circle-xmark"></i></div></div><div class="search-box"><i class="fa-solid fa-magnifying-glass"></i><input id="search-input" type="text" placeholder="请输入需要搜索的内容……" value=""/></div><div class="search-body"><div id="search-count">匹配结果数: </div><div id="search-result"></div><div id="search-result-empty">未搜索到匹配的文章。</div></div></div></div><footer><div class="footer-content"><div class="copyright-info"><i class="fa-regular fa-copyright fa-xs"></i><span>2024 - 2026 </span><a href="/about">17hwliao</a><i class="fa-solid fa-cat fa-sm"></i><span>Powered by </span><a href="https://hexo.io/" target="_blank">Hexo</a><span> &amp; </span><a href="https://github.com/chanwj/hexo-theme-meow" target="_blank" title="v2.1.5">Theme Meow</a></div><div class="pageview-site"><span id="busuanzi_container_site_pv">总访问量 : <span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner"></i></span></span><span id="busuanzi_container_site_uv">总访客数 : <span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner"></i></span></span></div></div></footer><!-- 在 footer.pug 文件末尾添加--><script src="/js/video.js"></script>
<script>const GLOBAL_CONFIG = {
  comment: { theme: 'light_high_contrast'}
}
</script>
<script src="/js/third-party/darkmode.js"></script>
<script>var options = {
  dark: '/css/darkmode.css',
  startAt: '24:00',
  endAt: '06:00',
  checkSystemScheme: 'false',
  saveOnToggle: 'true'
};
var darkMode = new DarkMode(options);
// change comment theme synchronously 同步修改评论区主题
if (darkMode.getMode() == "dark" && (true || true)) {
  if (document.getElementById('comment')) {
    document.getElementById('comment').getElementsByTagName('script')[0].setAttribute('data-theme', 'noborder_dark');
  }
}
</script><script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post-content').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/theme/tool-bar.js"></script>


<script src="/js/theme/menu.js"></script>


<script src="/js/third-party/clipboard.min.js"></script>


<script src="/js/theme/copy.js"></script>
<script>copyCode();
</script>
<script src="/js/theme/reward.js"></script>

<script src="/js/jquery-3.7.1.min.js"></script>


<script src="/js/theme/search.js"></script>
<script>searchFunc('/search.xml', 'search-input', 'search-result');
</script></body></html>