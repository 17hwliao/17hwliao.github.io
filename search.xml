<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java17</title>
      <link href="/2026/01/20/java17/"/>
      <url>/2026/01/20/java17/</url>
      
        <content type="html"><![CDATA[<p>Map映射<br>元素之间是两两对应的，是以键值对的形式存在。<br>Map接口 :<br>&#x2F;&#x2F;Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊<br>&#x2F;&#x2F;这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的<br>public interface Map&lt;K,V&gt; {<br>&#x2F;&#x2F;-------- 查询相关操作 -------- <br>&#x2F;&#x2F;获取当前存储的键值对数量<br>int size();<br>&#x2F;&#x2F;是否为空<br>boolean isEmpty();<br>&#x2F;&#x2F;查看Map中是否包含指定的键<br>boolean  containsKey(Object key);<br>&#x2F;&#x2F;查看Map中是否包含指定的值<br>boolean  containsValue(Object value);<br>&#x2F;&#x2F;通过给定的键，返回其映射的值<br>V get(Object key);<br>&#x2F;&#x2F;-------- 修改相关操作 --------<br>&#x2F;&#x2F;向Map中添加新的映射关系，也就是新的键值对<br> V put(K key, V value);<br>&#x2F;根据给定的键，移除其映射关系，也就是移除对应的键值对<br>V remove(Object key); 注意这里有返回值 ; 可以获取键对应的值<br>&#x2F;&#x2F;-------- 批量操作 --------&#x2F;&#x2F;<br>将另一个Map中的所有键值对添加到当前Map中<br>void  putAll(Map&lt;? extends K, ? extends V&gt; m);<br>&#x2F;&#x2F;清空整个Map<br>void clear();<br>&#x2F;&#x2F;-------- 其他视图操作 --------<br>&#x2F;&#x2F;返回Map中存放的所有键，以Set形式返回<br> Set<K> keySet();    ----只包含key<br>&#x2F;&#x2F;返回Map中存放的所有值<br>Collection<V> values();     ---只包含vaule<br>&#x2F;&#x2F;返回所有的键值对，这里用的是内部类Entry在表示<br>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();      ---下面是其定义<br>&#x2F;&#x2F;这个是内部接口Entry，表示一个键值对<br>interfaceEntry&lt;K,V&gt; {<br>&#x2F;&#x2F;获取键值对的键<br> K getKey();<br>&#x2F;&#x2F;获取键值对的值<br> V getValue();<br>&#x2F;&#x2F;修改键值对的值<br> V setValue(V value);<br>&#x2F;&#x2F;判断两个键值对是否相等<br>boolean  equals(Object o);<br>&#x2F;&#x2F;返回当前键值对的哈希值<br>int   hashCode(); ... } ... }<br>&#x2F;&#x2F;Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的：<br>&#x2F;&#x2F;安全插入 , 若有值不会覆盖, ;<br>map.putIfAbsent(2,&quot;xiao&quot;) ;<br>&#x2F;&#x2F;我们在获取一个不存在的映射时，默认会返回null作为结果<br>&#x2F;&#x2F;我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值<br>map.getOrDefault(3, &quot;备胎&quot;)<br>&#x2F;&#x2F;同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的：基础的123还是可以的 , 符号就不行了<br>&#x2F;&#x2F;如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护<br>操作和HashMap&lt;&gt;() 内部方法相同 ; 只是维护了插入顺序 ;<br>遍历map , 不能直接用for , 没接口 ,但内部接口 Entry 实现了itearable接口 可以直接for ;<br>map.entrySet().for ; 实现迭代 ;<br>简单实现替换  : V<br>注意看这里不是BiConsumer接口( 这个不会返回值 ) 详见函数式接口<br>1修改现有值2如果 key 不存在，创建新值<br>V compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)  需要返回一个V值 ;<br>map.compute(1,(key , value) -&gt; value + &quot;A&quot; ) ;<br>map.merge(1,&quot;qaa&quot; , (o1 ,o2) -&gt; o1 + o2 );  内部是返回值的函数接口 ;  &#x3D; Integer:: sum ;<br>底层采用的是哈希表<br>哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过链地址法解决这种问题，最后哈希表就长这样了<br>实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是差不多的实现，我们来看看这里面是怎么定义的：<br>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;<br>    implements Map&lt;K,V&gt;, Cloneable, Serializable {<br>}<br>比较相关接口( 和自动排序, 和sort排序密切相关 )<br>compareTo  实际上是因为这个类实现了Comparable接口获得的方法，我们常见的一些JDK提供的类型，如String、基本类型包装类、Date、LocalDate等，其实都实现了此接口，从而自带对于其类型对象之间的比较操作：<br>String s1 &#x3D; &quot;AAA&quot;, s2 &#x3D; &quot;BBB&quot;;<br>System.out.println(s1.compareTo(s2));  &#x2F;&#x2F;按字典顺序比较两个字符串,比较基于字符串中每个字符的 Unicode 值。<br>需要实现排序功能需要自己手动implements Comparable&lt;元素&gt; 接口 ;<br>可以重写下方法;<br>public   int   compareTo(Student o) {<br>return age - o.age; &#x2F;&#x2F;直接比较年龄<br> }<br>@Override<br>public String toString() { return&quot;Student{&quot; + &quot;age&#x3D;&quot; + age + &#39;}&#39;; }<br>TreeSet 内部还有Comparator接口 : 调用时也可以在构造时写入比较器( 规则 ) [ 内部自动实现的排序 ]<br> 创建一个比较器 ; Comparator<Student> comparator &#x3D; ( 比较规则 ) ;<br>TreeSet&lt;元素&gt; set &#x3D; new TreeSet&lt;&gt;( comparator.reversed() ) ;   反转排序 ;<br>添加次级比较规则 : 函数式接口 -&gt; comparator.thencomparing(o1 , o2 ) -&gt; o1.元素.compareTo( o2.元素 ) ;   由于内部红黑数比较comparator比较结果是相等 , 那么自动判读为两元素相等, 不会实现覆盖原来Tree中的内容 ;<br>&#x2F;&#x2F;上面的进阶版，可以自定义类中属性(作为key)的获取规则，并对此属性进行比较<br>default <U> Comparator<T> thenComparing(<br>Function&lt;? super T, ? extends U&gt; keyExtractor,          &#x2F;&#x2F;先写清楚获取元素的方法 , 之后lambda中的元素自动为方法元素 ;<br>Comparator&lt;? super U&gt; keyComparator) {<br>return thenComparing(comparing(keyExtractor, keyComparator));<br>}<br>&#x2F;&#x2F;针对于特定内置类型的提取并比较，同上，后续同理<br>default Comparator<T> thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)<br> { return thenComparing(comparingInt(keyExtractor)); }<br>TreeSet中实现的String比较方法实现Comparator.reverseOrder() ; 内部封装好了 , 可以直接使用 ;<br>&#x2F;&#x2F;------以下是所有的静态方法，可以直接生成一个新的Comparator对象<br>&#x2F;&#x2F;生成一个指定类型（需要实现Comparable）的反向比较器<br>public   static &lt;T extends   Comparable&lt;? super T&gt;&gt; Comparator<T> reverseOrder()<br> { return Collections.reverseOrder(); }<br>&#x2F;&#x2F;生成一个指定类型（需要实现Comparable）的正向比较器<br>@SuppressWarnings(&quot;unchecked&quot;)<br>publicstatic &lt;T extends    Comparable&lt;? super T&gt;&gt; Comparator<T> naturalOrder()<br>{ return (Comparator<T>) Comparators.NaturalOrderComparator.INSTANCE; }<br>&#x2F;&#x2F;生成一个指定类型的正向比较器，且针对于null值，会优先排到前面<br>public   static <T> Comparator<T> nullsFirst(Comparator&lt;? super T&gt; comparator) { return     newComparators.NullComparator&lt;&gt;(true, comparator); }<br>&#x2F;&#x2F;生成一个指定类型的正向比较器，且针对于null值，会直接排到后面<br>publicstatic <T> Comparator<T> nullsLast(Comparator&lt;? super T&gt; comparator) {<br>return   new   Comparators.NullComparator&lt;&gt;(false, comparator); }<br>实际使用时 Comparator.null---(Comparator.naturalOrder()) ;<br>&#x2F;&#x2F;传入一个指定类型用于比较的Key的获取方式，然后再传入Key的比较操作实现 , 泛型方法 ;<br>Comparator<br>public   static &lt;T, U&gt; Comparator<T> comparing(<br>Function&lt;? super T, ? extends U&gt; keyExtractor,<br>Comparator&lt;? super U&gt; keyComparator)<br>{ Objects.requireNonNull(keyExtractor);<br>Objects.requireNonNull(keyComparator);<br>return (Comparator<T> &amp; Serializable)<br> (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),<br>keyExtractor.apply(c2)); }<br>&#x2F;&#x2F;传入一个指定类型用于比较的Key（需要实现Comparable）的获取方式，然后自动进行比较<br>public  static &lt;T, U extendsComparable&lt;? super U&gt;&gt; Comparator<T> comparing(<br>Function&lt;? super T, ? extends U&gt; keyExtractor) {<br>Objects.requireNonNull(keyExtractor);<br>return (Comparator<T> &amp; Serializable)<br>(c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2)); }<br>&#x2F;&#x2F;针对于内置类型的<br>public   static <T> Comparator<T> comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)<br> { Objects.requireNonNull(keyExtractor);<br>return (Comparator<T> &amp; Serializable)<br>(c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2)); } ... }<br>实现可以比较的类<br>&#x2F;&#x2F; 构造时传入比较器<br>    public SortableList(Comparator<T> comparator) {<br>        this.list &#x3D; new ArrayList&lt;&gt;();<br>        this.comparator &#x3D; comparator;<br>    }<br>想实现逆向.就在后面comparing后面加一个.reversed()即可 ;<br>因为是泛型类 &lt;需要后期标清楚类型&gt; ;<br>Collections工具类 ;<br>集合中的&quot;Arrays&quot; :<br> List<Integer> list &#x3D; newArrayList&lt;&gt;(Array.aslist(  ));<br>&#x2F;&#x2F;快速获取到最大最小值 ;<br>Collections.max(list);<br> Collections.min(list);<br>同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类 必须实现排序)：<br>Collections.binarySearch(list, 8)<br>也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：<br>Collections.fill(list, 6);    &#x2F;&#x2F;集合中本身没有元素，那么fill操作不会生效。<br>可能需要生成一个空的集合类返回，那么我们可以使用emptyXXX来快速生成一个只读的空集合：<br> List<Integer> list &#x3D; Collections.emptyList(); &#x2F;&#x2F;Collections.singletonList()  , 可以用于创建List , 会生成一个只有一个元素的List list.add(10); &#x2F;&#x2F;不支持，会直接抛出异常 , 以上标记数组都不会再次发生变化 ;<br>List<Integer> newList &#x3D; Collections.unmodifiableList(list);    &#x2F;&#x2F;相当final 无法实现修改 ;<br>寻找子集和的位置 :<br>Collections.indexOfSubList(list, Arrays.asList(4, 5))<br>类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：<br> &#x2F;&#x2F;使用原始类型接收一个Integer类型的ArrayList<br>List list&#x3D;newArrayList&lt;&gt;(Arrays.asList(1,2,3,4,5));   Lisr此处不标签类型 ;<br>list.add(&quot;aaa&quot;); &#x2F;&#x2F;我们惊奇地发现，这玩意居然能存字符串进去<br>额外的洗牌功能 : Collections.shuffle(list) ;<br>在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查<br>Collections.checkedList(list, Integer.class); &#x2F;&#x2F;这里的.class关键字我们会在后面反射中介绍<br>checkedXXX可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：<br>表示Integer这个类型 list.add(&quot;aaa&quot;);  只要是Object类型就可以实现填入<br>import java.io.<em>;<br>import java.util.</em>;</p><p>public class Main {</p><pre><code>public static void main(String[] args)  &#123;    Map&lt;Integer , String&gt; map = new HashMap&lt;&gt;() ;    map.put(1,&quot;xiao&quot;) ;    map.put(2,&quot;ming&quot;) ;    map.putIfAbsent(2,&quot;xiao&quot;) ;    System.out.println(map);    System.out.println(map.get(2));    System.out.println(map.getOrDefault(4, &quot;gay&quot;));    Map&lt;Integer, String&gt; map2 = new LinkedHashMap&lt;&gt;() ;    System.out.println(map.containsKey(1));    Set&lt;Map.Entry&lt;Integer , String&gt;&gt; entries = map.entrySet() ;    for(Map.Entry&lt;Integer , String &gt; entry : entries) &#123;        Integer key = entry.getKey() ;        String value = entry.getValue() ;        System.out.println(&quot;key = &quot;+key+&quot;value = &quot;+value);    &#125;    map.forEach((key , value) -&gt; &#123;        System.out.println(&quot;key = &quot;+key+&quot;value = &quot;+value);    &#125;);    map.compute(1,(key , va) -&gt; &#123;        System.out.println(&quot;key = &quot;+key+&quot;value = &quot;+va);        return va ;    &#125; ) ;    map.merge(1,&quot;qaa&quot; , (o1 ,o2) -&gt; o1 + o2 );    System.out.println(map.get(1));    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3,4)) ;    Collections.sort(list);    System.out.println(list);&#125;static class  Student  &#123;    int age ;    String name ;    public Student(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;    public String toString() &#123;        return &quot;Student [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gitLearn</title>
      <link href="/2026/01/17/gitLearn/"/>
      <url>/2026/01/17/gitLearn/</url>
      
        <content type="html"><![CDATA[<p>学习Git技术 :<br>Git工作原理 :<br>大致分为四个板块 :<br>工作目录 : 存放正在写的代码  ( 开发完成之后 , 实现新版本提交 )<br>暂存区 : 保存待提交内容 ( 新版本提交会存放到本地仓库 )<br>本地仓库 : 位于本地的版本控制仓库( 存放当前项目各个版本之间代码的增删情况 )<br>远程仓库 : 服务器上的版本控制仓库( 服务器上的版本信息可以通过本地仓库实现推送 , 也可以从服务器上抓取文件到本地仓库 )<br>Git是分布式的控制系统</p><p>因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。</p><p>Git下载之后 :<br>建议进入 git bush<br>git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;<a href="mailto:&#101;&#109;&#97;&#x69;&#x6c;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;">email@example.com</a>&quot;<br>Git 的基本命令<br>git init  引导路径到目标文件 , 然后执行该命令<br>输入后，会自动生成一个.git目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。<br>其余空间全是工作区<br>git status 检测本地仓库状态<br>以下为显示　：　<br>On branch master  : 在master 分支上<br>No commits yet : 没有文件可以提交  , 空状态 ; </p><p>git add hello.txt #也可以 add . 一次性添加目录下所有的<br>实现将未追踪文件添加到暂存区，那么它会自动变为被追踪状态</p><p>git commit -m &#39;输入描述&#39;    &#x2F;&#x2F;这里提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容<br>git log 查看提交记录   git log --oneline 会缩减为一行 , 方便查看 ;<br> git log --graph 可以使用图形方式显示 , 需要有分支才可查看<br>git show (不加会自动返回最近提交的)[后面加上commit ID查看指定的提交记录]  可以超原文也可以抄简写版的但一定要保证唯一<br>创建 .gitignore 文件 , 确定一个文件忽略列表,如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查</p><p>写入 <em>.txt  &#x2F;&#x2F; 这样就会匹配所有以txt结尾的文件<br>!文件名.txt  &#x2F;&#x2F; 虽然上面排除了所有txt结尾的文件，但是这个不排除<br>test&#x2F;      &#x2F;&#x2F; 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略<br>xxx&#x2F;</em>.txt  &#x2F;&#x2F; 目录中所有以txt结尾的文件，但不包括子目录 ( 可以混搭 )<br>xxx&#x2F;**&#x2F;*.txt    &#x2F;&#x2F; 目录中所有以txt结尾的文件，包括子目录</p><p>实现添加和提交<br>git status 获取当前仓库信息<br>未追踪文件 会飘红<br>其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们 git add 将其添加到暂存区，那么它会自动变为被追踪状态;<br>使用add 操作 , 然后查看仓库信息 , 该文件变为待提交  ( 即在暂存区 )<br>git commit -m &#39;输入描述&#39;  &#x2F;&#x2F;实现提交 ;<br>实现一些修改之后再次调用git status ;<br>显示  modified:   hello .txt ; &#x2F;&#x2F;变为已修改状态<br>还是需要先 git add 新文件 , 转化文件到暂存区  , 然后再调用git commit -m &quot;描述&quot; 实现修改版本号上传<br>也可以直接使用 git commit -a -m &#39;描述&#39; 直接实现转存至暂存区 ;<br> 可以使用 展示修改  ; </p><p>回退<br>当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：<br>git reset --hard  [ commitID ]   执行后，会直接重置为创建ID时的状态。再次查看提交日志，我们发现之后的日志全部消失了。  &#x2F;&#x2F;忽略名单中的东西不会受回滚影响 ;<br>git reflog 不会随reset清理 , 全部记录 , 执行后输出全部版本号 , 和提示语 ;<br>再使用reset 实现回退到新旧版本 ; </p><p>分支<br>因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。<br>实现将一个项目分为两个方向不同的项目 ;<br>Linux命令 :<br>查看当前目录文件 ls ;<br>+隐藏文件 ls -a ;<br>+文件详细信息 ls -l ;<br>俩都要实现 ls -al ;<br>total : 磁盘大小<br>文件权限和类型  链接数  文件作者 文件所属组  文件大小（字节)  最后修改时间<br>pwd : 显示当前目录位置 ; ( Linux系统无盘符概念 )<br>mkdir 文件夹  &#x2F;&#x2F;在当前目录下创建文件夹<br>cd 文件夹 进入文件夹 ; cd .. ( 一个. 是当前 , 两个..是上一级 ) 退出文件夹 ; cd - 回退到上一次目录;<br>cat 文件名.文件类型 可以直接输出文件内容 ;<br>自带编辑器可以实现修改代码  vi 文件名.文件类型 ; </p><p>查看存在分支 : git branch 执行后会展示当前分支 ;<br>git branch 分支名  实现创建一个新的分支 ;<br>git branch -d 分支名 实现删除一个分支 ;<br>git commit -a -m &#39;提示词&#39; ;    &#x2F;&#x2F;实现添加到缓存区 + 提交<br>git log --all( 不写只显示当前分支 ) --graph --oneline ;   显示日志  ;<br>git checkout 分支名字 &#x2F;&#x2F;实现切换分支<br>实现切换分支之后文件的版本会随分支的版本进行修改  ;<br>分支之间互相不会干扰  , 相同文件名在不同分支状态下打开截然相反 , 相互隔离 ;<br>git checkout master   合并分支前需要实现切换回主分支上去 ;<br>git merge test  利用merge 实现强制合并 , 相同文件名不同版本号会出现冲突 ;<br>强行合并之后 , 冲突文件会同时包含两种修改思路 , 需要删除不需要的, 保留需要的;<br>执行文件任何修改都需要 git commit -a -m &#39;提示词&#39; ;<br>实现合并之后分支并不会消失 , 可以在合并后的分支中继续编写, 也可以在旧分支中继续编写;<br>合并并不是真实合并 ; 只是把分支中的提交实现了合并而已<br>git diff  可以查看是哪里出现了冲突 ; 其实合并之后打开文件看到的冲突更清晰</p><p>内部编译器 vi的使用 :<br>先按按键 i 变为insert可以实现输入 ;<br>按o实现下一行;<br>实现合并分支时可能会跳出编译器界面<br>Merge commit.<br>按下按键Esc 实现退出 ;<br>:wq 敲出冒号和 wq就可以实现退出编译器 ; </p><p>变基分支<br>接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：<br>git rebase master ;<br>yyds分支相当于同步了此前master分支的全部提交。<br>变基实现同步之后 , 在对任意一个做修改+提交 , 仍然会出现分支情况 ; </p><p>优选<br>选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick<br>git cherry-pick <commit id>:单独合并一个提交<br>会直接将这个id 在别的分支上的修改提交连提示词都照抄到当前分支</p><p>IDEA版本控制<br>这里的.gitignore 就是忽略 , 在版本更新中需要追踪的文件都在src中 ,其他包括开发环境 , 动态生成文件都需要忽略;<br>这里 .文件名, 是隐藏文件 ;<br>!表示不要忽略后面路径文件 ;<br>*单个表示 0 &#x2F; n 个字符 , ** 两个表示 0 &#x2F; n 个目录 ;<br>此处是保留所有路径下src&#x2F;中的bin目录 ;<br>实现版本控制找到Version control -Create Git repository<br>控制到根目录即可 ;<br>添加快捷按钮 :<br>右键点击 顶部工具栏空白处<br>选择 Customize Menus and Toolbars...<br>选择 Main Toolbar<br>点击 Add After...<br>找到 VCS → VCS Operations<br>添加需要的操作按钮<br>add全部文件后 点击左栏的commit 进行提交<br>需要回滚的时候<br>之前reset hard commit-ID 就是硬<br>控制行代码执行 :<br> git -c credential.helper&#x3D; -c core.quotepath&#x3D;false -c log.showSignature&#x3D;false reset --hard 57a1808511f12cf8dacbd82b4da7260140d83429<br>右击标签可以merge<br>日志左边的樱桃即是樱桃 ;<br>远程仓库 ( 实现团队操作 )<br>远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。<br>公有 : GitHub、码云、Coding等<br>私有 : 私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。<br>git remote add 名称 远程仓库地址  创建新仓库之后会提供http ;<br>可能需要连接时登陆账户 : 可以拿http的token 去登陆 , 也可以一劳永逸直接获取SSH密钥 ;<br> ssh-keygen -t rsa<br>cat ~&#x2F;.ssh&#x2F;github.pub<br>需要在GitHub上传密钥<br>git push 远程仓库名称 本地分支名称[:远端分支名称]<br>远程仓库也可以实现分支 ;<br>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：<br>在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）</p><p>克隆项目<br>git clone 远程仓库地址</p><p>合作开发<br>需要提供token ,或者提供Manage access 实现推送文章<br>抓取、拉取和冲突解决<br>别人和你同版本先提交 , 会出现推送错误<br>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：,<br>git fetch 远程仓库 #抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交<br>git pull 远程仓库 #拉取：获取+合并  直接pull 就行了 , 获取后会显示那些conflicts文件 , 手动打开, 合并即可;<br>git merge origin&#x2F;main     # 合并 origin 的 main 分支<br>在IDEA上推送就是push , 需要定义远程 ;<br>可以在settings中的版本控制中设置自己 的github远程仓库 , 令牌即token ; </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing36</title>
      <link href="/2026/01/17/acwing36/"/>
      <url>/2026/01/17/acwing36/</url>
      
        <content type="html"><![CDATA[<p>题目1 : bfs 找宝藏 :   设计动态数组 , 大小resize 设置题目大小<br>typedef pair&lt;int, int &gt; PII;<br>vector<string> g;          &#x2F;&#x2F;创建储存数组<br>vector&lt;vector<bool>&gt; visited;     &#x2F;&#x2F;标记状态</p><p>bool bfs(int x, int y, int n, int m) {<br>初始化 : 队列传值, 初始状态 ;<br>    queue<PII> q;<br>    q.push(make_pair(x, y));<br>    visited[x][y] &#x3D; true;</p><pre><code>bool tre = false; //判断有无宝藏int dx[4] = &#123; 0, 1, -1, 0 &#125;;int dy[4] = &#123; 1, 0, 0, -1 &#125;;</code></pre><p>&#x2F;&#x2F;开始对队列循环<br>    while (!q.empty()) {<br>&#x2F;&#x2F;判断队列中元素是否达标:<br>        int qx &#x3D; q.front().first;<br>        int qy &#x3D; q.front().second;<br>        q.pop();<br>        if (g[qx][qy] &gt;&#x3D; &#39;2&#39; &amp;&amp; g[qx][qy] &lt;&#x3D; &#39;9&#39;) {<br>            tre &#x3D; true;<br>        }<br>&#x2F;&#x2F;遍历可能的全部方向 ;<br>        for (int d &#x3D; 0; d &lt; 4; d++) {<br>            int nx &#x3D; qx + dx[d];<br>            int ny &#x3D; qy + dy[d];<br>&#x2F;&#x2F;判断条件 + 压入队列 + 标记 ;<br>            if (nx &gt;&#x3D; 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;&#x3D; 0 &amp;&amp; ny &lt; m<br>                &amp;&amp; g[nx][ny] !&#x3D; &#39;0&#39; &amp;&amp; !visited[nx][ny]) {<br>                visited[nx][ny] &#x3D; true;<br>                q.push(make_pair(nx, ny));<br>            }<br>        }<br>    }<br>按照思路返回值 ;<br>    return tre;<br>}</p><p>int main() {<br>    int n, m;<br>    cin &gt;&gt; n &gt;&gt; m;</p><pre><code>g.resize(n);visited.resize(n, vector&lt;bool&gt;(m, false));for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; g[i];&#125;int island = 0;int tre = 0;for (int i = 0; i &lt; n; i++) &#123;    for (int j = 0; j &lt; m; j++) &#123;        if (g[i][j] != &#39;0&#39; &amp;&amp; !visited[i][j]) &#123;            island++;            if (bfs(i, j, n, m)) &#123;                tre++;            &#125;        &#125;    &#125;&#125;cout &lt;&lt; island &lt;&lt; &quot; &quot; &lt;&lt; tre &lt;&lt; endl;return 0;</code></pre><p>}</p><p>题目2 : dijkstra算法找最短路径 ;<br>typedef pair&lt;int, int&gt; PII;<br>const int N &#x3D; 2e5 + 17 ;<br>&#x2F;&#x2F;按照数据稀疏使用邻接表 , 邻接矩形<br>int h[N], e[N * 2], ne[N * 2], idx;<br>int w[N * 2];   &#x2F;&#x2F;存储权值<br>int dist[N];      &#x2F;&#x2F;路径长度<br>bool visited[N];</p><p>void add(int a, int b, int c) {<br>    e[idx] &#x3D; b;<br>    ne[idx] &#x3D; h[a];<br>    w[idx] &#x3D; c;<br>    h[a] &#x3D; idx++;<br>}</p><p>int dijkstra(int n) {<br>    memset(dist, 0x3f, sizeof dist);<br>    dist[1] &#x3D; 0;</p><pre><code>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;   //小顶堆 ; &lt;长度 , 序号&gt; , 自动排序, 实现取出距离最小的数heap.push(&#123;0, 1&#125;);while (!heap.empty()) &#123;    auto t = heap.top();    heap.pop();    //防止相同序号再次进入堆    if (visited[t.second]) continue;    visited[t.second] = true;</code></pre><p>&#x2F;&#x2F;找寻最短路径 , h[ 序号 ] 进入链表编号,<br>        for (int i &#x3D; h[t.second]; i !&#x3D; -1; i &#x3D; ne[i]) {<br>            int v &#x3D; e[i];    &#x2F;&#x2F;  v 表示下一节点 ;<br>&#x2F;&#x2F;更新最短路径<br>            if (dist[v] &gt; t.first + w[i]) {<br>                dist[v] &#x3D; t.first + w[i];<br>                heap.push({dist[v], v});<br>            }<br>        }<br>    }<br>    return dist[n];<br>}</p><p>signed main() {<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);</p><pre><code>int N;cin &gt;&gt; N;memset(h, -1, sizeof h);idx = 0;for (int i = 1; i &lt; N; i++) &#123;    int A, B, X;     cin &gt;&gt; A &gt;&gt; B &gt;&gt; X;通过 加A 可以去 i+1 ; 通过 加B 可以去 X ;     add(i, i + 1, A);    add(i, X, B);&#125;// 调用 Dijkstraint result = dijkstra(N);cout &lt;&lt; result &lt;&lt; endl;return 0;</code></pre><p>}</p><p>信息传递 并查集算法:<br>const int MAXN &#x3D; 200005;<br>int parent[MAXN], dist[MAXN];</p><p>int find(int x) {<br>    if (parent[x] !&#x3D; x) {<br>        int root &#x3D; find(parent[x]);    &#x2F;&#x2F;储存根节点 ;<br>        dist[x] +&#x3D; dist[parent[x]];    &#x2F;&#x2F;记录到祖节点的距离;<br>        parent[x] &#x3D; root;&#x2F;&#x2F;并查集 ;<br>    }<br>    return parent[x];<br>}</p><p>int main() {<br>    int n;<br>    cin &gt;&gt; n;</p><pre><code>for (int i = 1; i &lt;= n; i++) &#123;    parent[i] = i;    dist[i] = 0;&#125;int ans = n + 1;for (int i = 1; i &lt;= n; i++) &#123;    int t;    cin &gt;&gt; t;        find(i);    find(t);        int root_i = find(i);    int root_t = find(t);        if (root_i != root_t) &#123;       //判断是否同主族 ;         parent[root_i] = root_t;    //并集        dist[root_i] = 1 + dist[t] - dist[i];    //储存路径长度 ;     &#125;    else &#123;        ans = min(ans, abs(dist[i] - dist[t]) + 1);     // 找出最短路径 ;     &#125;&#125;cout &lt;&lt; ans &lt;&lt; endl;return 0;</code></pre><p>}</p><p>使用拓扑算法实现找最小环 :<br>const int N &#x3D; 200010;</p><p>int n;<br>int h[N], e[N], ne[N], idx;  &#x2F;&#x2F; 邻接表<br>int d[N];                    &#x2F;&#x2F; 入度<br>int p[N];                    &#x2F;&#x2F; 拓扑序列（本题不需要输出）<br>bool st[N];                  &#x2F;&#x2F; 访问标记</p><p>void add(int a, int b) {<br>    e[idx] &#x3D; b;<br>    ne[idx] &#x3D; h[a];<br>    h[a] &#x3D; idx++;<br>}</p><p>int main() {<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);</p><pre><code>cin &gt;&gt; n;// 初始化memset(h, -1, sizeof h);idx = 0;// 读取数据for (int i = 1; i &lt;= n; i++) &#123;    int t;    cin &gt;&gt; t;    add(i, t);  // i -&gt; t    d[t]++;     // 入度+1&#125;// 拓扑排序queue&lt;int&gt; q;for (int i = 1; i &lt;= n; i++) &#123;    if (!d[i]) &#123;        q.push(i);    &#125;&#125;while (!q.empty()) &#123;    int t = q.front();    q.pop();        for (int i = h[t]; i != -1; i = ne[i]) &#123;        int j = e[i];        d[j]--;        if (!d[j]) &#123;            q.push(j);        &#125;    &#125;&#125;// 找最小环int ans = n + 1;for (int i = 1; i &lt;= n; i++) &#123;    if (d[i] &gt; 0 &amp;&amp; !st[i]) &#123;        int len = 0;        int u = i;                while (!st[u]) &#123;            st[u] = true;            // 注意：每个人只有一个出边，所以h[u]就是第一条边            u = e[h[u]];            len++;        &#125;                ans = min(ans, len);    &#125;&#125;cout &lt;&lt; ans &lt;&lt; endl;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java16</title>
      <link href="/2026/01/13/java16/"/>
      <url>/2026/01/13/java16/</url>
      
        <content type="html"><![CDATA[<p>package Today;</p><p>import java.util.*;<br>import java.util.function.UnaryOperator;</p><p>public class Main {<br>    public static void main(String[] args) {<br>       List<String> list1 &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;ws0&quot; ,&quot;&#x3D;&#x3D;0&quot;,&quot;gay0&quot;)) ;<br>       List<String> list2 &#x3D; new LinkedList&lt;&gt;(Arrays.asList(&quot;ws1&quot;, &quot;&#x3D;&#x3D;1&quot;,&quot;gay1&quot;) ) ;<br>       list1.addAll(1 , list2) ;<br>       String[] string &#x3D;  list1.toArray(new String[0]);    &#x2F;&#x2F; &#x2F;&#x2F;将 list1 转化为类型数组<br>       String[] strings &#x3D; list1.toArray(String[]::new);    &#x2F;&#x2F;方法引用和上面一个样<br>        list1.sort(new Comparator<String>() {<br>            @Override<br>            public int compare(String o1, String o2) {<br>                return o1.compareTo(o2);<br>            }<br>        }) ;<br>        list1.sort((o1 , o2) -&gt; o2.compareTo(o1));  &#x2F;&#x2F;通过交换o1 , o2 实现改变排序思路<br>        list1.removeIf(str -&gt; str.contains(&quot;a&quot;)) ; &#x2F;&#x2F;contains() 就是用来 检查一个集合里是否包含某个元素。<br>        &#x2F;&#x2F;Java的 Lambda表达式 会自动推导类型, str就相当于传入的参数<br>        list1.replaceAll(new UnaryOperator<String>() {     &#x2F;&#x2F;实现对每个元素进行操作<br>            @Override<br>            public String apply(String s) {<br>                return &quot;&quot; ;<br>            }<br>        });<br>        list1.replaceAll(str -&gt; str+&quot;:&quot;);<br>        System.out.println(Arrays.toString(strings));<br>        System.out.println(list1);<br>        System.out.println(list1.contains(&quot;gay&quot;));<br>        System.out.println(list1.indexOf(&quot;gay&quot;));  &#x2F;&#x2F;查找元素出现首次下标 , 未出现输出-1 ;<br>    }<br>}<br>第十七天学习<br>集合根接口 :<br> 其他具体实现放十六天的不同集合中去了<br>boolean containsAll( Collection&lt;?&gt; c ) ;    &#x2F;&#x2F;判断所给是否为子集</p><p>实际使用 : List1.containsAll(List2)</p><p>default boolean removeIf( Predicate&lt;? super T&gt; filter )  &#x2F;&#x2F;按条件删除元素</p><p> boolean changed &#x3D; numbers.removeIf(n -&gt; n % 2 &#x3D;&#x3D; 0);  &#x2F;&#x2F;删除队内偶数</p><p>clear( Collection&lt;?&gt; c ) &#x2F;&#x2F;清除当前集合中的全部元素</p><p>boolean equals( Object c )  &#x2F;&#x2F;比较是否元素相等</p><p>int hashcode() &#x2F;&#x2F;不同集合中求hashcode的方法也不同 </p><p>boolean&#96; addAll(int pos , collection&lt;? extends T&gt;c ) 在指定位置插入指定集合的全部元素 : 底层迭代器实现</p><p>boolean containsAll( Collection&lt;?&gt;c )在尾部添加该列表的全部元素</p><p>default void replaceAll( UNaryOperator<T> operator ) &#x2F;&#x2F;对所有元素执行所给操作</p><p>default void sort( Comparator &lt;? super T&gt;c )  &#x2F;&#x2F;基础排序</p><p>get( int pos ) &#x2F;&#x2F;得到pos位置的数  , set(int pos) &#x2F;&#x2F;设置pos位置的元素</p><p>独特的搜索函数 : int indexof( Object o) 查询该元素在当前列表第一次出现下标<br>int lastIndexOf( Object o ) 查询该元素在当前列表中的最后一次出现</p><p>List<T>subList( int fromIndex , int toIndex )返回当前集合在指定范围内的子集</p><p>内部实现的ArrayList内部实现的add等方法 , 内部都会调用grow扩容方法 ; 底层 : private Object[] grow( int mincapacity )</p><p>列表内部空间大小 不为0时 , 按照当前长度 , 最小( 传入 )和推荐( 当前大小的0.5倍 )长度三参数实现扩容操作   为0时, 初始化大小为max(mincapacity , 10 ) 内部参数固定为10 </p><p>扩容的辅助方法  : newlength( int oldLength , int minGrowth , int prefGrowth )  比较minGrowth和 prefGrowth得出新的长度 max(,,,) + old</p><p>超出 : return hugeLength(int oldLenfth m int minGrowth) 三种判断</p><p>&lt;0 超出int最大值 || &lt;&#x3D; 最大长度范围 ,len &#x3D; 最大长度 || 位于最大长度和int 范围之间的直接返回&#x2F;抛出异常<br>|| 不加参数 , 重载调用的是容量+1 , 操作</p><p>List列表 ( 线性表 )<br>在定义集合类时直接 List&lt;类型&gt; 名 &#x3D; new 需要实现的数据结构类型&lt;&gt;() ;  </p><p>接口定义  , 可以使用全部方法 , 方便之后转化类型</p><p>创建顺序表 : ArrayList&lt;&gt;() ;   LinkedList&lt;&gt;() ; </p><p>实现创建列表 + 初始化为已知数组 : List&lt;类型&gt; 名&#x3D; Array.asList() ; 直接传多个元素 , 引用类型都是 OK 的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java15</title>
      <link href="/2026/01/12/java15/"/>
      <url>/2026/01/12/java15/</url>
      
        <content type="html"><![CDATA[<p>Java实现数组顺序表:<br>实现基础的增删功能<br>package Today.Study.Study;</p><p>import java.util.ArrayList;</p><p>public class SequentialList<T> {<br>    private int size &#x3D; 0 ;   &#x2F;&#x2F;顺序表大小</p><pre><code>private int len = 100 ;         //限制大小private Object[] array = new Object[len] ;  //增添元素public void add(T element , int pos)&#123;    if(pos &lt; 0 || pos &gt; len)        throw new IndexOutOfBoundsException(&quot;超出数组范围&quot; + size);   //抛出异常    //超出容量限制时设置扩容操作    if(size &gt;= len)&#123;        int Len = len + (len &gt;&gt; 1 ) ;    //扩容1.5 倍        Object[] newArray = new Object[Len] ;        System.arraycopy(array, 0, newArray, 0, len);        array = newArray ;      //JVM的回收机制 , 无需担心        len = Len ;    &#125;    for( int i = size ; i &gt; pos ; i--)            array[i] = array[i-1] ;        array[pos] = element ;        size++ ;&#125;@SuppressWarnings(&quot;unchecked&quot;)     //抑制编译器产生的未检查警告 , 已知有安全问题选择忽视//删除元素 , 返回被删除元素public T remove(int pos)&#123;    if(pos &lt; 0 || pos &gt; len)        throw new IndexOutOfBoundsException(&quot;ws是gay&quot;) ;    T result = (T)array[pos] ;    for(int i = pos ; i &lt; size ; i++ )        array[i] = array[i+1] ;    size -- ;    return result ;&#125;方法重写 ( Object中的该函数 )@Overridepublic String toString()&#123;    StringBuilder builder = new StringBuilder();    for(int i = 0 ; i &lt; size ; i++) builder.append(array[i]).append(&quot; &quot;);    return builder.toString();&#125;</code></pre><p>}<br>Java实现链表 :<br>类似C和C++混合后的数组模拟链表</p><p>package Today.Study.Study;</p><p>import java.util.ArrayList;<br>public class LinkList<T> {<br>    private Node<T> head &#x3D; new Node<T>(null) ;</p><pre><code>private int size = 0 ;public void add(T element , int pos)&#123;    if(pos &lt; 0 || pos &gt; size)        throw new IndexOutOfBoundsException(&quot;ws+gay&quot;) ;    Node&lt;T&gt; prev = head ;    for(int i = 0 ; i &lt; pos ; i ++ )        prev = prev.next ;    Node&lt;T&gt; node = new Node&lt;&gt;(element) ;    node.next = prev.next ;    prev.next = node ;&#125;public T remove(int pos)&#123;    if(pos &lt; 0 || pos &gt; size)        throw new IndexOutOfBoundsException(&quot;ws&quot;) ;    Node&lt;T&gt; prev = head ;    for(int i = 0 ; i &lt; pos ; i ++ )        prev = prev.next ;    T t = prev.next.element;    prev.next = prev.next.next;  //JVM自动回收机制魅力时刻    return t ; &#125;private static class Node&lt;T&gt; &#123;      //节点类   T element ;                      //节点储存元素   Node&lt;T&gt; next;                    //下一个节点的索引   Node(T element) &#123;       this.element = element;   &#125;</code></pre><p>   }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SkillsLearnFromProject</title>
      <link href="/2026/01/10/SkillsLearnFromProject/"/>
      <url>/2026/01/10/SkillsLearnFromProject/</url>
      
        <content type="html"><![CDATA[<p>项目中学的技能 :<br>1.学习使用EasyX的基础语法 :<br>头文件 : #include&lt;graphics.h&gt;<br>  #include&lt;conin.h&gt;    &#x2F;&#x2F;调用getch() ;<br>初始化窗口界面 : initgraph( 宽度 , 高度 ) ;<br>( int接收 )getch();    &#x2F;&#x2F;从控制台获取一个用户按键返回ASCII码 || 让程序停止, 按键后继续<br>void closegraph();   &#x2F;&#x2F;关闭图形窗口 ( 必须调用 )<br>防闪屏技术 : 1: while(1) +cleardevice() +  sleep( 16 ) + 结束条件 &#x2F;&#x2F;约60FPS   [ 设计简单, 但会存在明显的闪屏 ]<br>原理 : 清理输出都在前台 + 直接显示<br> 2: 双缓冲技术 :  创建窗口后 + BeginBatchDraw()  &#x2F;&#x2F;进入批量绘制<br>while( 1 ) {<br>cleardevice();          &#x2F;&#x2F; 清空内存后台的缓冲区[ 把旧图去除 ]<br>&#x2F;&#x2F;需要实现的图形绘制<br>FlushBatchDraw();       &#x2F;&#x2F; 将绘制好的全部内容一次性全部显示<br>sleep( 16 ) ;<br>结束条件<br>}<br>EndBatchDraw();   &#x2F;&#x2F;结束批量绘制图片<br>原理 : 清理输出都在后台 + 一次性输出<br>  3.双缓冲技术 + 时间控制:<br>在进入批量绘制之后立马记录时间<br>while(1){<br>计算时间差() ;<br>清理缓存 + 绘图( 时间差 ) + FlushBatchDraw() + 精确计算的sleep() + 结束条件<br>}<br>原理 : 清理输出都在后台 + 一次性输出 + 动态时间控制</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Starting from poop</title>
      <link href="/2026/01/10/Starting-from-poop/"/>
      <url>/2026/01/10/Starting-from-poop/</url>
      
        <content type="html"><![CDATA[<p>寒假大作业:<br>项目 : 实现窗口化界面的音乐播放器<br>实现功能 :<br>实现过程的困难和解决措施 :</p><ol><li>困难：创建图形界面窗口<br> 解决方案 : 学习使用EasyX创建图形界面程序</li><li>困难: 窗口出现闪屏<br> 解决方案 : 学习了三种防闪屏技术</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java14</title>
      <link href="/2026/01/06/java14/"/>
      <url>/2026/01/06/java14/</url>
      
        <content type="html"><![CDATA[<p>● 函数式接口<br>导包 : import java.util.function.Supplier ;<br>Supplier接口 : 内部方法实现返回需要的类型  ;<br>public void setName(Supplier<String>name){<br>    this.name &#x3D; name.get() ;<br>}<br>Main :<br>使用lambda表达式 :<br>{public String get(){} ; }<br>        ws0.setName(()-&gt;{<br>            return &quot;ws&quot; ;<br>        }) ;<br>Consumer接口 :<br>public void usename(Consumer<String> consumer){<br>        consumer.accept(name) ;<br> }<br> consumer.accept(参数) ; 实现传出参数<br> 实现使用接口型函数+ 方法引用<br>ws0.setName(()-&gt;{<br>        return &quot;ws&quot; ;<br>    }) ;<br>    ws0.usename(System.out::println);<br>}<br>consumer &#x3D; consumer.andThen(name -&gt; {<br>            System.out.println(&quot;ws是gay啊&quot;);<br>        }) ;<br>   andThen     实现串联多个接口consumer函数<br>温习下方法引用:<br>具体判断条件表格<br>Lambda形式可替换为条件<br>x -&gt; x.method()ClassName::instanceMethod实例方法，无额外参数<br>x -&gt; obj.method(x)obj::instanceMethod调用特定对象的方法<br>(x, y) -&gt; x.method(y)ClassName::instanceMethod第一个参数是目标对象<br>(x, y) -&gt; Class.method(x, y)Class::staticMethod静态方法<br>() -&gt; new Class()Class::new无参构造器<br>x -&gt; new Class(x)Class::new带参构造器<br>区分这两种函数接口 :<br>方面SupplierConsumer<br>目的提供&#x2F;创建数据消费&#x2F;处理数据<br>方向数据源头数据终点<br>返回值总是有返回值总是 void<br>参数无参数至少一个参数<br>是否纯函数可以是纯函数（无副作用）通常有副作用<br>典型应用工厂方法、配置加载、懒加载遍历处理、回调、资源清理<br>流式操作用于生成流（Stream.generate()<br>）用于终端操作（forEach()<br>）<br>线程安全通常线程安全（只读）需要注意（可能修改共享状态）<br>● Function函数类型接口 :<br>消费 + 提供 :<br>public void namelength(Function&lt;String , Integer&gt; function){<br>    Integer apply &#x3D; function.apply(name);<br>    System.out.println(&quot;name的长度&quot;+apply);<br> }<br> ws0.namelength(String::length);<br>实现转化类型<br>Function&lt;String , byte[]&gt; f &#x3D; str -&gt; str.getBytes();<br>Function&lt;String , Integer&gt; f2 &#x3D; f.andThen(bytes -&gt; bytes.length) ;<br>Function&lt;String , String&gt; f3 &#x3D; f2.andThen(Integer::toHexString) ;<br>还有before 反着传值操作<br>Function还支持一个函数 Function.identity().apply ( &quot; SSS &quot; ) ;<br>功能 : 给啥返回啥<br>compose可以实现before操作<br>● Predicate断言型函数接口:<br>public void nameInvalid(Predicate<String> predicate){<br>    boolean test &#x3D; predicate.test(name) ;<br>    System.out.println(test ? &quot;是gay&quot; : &quot;骗你的还是gay&quot;);<br>}<br>主程序中调用 :<br>ws0.nameInvalid(name -&gt; name.length()&gt;&#x3D;3);<br>可以用and实现连接 :<br>Predicate<String> predicate &#x3D; name -&gt; name.length()&gt;&#x3D;3;<br>predicate &#x3D; predicate.and(name -&gt; name.length() &lt; 10);<br>negate是取反 ; 对test函数取反<br>内部equal 可以实现判断是否相等 ;</p><p>● Biconsumer : 实现提供俩参数<br>public void nameid(BiConsumer&lt;String, Integer&gt; biConsumer){<br>    biConsumer.accept(name,id);<br>}</p><p>● optional判空包装 ：　<br>之前 if 判空<br>Optional类 :<br>ofNullable允许空传入<br>ifPresent 不为空会执行后面的操作 , 否则return ;<br>Optional.ofNullable(name).ifPresent(s -&gt; System.out.println(s.length()));<br>使用方法包装后(传入参数String test ) : String s &#x3D; Optional.ofNullable(name).get() ; get可以获取对象的引用 , 若包装对象为空 , 会抛出异常<br>可以在get处写orElse(&quot;实现为空时的操作&quot;)  \ orElseGet( (  ) -&gt; &quot;&quot; )<br>可以使用map实现映射操作 : 可以实现转化类型<br>get处写map(s -&gt; s.length()),orElse( int类型结果 ) ;<br>sout( i ) ;  </p><p>● Optional在Java9 &#x2F; 10 &#x2F;11 版本加强<br>之前 : Optional.ofNullable( str ).ifPresent( s -&gt; { 操作 } ) ;<br>修改后:Optional.ofNullable(str).ifPresentorElse( s-&gt;{ 操作 }　，　（Ｒｕｎｎａｂｌｅ）－＞｛｝ ) ;<br>内部有Runnable函数式接口：返回为空；<br>(str).or( () -&gt; Optional.of [必须要使用optioal.of包起来]  ( &quot;为空时的输出&quot; ) ).ifZPresent( 输出 ) ;<br>orElseThrow() ; 判断是否为空来抛异常<br>private static void test1(String str) {<br>    String result &#x3D; Optional.ofNullable(str)<br>        .filter(s -&gt; s.length() &gt; 2)     &#x2F;&#x2F;断言 , 判断是否保留<br>        .orElse(&quot;(无效输入)&quot;);  &#x2F;&#x2F; ? 为空时返回安全值</p><pre><code>System.out.println(result);</code></pre><p>}<br>Optional.ofNullable(str).flagMap(s -&gt; Optional.ofNullable(null)).isEmpty() ; </p><p>code:<br>package Today;</p><p>import java.util.Optional;<br>import java.util.function.Consumer;<br>import java.util.function.Function;<br>import java.util.function.Predicate;<br>import java.util.function.Supplier ;</p><p>public class Today {<br>    public static void main(String[]args){<br>        Ws0<String> ws0 &#x3D; new Ws0<String>();</p><pre><code>    ws0.setName(()-&gt;&#123;        return &quot;ws&quot; ;    &#125;) ;    Consumer&lt;String&gt; consumer = name -&gt; &#123;        if(name.length() &lt; 10 )&#123;            System.out.println(&quot;ws是gay&quot;);        &#125;else&#123;            System.out.println(&quot;ws一直是gay&quot;);        &#125;    &#125;;    consumer = consumer.andThen(name -&gt; &#123;        System.out.println(&quot;ws是gay啊&quot;);    &#125;) ;    ws0.usename(consumer);    ws0.namelength(String::length);    Function&lt;String , byte[]&gt; f = str -&gt; str.getBytes();    Function&lt;String , Integer&gt; f2 = f.andThen(bytes -&gt; bytes.length) ;    Function&lt;String , String&gt; f3 = f2.andThen(Integer::toHexString) ;    ws0.nameInvalid(name -&gt; name.length()&gt;=3);    Predicate&lt;String&gt; predicate = name -&gt; name.length()&gt;=3;    predicate = predicate.and(name -&gt; name.length() &lt; 10);&#125;    private static void test1(String str)&#123;        System.out.println(Optional.ofNullable(str).filter(s-&gt;s.length()&gt;2).get());    &#125;</code></pre><p>}</p><p>package Today;</p><p>import java.util.Optional;<br>import java.util.function.*;</p><p>public class Ws0<T> {<br>    private String name ;<br>    int id ;<br>    T  score ;</p><pre><code>public void Ws(String name , int id , T score )&#123;    this.name = name;    this.id = id;    this.score = score;&#125;public void setName(Supplier&lt;String&gt; supplier)&#123;    this.name = supplier.get() ;&#125;public String getname()&#123;    String name = new String();    name = this.name ;    return  name ;&#125;public void usename(Consumer&lt;String&gt; consumer)&#123;    consumer.accept(name) ;&#125;public void namelength(Function&lt;String , Integer&gt; function)&#123;    Integer apply = function.apply(name);    System.out.println(&quot;name的长度&quot;+apply); &#125;public void nameInvalid(Predicate&lt;String&gt; predicate)&#123;    boolean test = predicate.test(name) ;    System.out.println(test ? &quot;是gay&quot; : &quot;骗你的还是gay&quot;);&#125;public void nameid(BiConsumer&lt;String, Integer&gt; biConsumer)&#123;    biConsumer.accept(name,id);&#125;private static void test(String name)&#123;    System.out.println(name) ;    Optional.ofNullable(name).ifPresent(s -&gt; System.out.println(s.length()));&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java13</title>
      <link href="/2026/01/04/java13/"/>
      <url>/2026/01/04/java13/</url>
      
        <content type="html"><![CDATA[<p>● 泛型方法( 支持静态方法 和 成员方法 )<br>private static <T> T test(T t ){<br>    return t ;<br>}</p><p>main: tring s &#x3D; test(&quot;ws是gay&quot;) ;  (创建泛型对象)</p><p>● JDK内部实现的泛型方法</p><ol><li>数组排序<br>Arrays.sort(arr , new Comparator<Integer>(){    &#x2F;&#x2F;需要实现Compare的接口内部的比较函数即可&lt;&gt;泛型方法<br> public int compare(Integer o1 , Integer o2){    &#x2F;&#x2F;int compare(T o1, T o2);内部需要实现的泛型方法<br> return o2 - o1 ;<br> }<br>}) ;<br>System.out.println(Arrays.toString(arr)) ;</li></ol><p>2.数组复制<br>Integer[] brr &#x3D; Arrays.copyOf(arr , 3) ;    传值类型改变 -&gt; 实现不同复制 -( 泛型方法 )</p><p>3.创建泛型方法 + 方法调用 + 需要设置类型进行传参数  -&gt; (子 , 各种)类名.&lt;类型&gt;方法名() ;<br>Today.<String>name() ;<br>String str &#x3D; name()  ;<br>private static <T> T name(){<br>    return null ;<br>}</p><p>● 泛型界限( 限制输入内容 )<br>public class New_Class<T extends Number>{<br>    String name  ;<br>    int date ;<br>    T ws ;<br>    New_Class(String name , int date, T ws){<br>        this.name &#x3D; name ;<br>        this.date &#x3D; date;<br>        this.ws &#x3D; ws;<br>        System.out.println(name + date + ws);<br>    }<br>当对象被限制在具体类中时 , 创建出的对象可以实现对应类的方法<br>通配符也可支持实现泛型限制<br>创建  ? 型时候, 对应的未知参数可以调用对应的继承父类, 不设计继承类时仍按Object类进行处理<br>Ws000&lt;? extends Number&gt; score &#x3D;  new Ws000&lt;&gt;(&quot;score&quot; , 22 , 12 ) ;<br>&lt;T  后接extends时限制上限 &#x2F; 后接super时限制下限  ( ?通配符可以实现限制上限不可实现限制下限 )<br>创建下限时   : 类型需要使用Object类进行接收</p><p>● 类型擦去<br>底层逻辑 : T ( 无上限 ) 编译后T类型会直接转化为Object类<br>创建上限 : 发生类型擦去 , T型参数 会被编译为上限类型( 可以去除尖括号直接创建对象 , 注意传参类型为上限即可 )    创建上限的子类对象时内部编译会实现强制类型转化为子类<br>interface Study<T>{<br>    T study(T t ) ;<br>}</p><p>static class Tree implements  Study<String>{<br>    public  String study(String  str){<br>        return &quot;ws是gay&quot;+str ;<br>    }<br>}<br>编译时编译器自动生成<br>&#x2F;&#x2F; 编译器自动生成的桥接方法<br>    public Object study(Object var1) {<br>        return this.study((String)var1);  &#x2F;&#x2F; 将Object转型为String，调用实际方法<br>    }<br>保持多态 : 先调用接口中的Object方法 , 再跳转到桥接方法中的study(Object)方法中去 , 最后再转接到实际的参数为String 方法 , return result ;<br>对象之间进行instance of 判断时不可以使用泛型 , 只可使用其原始类型<br>泛型类不支持创建参数化数组( 参数化的引用类型对象 )</p><p>● 协变和逆变<br>Tec<Integer> tec &#x3D; new Tec&lt;&gt;(12);<br>Tec&lt;父类&gt; tec1 &#x3D; tec ;  &#x2F;&#x2F;无法创建对象<br>static class Tec<T>{<br>    T name ;<br>    public Tec(T name){<br>        this.name &#x3D; name ;<br>    }<br>}</p><p>在JAVA中创建的泛型类&lt;明确形式&gt; 只能创建相应的类别 . 不具备协变的性质 ( 无法实现子类对象创建父类对象 )  : 数组支持协变<br>协变缺点 : 创建一个父类包含子类之后 ,传入参数( 属于父类不属于子类 )时若不按照原类型仍然会报错<br>逆变 : 父类转子类 -&gt;也不支持<br>抗变 : 父子无关系 . 编译器不会相关联<br>不支持创建父类的泛型对象( 抗变属性 )<br>通过&lt;? extends &gt; 创建类的对象后 该对象就具有协变性质 ( 父类包子类 )<br>虽然支持了协变 , 但创建出的泛型参数无法在父类对象中修改<br>super 设置下限 : 可以支持抗变性质<br>也是 ? super 进行创建子类对象   只可以Object类型的结果去接收<br>但使用Object 可以读取但只限制于Object类型的结果</p><p>code :<br>package Today;</p><p>public class New_Class<T>{<br>    String name  ;<br>    int date ;<br>    T ws ;<br>    New_Class(String name , int date, T ws){<br>        this.name &#x3D; name ;<br>        this.date &#x3D; date;<br>        this.ws &#x3D; ws;<br>        System.out.println(name + date + ws);</p><pre><code>&#125;</code></pre><p>}</p><p>package Today;</p><p>import java.lang.reflect.Array;<br>import java.util.Arrays;<br>import java.util.Comparator;</p><p>public class Today{<br>    public static void main(String[] args) {<br>        New_Class<String> ws1 &#x3D; new New_Class&lt;&gt;(&quot;ws0&quot; , 1 , &quot;是gay&quot;) ;<br>        Integer s &#x3D; test(21) ;<br>        Integer[] arr &#x3D; {1 , 2 ,4 ,5 ,4 , 3 ,12 } ;<br>        Arrays.sort(arr , new Comparator<Integer>(){<br>            public int compare(Integer o1 , Integer o2){<br>                return o2 - o1 ;<br>            }<br>        }) ;<br>        Integer[] brr &#x3D; Arrays.copyOf(arr , 3) ;</p><pre><code>    System.out.println(Arrays.toString(arr)) ;    Today.&lt;String&gt;name() ;    String str = name()  ;    Integer ws2 = test(12) ;    Tree tree = new Tree() ;    System.out.println(tree.study(&quot;,ws真的是gay&quot;));    Tec&lt;Integer&gt; tec = new Tec&lt;&gt;(12);&#125;private static &lt;T extends Number&gt; T test(T t )&#123;    return t ;&#125;private static &lt;T&gt; T name()&#123;    return null ;&#125;interface Study&lt;T&gt;&#123;    T study(T t ) ;&#125;static class Tree implements  Study&lt;String&gt;&#123;    public  String study(String  str)&#123;        return &quot;ws是gay&quot;+str ;    &#125;&#125;static class Tec&lt;T&gt;&#123;    T name ;    public Tec(T name)&#123;        this.name = name ;    &#125;&#125;</code></pre><p>}</p><p>package Today;</p><p>public class Ws000<T extends Number> {<br>    String name ;<br>    int date ;<br>    T ws ;<br>    public Ws000(String name, int date , T ws) {<br>        this.name &#x3D; name;<br>        this.date &#x3D; date;<br>        this.ws &#x3D; ws ;<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java12</title>
      <link href="/2026/01/03/java12/"/>
      <url>/2026/01/03/java12/</url>
      
        <content type="html"><![CDATA[<p>泛型类 ( 类型参数 )<br>Object : 1. 需要强制类型转化 ; 2 . 需要具体场景传参<br>实现编写代码时就可以明确类型<br>但在类的内部方法中 T型参数仍然会被当作 Object 类型去处理 , 形参无法实现实例化<br>New_class<?> ws2 = ws1 ;  使用 ? 通配符 : 可以支持任意类型的泛型 , 类型不确定仍会被当作Object类仍然需要强制类型转化Test<?> test &#x3D; new Test&lt;类型&gt;() ; 实行转化为不同中的泛型类<br>创建方法是也可以创建未知类型的<br>基本类型不可以写入泛型类中 , 但数组可以 ( 引用类型 ) New_class&lt;int[ ]&gt;<br>T : 甚至可以写为另外的一个类<br>支持泛型修改 , 泛型在多态下的表现  : 多态 : 实行 方法重写 , 继承 , 向上转型<br>实现接口时确定类型</p><p>static class Test implements New1<String>{<br>    @Override<br>    public String study(String n) {<br>        return &quot;&quot;;<br>    }<br>在实现接口时依旧创建泛类</p><p>static class Test1<T> implements New1<T>{<br>    @Override<br>    public T study(T name) {<br>        return null;<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java11</title>
      <link href="/2025/12/30/java11/"/>
      <url>/2025/12/30/java11/</url>
      
        <content type="html"><![CDATA[<p>代码训练 :<br>toString实现将对象转化为字符串进行输出 ( 在自己建的类中需要重写实现否则无实际意义 [ @1b6d3586 ]  , 数组中的Arrays.toString已经重写过可以输出数组全部内容  (直接输出[I@1b6d3586（没意义）) )<br>String s &#x3D; cin.nextLine( 直接读取一行 ) ;<br>获取字符cin.next(&quot;[a-zA-Z]&quot;) [ 正则表达式 ]; 类型获取 : next + 类型 ;  通过String获取字符: charAt(下标) ;<br>将String类型直接转化为char类型数组 :<br>char[] arr &#x3D; s.toCharArray() ;<br>创建类的时候一定要加上构造方法<br>实现判断回文序列<br>private static boolean Palind(String s){<br>        char[] arr2 &#x3D; s.toCharArray() ;<br>        for(int i &#x3D; 0 ; i &lt; s.length() &#x2F; 2 ; i ++){<br>            if(arr2[i] !&#x3D; arr2[s.length() - 1 - i]){<br>                return false ;<br>            }<br>        }<br>        return true ;<br>}<br>汉诺塔函数实现<br>&#x2F;&#x2F;参数 : 盘子数 , 起点 , 终点 , 辅助点<br>private static void Hanoi(int n , char a , char b , char c  ){<br>    if(n &#x3D;&#x3D; 1 ){<br>        System.out.println(a + &quot;-&gt;&quot; + b );<br>    }else{<br>        Hanoi(n -1 , a , c , b ) ;<br>        System.out.println(a + &quot;-&gt;&quot; + b );<br>        Hanoi(n - 1, c, b , a ) ;<br>    }<br>}<br>泛型 :<br>当不知道所存值的类型 : 例如 Integer 或者 String 可以直接使用 Object 类( 所有类型的子类 )型代替<br>在类中创建好之后编译时难以识别<br>只能使用类去接收类( 这里都是引用类型 : 只能使用包装类)<br>Integer value &#x3D; (Integer) ws1.value ;<br>String name &#x3D; (String)ws.value ;<br>Object name1 &#x3D; (String)ws.value ;</p><p>code :<br>package Today ;</p><p>import java.util.*;</p><p>public class Main{<br>    public static void main(String[]args){<br>        int[] arr &#x3D; {24,43,65,743,35,34,25,61,1,9} ;<br>        Bubble_Sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>        Scanner cin  &#x3D; new Scanner(System.in) ;<br>        String s &#x3D; cin.nextLine();<br>        char[] arr1 &#x3D; s.toCharArray() ;<br>        Class ws &#x3D; new Class(&quot;ws&quot; , &quot;122&quot; , &quot;是gay&quot;) ;<br>        Class ws1 &#x3D; new Class(&quot;ws1&quot; , &quot;gay&quot; , 11) ;</p><pre><code>    Integer value = (Integer) ws1.value ;    String name = (String)ws.value ;    Object name1 = (String)ws.value ;&#125;private  static void Bubble_Sort(int[] arr)&#123;    for(int i= 0  ; i &lt; arr.length -1 ; i ++)&#123;        boolean flag = false;        for(int j = 0 ; j &lt; arr.length  -1 - i ; j++)&#123;            if(arr[j] &gt; arr[j+1])&#123;                int temp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = temp;                flag = true ;            &#125;        &#125;        if(!flag) break ;    &#125;&#125;private static int Bin_find( int[]arr , int x )&#123;    //实现最小化查找( &gt;= ) r 返回第一个满足条件的数    int l = -1 ;                                    //实现最大化查找( &lt;= ) l 返回最后一个满足条件的数    int r = arr.length  ;    while(l +  1 &lt; r )&#123;        int mid = (l + r ) &gt;&gt; 1 ;        if(arr[mid] &lt;= x) l = mid ;        else r = mid ;    &#125;    return l ;&#125;private static int Fibo(int n)&#123;    if( n &lt;= 2 ) return 1 ;    int[] dp = new int[n+1] ;    dp[1] = dp[2] = 1 ;    for(int i = 3 ; i &lt;= n ; i++)&#123;        dp[i] = dp[i -1 ] + dp[i -2] ;    &#125;    return dp[n] ;&#125;private static boolean Palind(String s) &#123;    char[] arr2 = s.toCharArray();    for (int i = 0; i &lt; s.length() / 2; i++) &#123;        if (arr2[i] != arr2[s.length() - 1 - i]) &#123;            return false;        &#125;    &#125;    return true;&#125;//参数 : 盘子数 , 起点 , 终点 , 辅助点private static void Hanoi(int n , char a , char b , char c  )&#123;    if(n == 1 )&#123;        System.out.println(a + &quot;-&gt;&quot; + b );    &#125;else&#123;        Hanoi(n -1 , a , c , b ) ;        System.out.println(a + &quot;-&gt;&quot; + b );        Hanoi(n - 1, c, b , a ) ;    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java10</title>
      <link href="/2025/12/29/java10/"/>
      <url>/2025/12/29/java10/</url>
      
        <content type="html"><![CDATA[<p>第十一天学习<br>新版本的时间类 :<br>LocalTime中的一些静态方法<br>LocalDate today1 &#x3D; LocalDate.MAX;<br>LocalDate today2 &#x3D; LocalDate.MIN;<br>LocalTime today2 &#x3D; LocalTime.MAX;<br>LocalTime today2 &#x3D; LocalTime.MIN;<br>LocalTime today3 &#x3D; LocalTime.MIDNIGHT;<br>LocalTime today4 &#x3D; LocalTime.NOON();<br>totay1.实例方法调用  &#x2F;&#x2F;获取具体的年月日秒<br>LocalDateTime today7 &#x3D; LocalDateTime.of(1232, 11 , 2 , 2 , 21);<br>LocalDateTime today8 &#x3D; LocalTime.now().atDate(LocalDate.now()) ;   &#x2F;&#x2F;实现自动补全( atTime )<br>结合体两种类的实例方法和静态方法都可以实现调用<br>时间的格式化类转化DateTimeFormatter类<br>创建工具　：　<br>DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);<br>使用ｐａｒｓｅ : 实现将日期格式进行转换为字符串 ( 按照自定义的形式实现转化 )<br>LocalDateTime now &#x3D; LocalDateTime.parse( &quot;2025-09-09 07:12:34&quot; , formatter ) ;<br>sout( now ) ;<br>使用format 将字符串再转换回日期类 :<br>LocalDateTime time &#x3D; LocalDateTime.now() ;<br>System.out.println(dtf3.format(time));<br>通过parse直接转化也是可以的 :<br>LocalDateTime from &#x3D; LocalDateTime.from( fornatter.parse(&quot;2025-01-01 01:22:21&quot;)) ;<br>sout(from) ;<br>OffsetDateTime类 : 携带偏移值的时区时间 :<br>now() 不写默认当前时区, 添加ZoneId限制可以实现转化时区<br>OffsetDateTime hhh &#x3D; OffsetDateTime.now(ZoneId.of(&quot;UTC+0&quot;));<br>System.out.println(hhh);<br>LocalDateTime now &#x3D; LocalDateTime.now(ZoneId.of(&quot;UTC-6&quot;));<br>同样可以实现获取地区偏移的时间<br>ZonedDateTime类 : 获取时区的时间<br>ZonedDateTime zoneId &#x3D; ZonedDateTime.now() ;<br>System.out.println(zoneId);<br>Instant : 表示时间戳 , 表示某个时间点所代表的时间戳 ;<br>Instant intant &#x3D; Instant.now() ;<br>Instant.ofEpochSecond(1) ;    &#x2F;&#x2F;通过时间戳创建日期<br>Instant.ofEpochSecond(0,1) ; &#x2F;&#x2F;实现精确到毫秒<br>Duration &#x2F; period类 : 计算时间差 :<br>between 计算俩时间段之间的差值<br>Duration duration &#x3D; Duration.ofHours(1);<br>Duration.between(LocalDate.now(),LocalDate.now().plusDays(1));<br>Period period &#x3D; Period.ofDays(1);<br>LocalDate 不支持秒级的时间单位计算。LocalDate只有日期部分（年月日），没有时间部分（时分秒），所以不能计算秒数。</p><p>code :<br>package Today;</p><p>import java.text.* ;<br>import java.time.* ;<br>import java.time.format.DateTimeFormatter;<br>import java.util.* ;</p><p>public class Main {<br>    public static void main(String[] args) {<br>        LocalDate date &#x3D; LocalDate.now();<br>        LocalDate date1 &#x3D; LocalDate.of(2023,12 , 21) ;<br>        LocalDate date2 &#x3D; LocalDate.ofYearDay(2025,365) ;</p><pre><code>    System.out.println(date);    date = date.plusDays(1) ;  //实现在原本日期基础上++ ;    System.out.println(date1);    System.out.println(date2);    System.out.println(date);    System.out.println(date.getDayOfWeek());    System.out.println(date.getMonth());    System.out.println(date.getMonthValue());    System.out.println(date.getDayOfMonth());    System.out.println(date.getDayOfYear());    System.out.println(date.getYear());    LocalDate today1 = LocalDate.MAX;    LocalDate today2 = LocalDate.MIN;    LocalTime today3 = LocalTime.MAX;    LocalTime today4 = LocalTime.MIN;    LocalTime today5 = LocalTime.MIDNIGHT;    LocalTime today6 = LocalTime.NOON;    LocalDateTime today7 = LocalDateTime.of(1232, 11 , 2 , 2 , 21);    LocalDateTime today8 = LocalTime.now().atDate(LocalDate.now()) ;   //实现自动补全    DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);    LocalDateTime today9 = LocalDateTime.from(dtf.parse(&quot;2025-09-09 07:12:34&quot;));    System.out.println(LocalDateTime.parse(&quot;2023-09-09 10:09:22&quot; ,dtf));    DateTimeFormatter dtf3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);    LocalDateTime time = LocalDateTime.now() ;    System.out.println(dtf3.format(time));    OffsetDateTime hhh = OffsetDateTime.now(ZoneId.of(&quot;UTC-6&quot;));    System.out.println(hhh);    LocalDateTime now = LocalDateTime.now(ZoneId.of(&quot;UTC-6&quot;));    ZonedDateTime zoneId = ZonedDateTime.now() ;    System.out.println(zoneId);    Instant intant = Instant.now() ;    Instant.ofEpochSecond(1) ;    //通过时间戳创建日期    Instant.ofEpochSecond(0,1) ; //实现精确到毫秒    LocalDateTime stf10 =  LocalDateTime.ofInstant(intant , ZoneId.of(&quot;UTC+8&quot;));    Duration duration = Duration.ofHours(1);    Duration s = Duration.between(LocalDateTime.now(),LocalDateTime.now().plusDays(1)) ;    Period period = Period.ofDays(1);    System.out.println(duration);    System.out.println(s.getSeconds());    Period period1 = Period.between(LocalDate.now(),LocalDate.now().plusDays(56));    System.out.println(period1.getDays());&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java09</title>
      <link href="/2025/12/28/java09/"/>
      <url>/2025/12/28/java09/</url>
      
        <content type="html"><![CDATA[<p>第十天学习<br>工具类 :<br>数学工具类 :<br>通过Math类调用函数 : pow , min , max , abs , sin , cos  ;<br>Java重载魅力时刻 : Java 中的 Math.abs() 方法适用于所有数值类型，无论是整数还是小数，正数还是负数。   floor( 向下取整 )  , round( 四舍五入 )<br>使用 MPI可以实现找到 派  ;<br>Math.logq( x ) ; 以q为底 , x 的对数,<br>Random 随机数生成类 ; 创建出对象后  x.nextInt( 范围 ) ;<br>数组工具类 :<br>Arrays类 : 实现直接打印数组   ;<br>Array . sort( arr  ,x , y ) ; 实现( 对 x 到 y 位置的数字 )排序  ;<br>Array.fill( brr , x  )将brr数组中所有元素修改为数值 x  ;<br>Arrays.copyOfRange(arr , 2 , 5); 实现拷贝 2 - 5 位置之间的元素<br>Arrays.copyOf( 数组 , 拷贝的元素长度 )  ; 若是超出原数组大小会自动补零<br>Arrays.binarySearch(arr , 1222); 在arr数组中查找数值 , 若是未找到该数值 , 会返回负数( -4  , 在索引为3的位置插入查找数据 ) ;<br>Arrays.deepToString() 实现打印内外层的数组 ( 适合用于多维数组 ) ;<br> 针对多维数组 使用deepEquals 实现比较是否相等( 深层次判断 )  ;  内部实现的函数包装的是Object 类型<br>日期相关类 :<br>区分Date 和 Calendar 差别 : Date是表示时间戳  , 而Calendar 是具体表示出来时间的具体年份 , 月 , 日<br>日期一般是以时间戳的形式存在 , 是自1970年1月1日00:00:00起的时刻毫秒数 , 当时间戳为1000时 ,实际上过了1秒 ;<br>时区 : 地球划分区域 , 实现标准化时间 , 共24时区 , 每精度15度划分一个时区 , 由英国的本初子午线开始划起 ;<br>中国东8区 : 本初子午线 0 点的时候, 中国是 8 点 ;<br>UTC : 协调世界时 , 同步世界时间 , 中国 UTC + 8 ;<br>Date 类 创建类对象 , date.tolocaleString() [ 被弃用 ]; 实现播报当地时间<br>getTime获取当前时间戳 ; 精确到毫秒o<br>获取格林威治时间的时间戳 : System.out.println(u.toGMTString());<br>年份 1900 + 输入年份 ,  月份类似下标 1 - 11 , 日期1 - 31 ;<br>Date date  &#x3D; new Date(125 , 11 , 17 , 2 , 2 ,2   ) ;可以精确到秒 ;<br>构造都过时 , 也无法设置时区 ;<br>实现比较时间的先后 :<br>输出true , false :<br>sout( date1.after( date2 ) ) ;<br>sout( date.before( date1 ) ) ;<br>输出 -1( 早 )  0 ( 相等 )  1( 晚 ) :<br>sout( date2.compareTo(date1) ) ;<br>实现修改当前时间 , 并且输出当前时间<br>Calendar cal &#x3D; Calendar.getInstance();<br>cal.set(2025 , Calendar.JANUARY , 16 , 12 , 2 , 2  ) ;<br>System.out.println(cal.getTime());    &#x2F;&#x2F;获取当前时间<br>cal.set(Calendar.YEAR , 2026) ;    &#x2F;&#x2F;实现具体修改<br>内部实现的set方法</p><p>public final void set(int year, int month, int date, int hourOfDay, int minute,<br>                      int second)<br>{<br>    set(YEAR, year);<br>    set(MONTH, month);<br>    set(DATE, date);<br>    set(HOUR_OF_DAY, hourOfDay);<br>    set(MINUTE, minute);<br>    set(SECOND, second);<br>}<br>一堆方法 自己摸索<br>cal.getweeksInWeekYear()  获取基于周的年份 : 将一年中的第一个周作为一年的开始 , 最后一周的周日为年的结束<br>System.out.println(cal.getFirstDayOfWeek()); 获取到一周的第一天<br>DateFormat抽象类 实现将日期和字符串之间相互转化 , 抽象无法直接创建对象 ,<br>常利用子类 SimpleDateFormat 实现创建<br>创建对象 ：( 提供方法 )DateFormat formatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);<br>System.out.println(formatter.format(new Date()));实现按上述格式输出<br>输出的规则 :  实现字符和对应的数据之间进行转化<br>实现反向转化</p><p>Date parse &#x3D; formatter.parse(&quot;2026-01-01 24:00:00&quot;);<br>System.out.println(parse);</p><p>code :<br>package Today;</p><p>import java.text.* ;<br>import java.time.* ;<br>import java.util.* ; </p><p>public class Main {<br>    public static void main(String[] args) throws ParseException {<br>        System.out.println(Math.abs(-1));<br>        System.out.printf(&quot;%.3f      &quot; , Math.pow(-2.2 , 2 ));</p><pre><code>    Random x = new Random();    for(int i = 0 ;  i  &lt; 20 ; i++)&#123;        System.out.println(x.nextDouble(10008) + &quot;   &quot;);    &#125;    int[] arr = &#123;1 , 22 , 2323, -12321, 31 , 2333, 23123&#125;;    Arrays.sort(arr , 2  , 4);    System.out.println(Arrays.toString(arr));    int[] brr = new int[10] ;    Arrays.fill(brr, -1);    brr = Arrays.copyOfRange(arr , 2 , 5);    System.out.println(Arrays.toString(brr));    int[] crr = new int[10] ;    System.arraycopy(arr , 0 , crr ,1  , 2 );    System.out.println(Arrays.binarySearch(arr , 1222));    int[][]arr1 = &#123; &#123;1 ,2 ,2 ,3 ,3213&#125; ,  &#123;1232,323213, 23123 ,22&#125; &#125; ;    System.out.println(Arrays.deepToString(arr1));    int[][]brr1 = &#123;&#123;1 ,2 ,2 ,3 ,3213&#125; ,  &#123;1232,323213, 23123 ,22&#125; &#125; ;    System.out.println(Arrays.equals(arr1 , brr1)) ;    System.out.println(Arrays.toString(crr));    Date u   =  new Date();    System.out.println(u.toGMTString());    System.out.println(u.getTime());    Date date1  = new Date(125 , 11 , 17 , 2 , 2 ,2   ) ;    Date date2  = new Date(125 , 11 , 17 , 2 , 2 ,1  ) ;    System.out.println(date2.compareTo(date1));    Calendar cal = Calendar.getInstance();    cal.set(2025 , Calendar.JANUARY , 16 , 12 , 2 , 2  ) ;    cal.set(Calendar.YEAR , 2026) ;    System.out.println(cal.getTime());    System.out.println(cal.getWeeksInWeekYear());    System.out.println(cal.getFirstDayOfWeek());    System.out.println(cal.getTime());    //获取当前时间    DateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    System.out.println(formatter.format(new Date()));    Date parse = formatter.parse(&quot;2026-01-01 24:00:00&quot;);    System.out.println(parse);&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javaweb01</title>
      <link href="/2025/12/27/javaweb01/"/>
      <url>/2025/12/27/javaweb01/</url>
      
        <content type="html"><![CDATA[<p>● 互联网和网络设备<br>访问互联网 :  只能通过网络运营商( 网络服务供应商,ISP )<br>1.通过SIM卡 , 通过移动设备连接到附近的基站使用网络 , 只要有基站就能使用<br>2.通过办理宽带 , 光纤入户 . 位置固定 , 但连接延迟低很稳定<br>光猫 : 光纤入户的是光信号 -&gt; 电信号 ,网线 -&gt; 转换WiFi , 供移动设备使用<br>路由器 : 光猫的有线网口太少 , 不支持多连接 ,  通过路由器发射WiFi 实现多个连接</p><p>● IP地址和端口<br>IP地址分为4类 :<br>其中一种IP4地址 , 一般为192.168.XX.XX 格式:<br>转化为二进制 </p><p>共有4段 , 每段8个bit位 , 一共32位 , 0.0.0.0 - 255.255.255.255 一共有大约43亿<br>但实际供使用的地址是否有限 , 国际按用途对网段划分 ABCDE 共5类<br>网络地址 -&gt; 地区  , 全球唯一性 ,   主机地址 -&gt;具体位置 , 本地分配 ;<br>A类地址 : 0开头 , 网络地址空间长度7位 , 主机地址空间长度24位 , 1.0.0.0 - 127.255.255.255 . 适用于有大量主机的大型网络 , 每个A类网络的主机网址多达16,777,214 ;<br>B类地址 : 以10开头 , 网络地址空间长度14位, 主机地址长度16位 , 128.0.0.0 - 191.255.255.255 , 适用于一些国际性的大公司和政府机构 主机地址可达65536 个.<br>C类地址: 以110开头 , 网址地址为21位 , 主机地址8位, 192.0.0.0 - 223.255.255.255,适用于小公司和普通的研究机会, 主机地址数最多为256个 .<br>D类地址 :以1110开头 , 不标识网路, 特殊用途 , 224.0.0.0-239.255.255.255<br>E类地址: 以11110开头,暂时保留为某些实验和将来使用 , 240.0.0.0-255.255.255.255<br>所有用户的IP地址 : 均为局域网IP , 与互联网无关 .( 路由器去创建一个局域网 , 所有连接的设备都用的局域网的IP去访问互联网 ) ;<br>IPv6地址 :共128种 , 大大扩展地址可用空间 , 但普及率低 , 每个设备都有公网IP .<br>使用IPv6直连 , 不会出现高峰 , 速度显著提升<br>端口连接:实现区分不同的应用 ,实现两台设备之间的通信 , 区分一个公网地址下的不同家庭和设备 , 也是使用端口不同来区分的 . </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java08</title>
      <link href="/2025/12/27/java08/"/>
      <url>/2025/12/27/java08/</url>
      
        <content type="html"><![CDATA[<p>第九天学习<br>异常<br>在Java中异常已经被封装为类 :<br>第一种异常  :  运行时异常 :<br>算数中出现 &#x2F; 0;<br>对 null 执行 toString() 操作<br>没在类中实现接口但调用方法的<br>第二种异常  :  编译时异常 ( 必须进行手动处理 )<br>第三种异常 : 错误  ,  致命的问题 :<br>创建为 Integer . MAX_VALUE大小的数组<br>在main中调用main 会不断调用 , 会爆栈<br>自定义异常<br>编译时异常 : extends Exception  所有异常都要继承自Exception类<br>运行时异常 : extends RuntimeException  ( 直接创建异常类时会自动变为Runtime类 )<br>抛出异常<br>在方法中设置判断抛出运行时异常<br>private static int div(int a , int b ){<br>    if(b &#x3D;&#x3D; 0){<br>        throw new Exercise1(&quot;发现除0&quot;) ;<br>    }<br>    return a &#x2F; b ;<br>}<br>栈追踪 问题 : at Today.Main.div(Main.java: 异常所在行数)<br>实现抛出编译型异常 : 在实现函数 标清楚 throws TestExecption  , 实现方法的类必须标明throws 编译时异常<br>父类中被标记会抛出某异常 : 但子类中不会出现该异常时可以去除throw操作<br>try - catch 语句 :<br>实现捕获异常 , 错误 :<br>当try中代码发出异常或错误 , 会执行catch中的代码块<br>try{<br>    Object obj &#x3D; null ;<br>    obj.toString();<br>} catch(NullPointerException ws){<br>    System.out.println(&quot;发生异常&quot; );<br>}<br>catch中表明出现的异常并且表明出 代表异常的变量<br>ws.printStackTrace()  ; 通过变量调用追踪函数实现栈异常路径 : 虽然会抛出异常但不会中止运行<br>ws.getmessage() 实现输出异常的原因 ;<br>catch 和 try 中出现的异常必须一致 , 否则还会出现程序被掐断<br>catch(  Exception  ws  ) 可以直接写这个( 所有异常全部继承自Exception )<br>注意在捕获异常时 :<br>一个try 下可以追加很多catch( 类型 变量 ) ; 实现识别不同的异常 并抛出对应异常中的内容<br>可以在一个catch( 异常类型1 | 异常类型2  变量 ) 实现输出对应的异常<br>message类的异常设置String提示 ,可以通过使用getmessage实现输出String<br>运行时异常可以不明确标注 , 但编译时异常在定义方法时就要实现抛出可能出现的异常类型<br>也可以在方法后不抛出异常：可以在方法中就实现try-catch 处理掉异常<br>主方法 , 异常再继续上抛的话 , JVM默认处理 : 中止程序运行 + 打印出栈追踪信息<br>不论是否发生异常 , 最后都要加上收尾操作 : finally{} 不论 是否有异常, 是否被捕获 , 程序是否被中止, 都会执行finally语句<br>断言表达式<br>默认状态下不会自动开启断言操作 , 要实现断言操作 必须手动在虚拟机设置中去手动开启 :<br>在文件的运行与设置中 对当前的主文件 进行配置<br>在配置中选择实行虚拟机选项 : Alt + V ;<br>再VM配置中写入 -enableassertions ;<br>assert关键字 : + 判断语句 出现false 就会报出异常 </p><p>code :<br>package Today;</p><p>public interface Add {<br>    public int add(int a , int b )  ;<br>}</p><p>package Today;</p><p>public class Fulei {<br>    String name  ;</p><pre><code>public Fulei(String name)&#123;    this.name = name ;&#125;public String Lulao()&#123;    return (&quot;得得得得得得得得得&quot;);&#125;</code></pre><p>}</p><p>package Today;</p><p>public interface haoa {<br>    int  haoa(String a) ;<br>}</p><p>package Today;</p><p>public class Main {<br>    public static void main(String[]args){<br>        Test s &#x3D; new Test(&quot;ws1&quot;);<br>        Test.Inner inner &#x3D; new Test.Inner(&quot;wss1&quot;) ;<br>        inner.text(&quot;ws0&quot;);</p><pre><code>    Test s1 = new Test(&quot;ws2&quot;) ;    Test.Inner inner1 = new Test.Inner(&quot;wss2&quot;) ;    inner1.text(&quot;ws00&quot;);    class Inner&#123;        void text()&#123;            System.out.println(&quot;ws是gay&quot;);        &#125;    &#125;    Inner inner0 = new Inner() ;    inner.text(&quot;ws00&quot;);    class Inner11 extends Person&#123;        @Override        public void study() &#123;&#125; ;    &#125;    Person p = new Person()&#123;        String name  = &quot;,ws说自己是gay&quot; ;        public void study()&#123;            System.out.println(&quot;ws是gay&quot; + name );        &#125; ;    &#125; ;    p.study();    Fulei f = new Fulei(&quot;ws&quot;)&#123;        &#123;            System.out.println(name + &quot;是gay&quot;);        &#125;    &#125; ;    Add ws1 = (a , b ) -&gt; a + b  ;    System.out.println(ws1.add(1,2));    Add ws2 = Integer:: sum ;    System.out.println(ws2.add(1,2));    Fulei ws22 = new Fulei(&quot;卢姥爷&quot;);    Study ss =  ws22::Lulao;    System.out.println(ss.study());    haoa a = String::length;    String ws111 = &quot;得得得得得得得得得&quot; ;    System.out.println(a.haoa(ws111));&#125;private static void test(Study s)&#123;    s.study() ;&#125;</code></pre><p>}</p><p>package Today;</p><p>public abstract class Person {<br>    String name ;<br>    public abstract void study() ;<br>}</p><p>package Today;</p><p>public interface Study {<br>    public String study();<br>}</p><p>package Today;</p><p>public class Test {</p><pre><code>String name ;public Test(String name)&#123;    this.name = name ;&#125;static class Inner&#123;    String name ;    public Inner(String name)&#123;        this.name = name;    &#125;    public void text(String name) &#123;        System.out.println(name + &quot;是gay&quot;);        System.out.println(this.name + &quot;是gay&quot;);    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java07</title>
      <link href="/2025/12/26/java07/"/>
      <url>/2025/12/26/java07/</url>
      
        <content type="html"><![CDATA[<p>第八天学习<br>内部类<br>在类里创建类 ：内部类 ;<br>内部类也可以含有成员变量和方法<br>内部类可以设置访问权限控制  ( 方法和成员变量 )<br>成员内部类可以访问到外部变量( 外面无法访问内部 ) ;</p><p>静态内部类 :<br>在之前的内部类前加static 即可 ;<br>只能访问外部的静态属性  , 不可能访问到外部的方法 ;<br>局部内部类<br>匿名内部类<br>必须创建为public类的方法 : 方法重写不能更严格<br>匿名内部类中也是可以实现创建属性 :<br>但是创建方法在外部不会被调用 ;<br>但可以内部创建方法 实现辅助 抽象方法的实现 ;<br>Lambda 表达式  : 只限制在只有一个待实现方法的接口<br>正常实现接口方法<br>&#x2F;&#x2F;正常实现接口方法<br>Study study &#x3D; new Study(){<br>    public void study() {<br>        System.out.println(&quot;ws是gay&quot;);<br>    }<br>} ;<br>study.study();<br>&#x2F;&#x2F;使用lambda表达式实行<br>  Study study &#x3D; (变量名)-&gt; {<br>  System.out.println(&quot;ws是gay&quot; + 变量名) ;  &#x2F;&#x2F;变量名要保持一致<br>  } ;<br>        study.study();<br>实现创建静态的方法实现调用接口和实现传参</p><p>test((a) -&gt;{<br>        System.out.println(&quot;ws&quot;+ a + &quot;是gay&quot;);<br>    } ) ;<br>}</p><p>private static void test(Study s){<br>    s.study(123) ;<br>}<br>基本格式 : (参数列表) -&gt; { 方法体 }  : 这一坨就代表一种方法（接口中待实现的方法）；<br>方法引用<br>::直接引用方法实现功能</p><p>Add ws2 &#x3D; Integer:: sum ;<br>System.out.println(ws2.add(1,2));<br>等于上述的方法引用</p><p>Add ws1 &#x3D; (a , b ) -&gt; a + b  ;<br>System.out.println(ws1.add(1,2));<br>静态方法实现　：类名 :: 方法名 的形式<br>将别的类中方法( 返回值类型相同 )的传入到接口函数中去</p><p>Fulei ws22 &#x3D; new Fulei(&quot;卢姥爷&quot;);<br>Study ss &#x3D;  ws22::Lulao;<br>System.out.println(ss.study());<br>注意在实现方法引用的时候后面无() ;<br>构造方法 :<br>String str &#x3D; new String() ;<br>接口 变量名 &#x3D; 类名:: new ; 这里的new写法是统一的构造写法<br>实现接口后利用接口变量来引用接口中的函数</p><p>haoa a &#x3D; String::length;<br>String ws111 &#x3D; &quot;得得得得得得得得得&quot; ;<br>System.out.println(a.haoa(ws111));</p><p>练习代码8</p><p>package Today;</p><p>public class Main {<br>    public static void main(String[]args){<br>        Test s &#x3D; new Test(&quot;ws1&quot;);<br>        Test.Inner inner &#x3D; new Test.Inner(&quot;wss1&quot;) ;<br>        inner.text(&quot;ws0&quot;);</p><pre><code>    Test s1 = new Test(&quot;ws2&quot;) ;    Test.Inner inner1 = new Test.Inner(&quot;wss2&quot;) ;    inner1.text(&quot;ws00&quot;);    class Inner&#123;        void text()&#123;            System.out.println(&quot;ws是gay&quot;);        &#125;    &#125;    Inner inner0 = new Inner() ;    inner.text(&quot;ws00&quot;);    class Inner11 extends Person&#123;        @Override        public void study() &#123;&#125; ;    &#125;    Person p = new Person()&#123;        String name  = &quot;,ws说自己是gay&quot; ;        public void study()&#123;            System.out.println(&quot;ws是gay&quot; + name );        &#125; ;    &#125; ;    p.study();    Fulei f = new Fulei(&quot;ws&quot;)&#123;        &#123;            System.out.println(name + &quot;是gay&quot;);        &#125;    &#125; ;    Add ws1 = (a , b ) -&gt; a + b  ;    System.out.println(ws1.add(1,2));    Add ws2 = Integer:: sum ;    System.out.println(ws2.add(1,2));    Fulei ws22 = new Fulei(&quot;卢姥爷&quot;);    Study ss =  ws22::Lulao;    System.out.println(ss.study());    haoa a = String::length;    String ws111 = &quot;得得得得得得得得得&quot; ;    System.out.println(a.haoa(ws111));&#125;private static void test(Study s)&#123;    s.study() ;&#125;</code></pre><p>}</p><p>package Today;</p><p>public abstract class Person {<br>    String name ;<br>    public abstract void study() ;<br>}</p><p>package Today;</p><p>public interface Study {<br>    public String study();<br>}</p><p>package Today;</p><p>public class Test {</p><pre><code>String name ;public Test(String name)&#123;    this.name = name ;&#125;static class Inner&#123;    String name ;    public Inner(String name)&#123;        this.name = name;    &#125;    public void text(String name) &#123;        System.out.println(name + &quot;是gay&quot;);        System.out.println(this.name + &quot;是gay&quot;);    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java06</title>
      <link href="/2025/12/25/java06/"/>
      <url>/2025/12/25/java06/</url>
      
        <content type="html"><![CDATA[<p>package Next_day;</p><p>public class Main {<br>    public static void main(String[]args){<br>        String str &#x3D; &quot;杰哥&quot; + &quot;你干嘛&quot;  ;<br>        String str2 &#x3D; &quot;汉堡&quot; ;<br>        String str3 &#x3D; &quot;坐的&quot; ;<br>        String str4 &#x3D; &quot;行不行&quot; ;<br>        String str5 &#x3D; &quot;   &quot; ;</p><pre><code>    System.out.println(str.strip());    System.out.println(str2.stripLeading());   //去除前列的空格    System.out.println(str3.stripTrailing());  //去除后列的空格    System.out.println(str + str2 + str3 + str4);    StringBuilder builder = new StringBuilder() ;    builder.append(&quot;AAA&quot;) ;    builder.insert(1 , &quot;BBB&quot;) ;    builder.delete(2 , 3 ) ;    System.out.println(builder.toString());    String fen = &quot;&quot;&quot;            shiqihaowuliao@qq.com,             17hwliao.io            相            &quot;&quot;&quot; ;    String str10 = &quot;shiiqhaowuliao@qq.com&quot; ;    System.out.println(str10.matches(&quot;[A-Za-z0-9]*@[A-zA-z0-9]&#123;1,5&#125;\\.com&quot;));    System.out.println(test(str10 ,str,89)) ;    System.out.println(fen);    System.out.println(new Ppint(1 , 2 ));    System.out.println(new continuer(1));&#125;public static String test(Object obj , String str , Integer score) &#123;    String t = switch (obj) &#123;        case String _ -&gt; &quot;String&quot;;        case Integer _ -&gt; &quot;Integer&quot;;        case Ppint(int x ,int _) -&gt; &quot;坐标是&quot; + x + &quot; , &quot; + &quot;  &quot; ;        case continuer(String s ) -&gt; &quot;continue&quot;+ &quot;String&quot; ;        case null -&gt; &quot;NULL&quot;;        default -&gt; &quot;Other&quot;;    &#125;;    System.out.println(t);    String type = switch (str) &#123;        case String s when s.isEmpty() -&gt; &quot;Empty&quot;;        case String s when s.isBlank() -&gt; &quot;Blank&quot;;        case String s when s.length() &gt; 2 -&gt; &quot;haohaiyou&quot;;        default -&gt; &quot;Other&quot;;    &#125;;    if (obj instanceof String) &#123;        System.out.println(&quot;String&quot;);    &#125; else if (obj instanceof Integer) &#123;        System.out.println(&quot;Integer&quot;);    &#125; else &#123;        System.out.println(&quot;Other&quot;);    &#125;    return switch (score) &#123;        case Integer c when c &gt;= 90 -&gt; &quot;优秀&quot;;        case Integer c when c &gt;= 80 -&gt; &quot;良好&quot;;        case Integer c when c &gt;= 70 -&gt; &quot;及格&quot;;        default -&gt; &quot;滚蛋&quot;;    &#125; ;&#125;</code></pre><p>}</p><p>package Next_day;</p><p>public record Ppint(int x , int y ) {<br>}</p><p>package Next_day;</p><p>public record continuer(Object data) {<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java05</title>
      <link href="/2025/12/24/java05/"/>
      <url>/2025/12/24/java05/</url>
      
        <content type="html"><![CDATA[<p>● 面向对象 :<br>基本类型包装类 :<br>基本类型 (代表具体数值)  !&#x3D; 引用类型  ( 代表对象的引用 )</p><p>设计了包装类　：实现将 基本类型 当作 引用类型来用<br>基本类型包装类 : 继承Number :<br>Integer a &#x3D; Integer.valueOf(222);   &#x3D;&#x3D;  ( 自动装箱机制)  Integer a &#x3D; 222;   ( Java9之后去除 new 创建的方法 )  { 内部传入value 后会变为final 类型 }<br>Integer a &#x3D; Integer.valueOf(222 , 进制数(实现自动转化));<br>Integer a &#x3D; 222 ; </p><p>int p &#x3D; a  +  10 ;<br>int p &#x3D; a.intValue() * b.intValue() ;<br>Integer a &#x3D; 333 , b &#x3D; 2  ;<br>Integer c &#x3D; 333 ;<br>System.out.println( a &#x3D;&#x3D; c );<br>节省内存开销( -127 ~128 )会使用内部创建好的缓存对象<br>快速转化类型 -&gt; 函数 : (byte) &#x3D;&#x3D; 对象.byteValue() ;<br> 对象1.compareTo() : 输出 0 ( 相等 )  ;  输出 1 ( 对象1大 ) , 输出 -1 ( 对象1小 )<br>toString() ,   toHexString 可以转化为16 进制的字符串</p><p>● 特殊包装类<br>BigInteger 类 : 用于储存超大数据 ;<br>不支持自动 装箱 和 拆箱<br>存入数据时 使用valueOf函数 : 内部数据传入时末尾要加上L<br>BigInteger a2 &#x3D; BigInteger.valueOf(1211212223423423L);<br>BigInteger b2 &#x3D; BigInteger.valueOf(Long.MAX_VALUE);<br>BigInteger c2 &#x3D; BigInteger.valueOf(Long.MAX_VALUE) ;<br>计算　：<br>BigInteger result &#x3D; i.multiply(i) ; 实现乘法 ;<br>add : 加法<br>subtract : 减法<br>remainder : 除法<br>内部函数 a2.pow() ; 实现惊人的数据大小<br>BigInteger remainder &#x3D; a.remainder(b);</p><p>BigDecimal 类: 储存巨大精度的小数<br>不支持自动 装拆<br>divide 除法 ( 除数  , 保留位数精度 , (四舍五入 , 向上取整 ))<br>BigDecimal d &#x3D; BigDecimal.valueOf(29);<br>BigDecimal result &#x3D; d.divide(BigDecimal.valueOf(3), 199999 , RoundingMode.HALF_UP);<br>加减乘法同上<br>实现取余 ：　<br>BigDecimal remainder &#x3D; a.remainder(b);<br>● 数组( 存储的是基本数据类型 不能储存对象 )<br>int[] arr &#x3D; new int[ n ] ; n表示大小<br>类型[] 变量名 先声明 再传值<br>变量名 &#x3D;  new int[] { 数据 } : 静态初始化<br>直接初始化 ; 类型[] 变量名  &#x3D; { 数据 } ;<br>可以使用Object obj 来获取arr ;<br>可以使用arr的内部函数 length ;<br>数组类型是引用类型 : 不同对象 { 即使内容相同}<br>二维数组 : int[][] arr &#x3D; new int [2 ] [ ] ;<br>arr[ x ] &#x3D; new int [y] ; ( 设置x 行为 y 列 ) ; </p><p>●  可变长参数<br>main方法中 :<br> 方法( 对应类型的数据 ) ;<br>林好尴尬 方法( 类型 ) 当有可变长参数的时候只能存在一个且要放到末尾 : 不可控制大小<br> 便捷操作 :  可引用类型.for + 回车 自动变换为for的范围循环<br>args 实际上是指令行 ,从程序外构造出的程序实参</p><p>● 字符串<br>String 本身就是类<br>java17 之前是 char类型  ;<br>java17 之后是 byte类型 ;<br>会底层优化 : 不明确创建对象 的话 实际还是引用<br>切割函数 : substring( 起始位置 , 切割长度 ) ;  返回的是一种新的对象<br>分割函数 : String[] arr &#x3D; 字符串.split(&quot;分割位置所需的字符&quot;)<br>直接使用工具类来打印数组 : Arrays.toString(arr) ;<br>通过 字符串变量 . toCharArray() ; 可以实现获取一个char类型的数组<br>char[] chara &#x3D; {&#39;1&#39; ,&#39;2&#39; , &#39;3&#39;} ;<br>System.out.println(new String(chara));<br>String s1 &#x3D; &quot;hell o &quot; ;<br>String[] brr &#x3D; s1.split(&quot; &quot;);<br>System.out.println(s1.replace(&quot;hell&quot;, &quot;ciall&quot; ));</p><p>package io_17hwlioa;</p><p>import java.math.BigDecimal;<br>import java.math.BigInteger;<br>import java.math.RoundingMode;<br>import java.util.ArrayList;</p><p>public class Exercise {</p><pre><code>public static void main(String[] args) throws CloneNotSupportedException &#123;    Student s = new Student() ;    s.setName(system.SLEEP);    System.out.println(s.getName().getName());    Dingdan m = new Dingdan(1 , &quot;chabaidao&quot; , &quot;xinan&quot;) ;    Dingdan m1 = new Dingdan(2 , &quot;chabaidao&quot; , &quot;xinan&quot;) ;    System.out.println(m);    Integer q = 222 ;    Integer a = 10 , b = 2  ;    int p = a.intValue() * b.intValue() ;    Integer c = 10 ;    System.out.println( a == c );    Integer a1 = 1221 ;    Integer b1 = 1222 ;    int c1 = a1 ;    System.out.println(a1.compareTo(b1));    BigInteger a2 = BigInteger.valueOf(1211212223423423L);    BigInteger b2 = BigInteger.valueOf(Long.MAX_VALUE);    BigInteger c2 = BigInteger.valueOf(Long.MAX_VALUE);    BigInteger a3 = b2.multiply(a2);    System.out.println(a3);    System.out.println(a3.bitLength());    System.out.println(a3.pow(1));    BigDecimal d = BigDecimal.valueOf(29);    BigDecimal result = d.divide(BigDecimal.valueOf(3) , 1 , RoundingMode.HALF_UP);    System.out.println(result);</code></pre><p>;<br>        String[] str ;<br>        str &#x3D; new String[]{ &quot;qqqq &quot;, &quot;sssss&quot; , &quot;wwwwww&quot;};</p><pre><code>    test(222,str ) ;    for (String arg : args) &#123;        System.out.println(arg);    &#125;    String s1 = &quot;hell o &quot; ;    String[] brr = s1.split(&quot; &quot;);    System.out.println(s1.replace(&quot;hell&quot;, &quot;ciall&quot; ));    for (String string : brr) &#123;        System.out.println(string);    &#125;    char[] chara = &#123;&#39;1&#39; ,&#39;2&#39; , &#39;3&#39;&#125; ;    System.out.println(new String(chara));&#125;private static void test(  int si  ,String... text)&#123;    System.out.println(&quot;传入参数&quot; + text.length);    for(var it : text)&#123;        System.out.println(it);    &#125;    System.out.println(si);&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java04</title>
      <link href="/2025/12/23/java04/"/>
      <url>/2025/12/23/java04/</url>
      
        <content type="html"><![CDATA[<p>● Object 是所有类的父类 : 超类<br>public Object object 是一个公有的 Object 类型成员变量声明<br>object  &#x3D; new Object();  设计一个Object 对象 , 可以实现调用object内部所有函数<br>设计函数传入类型为Object obj  可以在调用函数的时候传入任意数据<br>● 深浅拷贝 :<br>浅拷贝 : 只会基础 复制值传给拷贝对象 , 对引用型 只会传递对象地址  , 实际还是原来的对象;<br>深拷贝 : 无论是引用还是基本类型 , 会将引用类型中的全部内容拷贝为一个新的对象 , 包含成员变量<br>clone 拷贝方法 : 在主方法调用时需要在方法后加上    throws CloneNotSupportedException<br>clone重写 : return super clone() ;   后要加上接口 : 直接加上 Cloneable<br>拷贝出的对象 与 原对象 指向一个地址 : java 中的拷贝实现浅拷贝<br>注意 : </p><ol><li>对象是新对象 ?（内存地址不同）</li><li>基本类型字段：复制的是值（不是地址）</li><li>引用类型字段：复制的是引用地址（指向同一个对象）</li></ol><p>● ( Java8后 )接口中的默认方法 :<br>在接口中实现默认方法 : 默认方法接口 和 父类中的方法会冲突( 会优先调用父类中的方法 ) ;<br>default void  study(){<br>    System.out.println(&quot;默认实现&quot;);<br>}</p><p>可以实现静态变量( 实则为常量 ) , 静态方法 : static( 系统会自己补 ) int a  &#x3D; 10 ; ( 加final 或者 static 都是多余的 )</p><p>● (java9后 )接口条件继续放宽　:<br> 允许private方法 : 只能内部使用 , 让其他内部的 public 和 static  , default 使用</p><p>●  枚举类 ( 基础类 )<br>创建一个enum 枚举类 ;<br>类中属性必须全部大写 : [ 静态常量 ]<br>将类中的需要限制变量定义为枚举类型  , 传入数据 和 返回值  都要限制为枚举类型<br>添加限制 , 实现控制输入合法性 : 传入对应方法的值只能为 枚举类.属性名<br>直接状态 : s.setName(system.STUDY);<br>添加状态 : s.setName(system.valueOf(&quot;STUDY&quot;));<br>可以内部创建方法 :<br>public enum system {<br>    SLEEP(&quot;dingyi&quot;), RUNNING(&quot;sau&quot;) , STUDY (&quot;hui&quot;) ;  &#x2F;&#x2F;后面加上对应字段实现调用状态时写出对应状态的描述</p><pre><code>String name ;    //内部创建参数system(String name)&#123;        this.name = name;&#125;public String getName()&#123;    return name ;&#125;</code></pre><p>}<br>Student s &#x3D; new Student() ;<br>s.setName(system.SLEEP);  得到枚举变量<br>System.out.println(s.getName().getName());   第一个返回枚举变量, 第二个调用枚举类的函数进行输出</p><p>●  记录类型 : 实现记录一些不可变数据的类<br>创建一个记录类 : 会自动编译出public get , equals , toString等方法 ;<br>public record Dingdan(int id , String product , String adress) {<br>}<br>Dingdan m &#x3D; new Dingdan(1 , &quot;chabaidao&quot; , &quot;xinan&quot;) ;<br>这时候直接sout(m)  后者 sout(m.属性名)    输出 : Dingdan[id&#x3D;1, product&#x3D;chabaidao, adress&#x3D;xinan]<br>可以在记录类中实现重写方法 : equals 或者其他方法( 设计传入类型为Object obj )<br>无法内部设计方法修改 传入的id名( final )</p><p>● ( Java17 ) 密封类<br>添加 final 关键词实现 防继承 ; ( 太激进 )<br>添加 sealed 关键字 , 表示密封类  类名后添加 permits 允许记录的子类<br>sealed 和 final 无法共存<br>必须要有子类继承<br>子类必须要标记为final , sealed 同父类 继续继承下去 或是 non-sealed ( 允许所有人继承 ; )类型<br>[访问修饰符] [sealed&#x2F;non-sealed&#x2F;final] class 类名<br>[extends 父类] [implements 接口...]<br>[permits 子类...] {<br>    &#x2F;&#x2F; 类体<br>}<br> 当第一个子类声明为 sealed 时，第二个子类继承的是第一个子类，而不是原始父类。</p><p>package io_17hwlioa;</p><p>public class Exercise {</p><pre><code>public static void main(String[] args) throws CloneNotSupportedException &#123;    Student s = new Student() ;    s.setName(system.SLEEP);    System.out.println(s.getName().getName());    Dingdan m = new Dingdan(1 , &quot;chabaidao&quot; , &quot;xinan&quot;) ;    Dingdan m1 = new Dingdan(2 , &quot;chabaidao&quot; , &quot;xinan&quot;) ;    System.out.println(m);&#125;</code></pre><p>}</p><p>package io_17hwlioa;</p><p>import java.util.Objects;</p><p>public sealed class Person implements Study permits Student  {<br>    private String name;<br>    private int age;<br>    public Person() {</p><pre><code>&#125;public Person(String name, int age) &#123;    this.name = name ;    this.age = age ;&#125;public Person(String name)&#123;    this.name = name;    System.out.println(getname());&#125;public void unit(String name , int age)&#123;    this.name = name;    this.age = age;&#125;public String getname()&#123;    return name  ;&#125;public void teach()&#123;    System.out.println(&quot;我爱教Java&quot;);&#125;@Overridepublic boolean equals(Object o) &#123;    if (!(o instanceof Person person)) return false;    return age == person.age &amp;&amp; Objects.equals(name, person.name);&#125;public  void hello() &#123;    System.out.println(&quot;qunide&quot;);&#125;;</code></pre><p>}</p><p>package io_17hwlioa;</p><p>public final class Student extends Person implements Study {<br>    String name ;<br>    int age  ;<br>    private system hehe ;<br>    public Object object  ;</p><pre><code>public Student(String name, int age) &#123;    super(name, age);    object  = new Object();    System.out.println(super.getname());&#125;public system  getName()&#123;    return hehe ;&#125;public void setName(system hehe)&#123;    this.hehe = hehe;&#125;public Student(String name )&#123;    super(name );    this.name = name ;    System.out.println(super.getname() + name);&#125;public Student()&#123;&#125; ;@Overridepublic void teach()&#123;    System.out.println(&quot;我要教同学java&quot;);&#125;public void hello()&#123;    System.out.println(&quot;hello&quot;);&#125;</code></pre><p>}</p><p>package io_17hwlioa;</p><p>public enum system {<br>    SLEEP(&quot;dingyi&quot;), RUNNING(&quot;sau&quot;) , STUDY (&quot;hui&quot;) ;</p><pre><code>String name ;system(String name)&#123;    this.name = name;&#125;public String getName()&#123;    return name ;&#125;</code></pre><p>}</p><p>package io_17hwlioa;</p><p>public interface Study {<br>    default void  study(){<br>        System.out.println(&quot;默认实现&quot;);<br>    }</p><pre><code>private void inner()&#123;    System.out.println(&quot;内部操作&quot;);&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing35</title>
      <link href="/2025/12/23/acwing35/"/>
      <url>/2025/12/23/acwing35/</url>
      
        <content type="html"><![CDATA[<p>Prim算法 :<br>const int N &#x3D; 501;<br>int n, m;<br>int p[N][N];<br>int d[N];<br>bool st[N];</p><p>int Prim() {<br>memset(d, 0x3f, sizeof d);<br>d[1] &#x3D; 0;<br>int res &#x3D; 0;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>int t &#x3D; -1;<br><br>&#x2F;&#x2F;找到未进入生成树的距离最小点<br>for (int j &#x3D; 1; j &lt;&#x3D; n; j++)<br>if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || d[t] &gt; d[j]))<br>t &#x3D; j;<br><br>&#x2F;&#x2F;如果图无法连通 , 返回无穷大<br>if (i &amp;&amp; d[t] &#x3D;&#x3D; 0x3f3f3f3f) return 0x3f3f3f3f;<br><br>&#x2F;&#x2F;累加边权( 除了第一个点 )<br>if ( i ) res +&#x3D; d[t];<br>st[t] &#x3D; true;</p><pre><code>// 用 已完成的点去更新其他未加入点的距离for (int j = 1; j &lt;= n; j++)if (!st[j]) &#123;d[j] = min(d[j], p[t][j]);&#125;&#125;return res;</code></pre><p>}</p><p>int main() {<br>memset(p, 0x3f, sizeof p);         &#x2F;&#x2F;初始化各个顶点的距离为 最大值 ;<br>cin &gt;&gt; n &gt;&gt; m;<br>while (m--) {<br>int a, b, c;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>p[a][b] &#x3D; p[b][a] &#x3D; min(p[a][b], c);      &#x2F;&#x2F;处理重边 , 保留最小权值<br>}<br>int t &#x3D; Prim();<br>if (t &#x3D;&#x3D; 0x3f3f3f3f) {<br>cout &lt;&lt; &quot;impossible&quot;;<br>}<br>else {<br>cout &lt;&lt; t;<br>}<br>return 0;<br>}</p><p>Kruskal 克鲁斯卡尔 算法 :<br>&#x2F;&#x2F;1. 将所有边按权重排序( sort ) ;<br>&#x2F;&#x2F;2.枚举每条边 , 判断是否连通, 不连通 -&gt; 放入数组中去<br>int n, m;<br>int p[N]; </p><p>struct Edge {<br>int a, b, w; </p><pre><code>bool operator&lt; (const Edge &amp;W ) const&#123;            //重载 加 sort 排序实现按边权升序排序return w &lt; W.w; &#125;</code></pre><p>}edges[M];            &#x2F;&#x2F;创建边</p><p>&#x2F;&#x2F;初始化并查集<br>int  find(int x) {<br>if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);<br>return p[x];<br>}</p><p>int main() {<br>cin &gt;&gt; n &gt;&gt; m;<br><br>循环 M 次 输入边<br>for (int i &#x3D; 0; i &lt; m ; i++) {<br>int a, b, w;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>edges[i] &#x3D; { a , b ,w };<br>}<br><br>按边权值排序<br>sort(edges, edges + m);<br><br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++)   p[i] &#x3D; i;<br><br>int res &#x3D; 0, cnt &#x3D; 0;<br><br>for (int i &#x3D; 0; i &lt; m; i++) {<br><br>int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;<br><br>a &#x3D; find(a), b &#x3D; find(b);<br>if (a !&#x3D; b) {<br>p[a] &#x3D; b;     &#x2F;&#x2F;合并集合<br>res +&#x3D; w; &#x2F;&#x2F;累加最小生成树的权值<br>cnt++; &#x2F;&#x2F;记录已选边数<br>}<br>}<br><br>最小生成树是否含 n - 1 条边<br>if (cnt &lt; n - 1) cout &lt;&lt; &quot;impossible&quot;;<br>else cout &lt;&lt; res ; </p><pre><code>return 0; </code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java03</title>
      <link href="/2025/12/22/java03/"/>
      <url>/2025/12/22/java03/</url>
      
        <content type="html"><![CDATA[<p>● Object 类 :<br>object 类 : 所有的类都继承于 object 类(  被省略而已 )<br>每个初建的类的方便函数 继承于 object 类<br>native 方法底层使用C++实现 无法直接在java中调用<br>hashcode 返回int 表示返回对象的内存地址<br>equals 判断( 返回Boolean )当前对象和this是否相同<br>clone 返回Object类型 实现复制一个完全相同的对象 , 包含目标对象属性<br>toString 将对象( 包含类名也可 )转化为String类型<br>println 只可以实现单变量的输出 , 根据传入数据类型找最近的类库函数<br>多线程函数 notify , wait , wait;<br>finalize 已经被弃用 , 在JVM中有更好的释放资源的手段 </p><p>小更新:<br>instanceof  之前 ：　实现判断 类 或 该类的子代索引用关键字<br>在判断时在类型的后面加变量名 实现直接类型转化<br>private static void test(Person s){<br>    if(s instanceof Student stu){<br>        stu.study();<br>    } else if( s instanceof Person se){<br>        se.teach() ;<br>    } else{<br>        System.out.println(&quot;111&quot;);<br>    }<br>}</p><p>● 方法的重写<br>子类定义和父类名字相同的方法会发生重写<br>只是实现在子类中覆盖了父类中该名字的方法实现<br>重写后  调用父类的方法使用的是父亲的<br>调用子类的就是子类的方法<br>1 . 注意( 实现重写的关键注意点 )　：   Person p1 &#x3D; student ;<br>只有当父类指向子类对象时( 多态 ) , 才会调用子类重写后的方法<br>2.使用static标记的静态方法无法通过重写 , 但还是可以各用各的 ;<br>3.添加了final的方法无法被重写<br>即使创建一个父类的对象 但传入的是子类, 也是使用子类的方法<br>争对上面的创建 , 在调用属性时p1调用的是自己本身所属的内容<br>在重写会提供系统标示 @Override<br>判断字符串是否相符 使用equals 实现判断对象是否相同<br>● &#x3D;&#x3D; 比较的是内存地址（是否为同一个对象）<br>● equals() 比较的是内容（字符序列是否相同）<br>println即是调用toString方法  : 可以在类中重写实现完整输出 ( 会在调用println时自动运行 ) ;<br>父类方法private的时候会实现共存 </p><p>● 抽象类<br> 类变为抽象类时只有被继承的能力<br>不能被实例化 , 不能被new对象无法实例化<br>可以和实例方法共存<br>可以包含成员变量</p><p>● 接口( 类似插件 )  interface<br>1.在要接口的类加上 implements 方法名( 大写首字母 )<br>创建接口文件<br>只能存在变量只能为常量 , 方法只能为 : 公共抽象方法 , 公共方法   :<br>public abstract  void 方法<br>可以将子类当作接口来用<br>Study s &#x3D; new Student()  ;<br>s . 方法名() ; </p><p>2.继承只能一传一 , 但接口可以实现一对多 , 同时实现功能<br>implements 方法名 , 另外的方法( 首字母大写 )</p><p>3.继承是获得类的属性和成员方法, 但接口只能实现功能连属性都没有 , 且方法要到子类里才能去定义<br>修改系统函数 : 创建接口 , 在调用时转化权限为public 类型<br>修改后的系统函数 , 通过return super.clone() ; 必须使用super克隆 ,系统函数的底层是使用C++ 代码实现<br>在类中调用时</p><ol><li>Object.clone() 方法本身就声明了 throws CloneNotSupportedException</li><li>当重写一个方法时，不能添加比父类方法更多的检查型异常</li><li>所以必须保持相同的异常声明</li></ol><p>code 练习 :<br>package io_17hwlioa;</p><p>public class Exercise {<br>    public static void main(String[] args) {</p><pre><code>    Student student = new Student(&quot;shiqi&quot; ) ;    test( student ) ;    student.teach() ;    Person p1 = new Person() ;    p1.study();    student.study(); ;    p1.teach() ;    p1.hello() ;    student.hello() ;&#125;private static void test(Person s)&#123;    if(s instanceof Student stu)&#123;        stu.study();    &#125; else if( s instanceof Person se)&#123;        se.teach() ;    &#125; else&#123;        System.out.println(&quot;111&quot;);    &#125;&#125;</code></pre><p>}</p><p>package io_17hwlioa;</p><p>public class Student extends Person implements Study ,Hello{<br>    String name ;<br>    int age  ;</p><pre><code>public Student(String name, int age) &#123;    super(name, age);    System.out.println(super.getname());&#125;public Student(String name )&#123;    super(name );    this.name = name ;    System.out.println(super.getname() + name);&#125;public void study()&#123;    System.out.println(&quot;我爱java&quot;);&#125;@Overridepublic void teach()&#123;    System.out.println(&quot;我要教同学java&quot;);&#125;public void hello()&#123;    System.out.println(&quot;hello&quot;);&#125;</code></pre><p>}</p><p>package io_17hwlioa;</p><p>public interface Study {<br>    void study() ;<br>}</p><p>package io_17hwlioa;</p><p>public interface Hello {<br>    void hello() ;<br>}</p><p>package io_17hwlioa;</p><p>public class Student extends Person implements Study ,Hello{<br>    String name ;<br>    int age  ;</p><pre><code>public Student(String name, int age) &#123;    super(name, age);    System.out.println(super.getname());&#125;public Student(String name )&#123;    super(name );    this.name = name ;    System.out.println(super.getname() + name);&#125;public void study()&#123;    System.out.println(&quot;我爱java&quot;);&#125;@Overridepublic void teach()&#123;    System.out.println(&quot;我要教同学java&quot;);&#125;public void hello()&#123;    System.out.println(&quot;hello&quot;);&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing34</title>
      <link href="/2025/12/22/acwing34/"/>
      <url>/2025/12/22/acwing34/</url>
      
        <content type="html"><![CDATA[<p>使用Dijkstra 算法实现找出最短路径<br>&#x2F;&#x2F;稠 : 邻接矩阵<br>&#x2F;&#x2F;稀 : 邻接表<br>int n , m ;<br>int p[N][N];<br>int d[N];<br>bool st[N]; </p><p>int dijkstra() {<br><br>memset(d, 0x3f, sizeof d);<br>d[1] &#x3D; 0; </p><pre><code>for (int i = 0; i &lt; n; i++) &#123;int t = -1;for (int j = 1; j &lt;= n; j++)&#123;if (!st[j] &amp;&amp; (t == -1 || d[t] &gt; d[j]))t = j;&#125;st[t] = true;for (int j = 1; j &lt;= n; j++)&#123;d[j] = min(d[j], d[t] + p[t][j]);               //利用已经存入的t值来更新后面的路径&#125;</code></pre><p>}<br><br>if (d[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;                 &#x2F;&#x2F;比较最大值 判断是否存在<br>return d[n]; &#x2F;&#x2F;存在的话 会输出到 n  的最短路径<br>}</p><p>int main() {<br><br>cin &gt;&gt; n &gt;&gt;  m ;<br>memset(p, 0x3f, sizeof p); </p><pre><code>while (m--) &#123;int a, b; cin &gt;&gt; a &gt;&gt; b; int c; cin &gt;&gt; c; p[a][b] = min(p[a][b], c); &#125;int count = dijkstra(); cout &lt;&lt; count &lt;&lt; &#39;\n&#39;;return 0;</code></pre><p>}</p><p>使用邻接表实现dijkstra算法:<br>typedef pair&lt;int, int &gt; PII;<br>const int N &#x3D; 1e4 + 17;<br>int n, m;<br>int w[N] , h[N], e[N], ne[N], idx;<br>int d[N];<br>bool st[N]; </p><p>void add(int a, int b, int c) {<br>e[idx] &#x3D; b;<br>ne[idx] &#x3D; h[a];<br>w[idx] &#x3D; c;<br>h[a] &#x3D; idx++;<br>}</p><p>int dijkstra() {<br>memset(d, 0x3f, sizeof d);<br>d[1] &#x3D; 0;<br>priority_queue&lt;PII, vector<PII>, greater<PII>&gt;  heap;<br>heap.push({0 ,1 });</p><pre><code>while (heap.size()) &#123;auto t = heap.top(); heap.pop(); int ver = t.second;   // 当前节点int dis = t.first;    // 当前距离if (st[ver]) continue;        // 如果已经确定最短距离，跳过st[ver] = true; //遍历ver邻接表 ; for (int i = h[ver]; i != -1; i = ne[i]) &#123;int j = e[i];      if (d[j] &gt; dis + w[i]) &#123;  d[j] = dis + w[i]; heap.push(&#123; d[j] , j &#125;); &#125;&#125;&#125;if (d[n] == 0x3f3f3f3f) return -1; return d[n]; </code></pre><p>}</p><p>int main() {</p><pre><code>memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; while (m--) &#123;int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125;int count = dijkstra();  cout &lt;&lt; count &lt;&lt; &#39;\n&#39;;return 0; </code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java02</title>
      <link href="/2025/12/21/java02/"/>
      <url>/2025/12/21/java02/</url>
      
        <content type="html"><![CDATA[<p>类的成员方法<br>静态方法 : </p><p>static 创建为属于类的属性  和对象无关 ; </p><p>static 可以创建静态变量 和 静态方法</p><p>静态成员（静态变量、静态代码块）在 类加载时 初始化，只执行一次，且 早于任何对象创建。<br>可以多次调用 , 但只属于类 , 可以修改值</p><p>注意 : 无法实现this 关键字的使用</p><p>除静态变量外 , 静态方法在不同的对象传入不同值时各自单独运行<br>静态方法可以在一个类中被 main 方法调用<br>实例方法需要创建一个类对象在进行调用</p><p>包</p><p>需要在包内的类中最上面说明所属类</p><p>package 包名 ;<br>import 导入不同包内的类<br>import.其他包名.* ; 利于* 表示导入其他包名中的全部类</p><p>类只能调用相同包内的类<br>不同包之间的可以创建同名的类<br>String如果发生命名冲突 : 在系统自带的String前补上包名java.long<br>访问权限限制<br>private ( 同类 ): 私有 , 标记为私有内容无法被除当前类以外的位置访问 ;<br>会导致无法创建出来类 ( 全是静态方法不需要创建 );<br>什么都不写( 同包 ): 默认 , 只能被类本身 和 同包 的其他类访问 ;<br>protected ( 同包 ): 受保护 ,标记为保护的内容可以被类本身和同包中的其他类访问 , 也可被子类访问 ;<br>public ( 任意 ): 公共 , 标记为公共的内容可以在任意位置去访问 ;<br>在同一个类中，所有方法无论权限修饰符是什么，都可以互相访问！<br>可以单独实现导入静态方法:<br>import static 包名.方法名<br>在main类中可以实现直接调用静态变量 + 静态方法</p><p>封装  继承   多态</p><p>封装 : 让外部只能调用内部的方法( public )才能修改内部参数( private ) ;</p><p>package com_java;</p><p>public class Person {<br>    private String name ;<br>    private int age;</p><pre><code>public void setName( String name ) &#123;    //封装name    this. name = name ;&#125;public void setAge(int age) &#123;    //封装age    this.age = age;&#125;public int getAge() &#123;    return age;&#125;public String getName() &#123;    return name;&#125;public static Person new_i()&#123;    //实现封装创建    return new Person();&#125;</code></pre><p>}</p><p>继承 :  </p><p>子类在构建时  , 不仅要初始化子类属性, 还要初始化父类的属性</p><p>父类的构造方法需要参数时 , 需要手动指定  若是无参数则可以不去指定</p><p>通过在新类的后面加extends ( 继承 ) 父类 </p><p>可以调用父类中的 所有 函数 和 变量<br>可以多层继承 , 继承的子代越多 , 获取的参数 和 方法就越多<br>使用public final class 限制继承 , 到达最终态 不能再被继承<br>快捷创建对象 new 类() . var会直接创建对象<br>父类 变量名1 &#x3D; new 子类() ; 只能调用父类中的属性<br>变量名 2&#x3D; (子类)  变量名1 可以实现强制转化<br>在传参时子类只要包含父类的全部属性就可以当作父类实现传参<br>instanceof用于判断变量是否为对应类型和对应子类 , 函数用于返回true 或者返回false ;<br>子类可以和父类创建同名属性:<br>如何在子类中含相同属性名, 还能获取父类的属性 : 使用super关键字  :<br>只能获取父类不能获取爷爷辈的属性变量</p><p>sout( super.name +  &quot; &quot;  ) ; </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java0111</title>
      <link href="/2025/12/20/java0111/"/>
      <url>/2025/12/20/java0111/</url>
      
        <content type="html"><![CDATA[<p>● 标签 :<br>可以将类里面的方法使用一个标签全部打包后</p><p>break + 标签（跳出指定代码区）<br>continue + 标签（跳到指定代码区）<br>outer : 放在外层循环 </p><p>运用 break outer 可以实现直接跳出外层循环<br>运用 continue outer 可以实现开始下一外层循环</p><p>● this 关键字的使用:  1.  区分成员变量和局部变量<br>     2.调用类中的方法</p><ol><li><p>参数名与成员变量名相同 → 必须使用this<br>着重代表此变量为当前对象本身内部的变量</p></li><li><p>参数名与成员变量名不同 → 可不使用this</p></li></ol><p>3.实现找出<br>● 方法重载</p><ol><li>同一类中方法名相同</li><li>实现功能类似但不是必须相同</li><li>编译器通过实现查看变量传入的 参数类型 , 顺序 和 数量 来判断不同类的方法   ( 返回值类型不同不构成重载 )</li></ol><p>● 方法的互调和递归<br>同一个类中可以实现方法之间的相互调用<br>方法自己调用自己实现递归调用 ( 区别: 不是用return 实现递归 ); </p><p>● 构造器<br>类都会自带一个无参数的构造方法<br>实际new Person()的时候就是调用构造方法创建对象<br>下面通过定义了构造无参数方法 ; </p><ol><li><p>直接初始化 对象内部资源 ;<br>Person. class :<br>Person(){<br> name &#x3D; &quot;xiao_ming&quot; ;<br> age &#x3D; 18 ;<br> gender &#x3D; &quot;nan&quot; ;<br>}</p></li><li><p>创建有参构造 : 实现在初始化的时候传入变量值<br>Person.class :<br>Person(String name , int age , String gender){<br> this.name &#x3D; name ;<br> this.age &#x3D; age ;<br> this.gender &#x3D; gender ;<br>}<br>Person(String name , String gender){<br> this(name , 16) ;<br> this.gender &#x3D; gender ;<br> this.age &#x3D; 187 ;<br>}</p></li></ol><p>Person(String name , int age ){<br>    this.name &#x3D; name ;<br>    this.age &#x3D; age ;<br>}<br>上述代码中会发生初始化 age的覆盖 : 187 ;<br>存在代码块特殊形式<br>在调用方法前按顺序运行<br>创建对象实例时（无论使用哪个构造函数）<br>调用方法时不会运行实例代码块。<br>{ 在大括号内直接进行编码 }</p><p>● final 关键词 : 在变量前加上final后此变量不会受后续的赋值操作更改<br>● 初始化加上final 必须赋值为空</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java011</title>
      <link href="/2025/12/19/java011/"/>
      <url>/2025/12/19/java011/</url>
      
        <content type="html"><![CDATA[<p>实现数组排序 : Arrays.sort(numbers);  &#x2F;&#x2F; 实现升序排序<br>Arrays.sort(nums, (a, b) -&gt; b - a);<br>&#x2F;&#x2F;实现降序排序</p><p>快捷输出 : sout 直接打印 System.out.println() ;<br>● 类</p><p>1.创建类文件<br>类名.java<br>class内装入属性值</p><p>2.引用类名<br>类名 变量名 &#x3D; new 类名() ;    进行引用( 必须引用对象)</p><p>3.对创建出的变量赋值和使用<br>可以不进行赋值  , 但仍可以实现正常输出 ,默认为空( null ) , int ( 0 ) , bool (false) ;<br>变量名.属性名 &#x3D; 对应值 ; </p><p>● 方法</p><p>1.方法 ( 函数 )定义 : 返回值类型 方法名( ) { 方法体 }      main即为方法  . </p><ol start="2"><li>类中的方法调用  成员变量     时使用的值即为当前对象的存放值</li></ol><p>3.就和正常函数使用类似<br>但注意 swap() 操作无法通过简单方法实现 , java是值传递语言<br>可以通过使用数组实现交换修改( 或者是封装 )<br>void swap(int[] arr, int i, int j) {<br>    int temp &#x3D; arr[i];<br>    arr[i] &#x3D; arr[j];<br>    arr[j] &#x3D; temp;<br>}</p><p>&#x2F;&#x2F; 使用<br>int[] values &#x3D; {5, 10};<br>swap(values, 0, 1);  &#x2F;&#x2F; values[0]&#x3D;10, values[1]&#x3D;5</p><ol start="4"><li></li></ol><p>你的理解完全正确：<br>“传入方法两个变量的值无法实现修改，但是可以修改传入方法的对象内部的值”<br>精辟的总结！ 这就是 Java 参数传递的本质：<br>● 传值（对于基本类型：传值的副本）<br>● 传引用的值（对于对象：传引用地址的副本）<br>● 通过引用副本可以找到真实对象并修改其内容</p><p>这正是 Java 中实现交换的标准模式：</p><ol><li>把需要交换的数据封装在对象中</li><li>传递这个对象的引用</li><li>通过引用修改对象内部字段</li><li>原调用处看到的是修改后的对象状态</li></ol><p>java参数传递是值传递 , 传递的是引用的副本 不是 引用本身<br>void trySwap(Person a, Person b) {<br>    Person temp &#x3D; a;    &#x2F;&#x2F; 交换的是副本引用<br>    a &#x3D; b;<br>    b &#x3D; temp;           &#x2F;&#x2F; 不影响原调用处的引用<br>}<br>但是可以修改对象的内容<br>void swapContent(Person a, Person b) {<br>    String tempName &#x3D; a.name;<br>    a.name &#x3D; b.name;    &#x2F;&#x2F; 修改的是对象内部数据<br>    b.name &#x3D; tempName;<br>}</p><p>public class Person {<br>    String name ;<br>    int age ;<br>    String gender ;<br>    int  cun1 ;<br>    int  cun2 ;<br>    void say_hello(){<br>        System.out.println(&quot; &quot; + name + &quot; &quot;+  age + &quot; &quot;+ gender);<br>    }</p><pre><code>int sum(int a , int  b)&#123;    int c = a + b ;    return c ;&#125;void test(int a) &#123;    for (int i = 0; i &lt; 10; i++) &#123;        if (i == a) &#123;            break;        &#125; else &#123;            System.out.println(&quot;hello&quot;);        &#125;    &#125;    System.out.println(&quot;hhhhhhh&quot;);&#125;void swap(int a, int b)&#123;        int temp = a;        a = b;        b = temp;&#125;void swap(Person person)&#123;    person.name = &quot;nitian&quot; ;&#125;void swap1(Person person)&#123;    int temp = person.cun1 ;    person.cun1 = person.cun2 ;    person.cun2 = temp ;&#125;</code></pre><p>}</p><p>public class java01 {<br>    public static void main(String[] args) {<br>        Person s  &#x3D; new Person() ;<br>        s.name &#x3D; &quot;xiaoming&quot; ;<br>        s.age &#x3D; 18 ;<br>        s.gender &#x3D; &quot;男&quot; ;<br>        System.out.println(s.name);<br>        s.say_hello();</p><pre><code>    Person s1 = new Person() ;    s1.name = &quot;xiaohong&quot; ;    s1.age = 18 ;    s1.gender  = &quot;女&quot; ;    s1.say_hello() ;    int a = 19 ;    int b = 11 ;    int c = s1.sum(a, b ) ;    System.out.println( &quot; &quot;+  c);    System.out.println(&quot; &quot;+ s.sum(10 , 100 ));    s.test(6) ;    s.swap(s) ;    System.out.println(s.name);    s.cun1 = 1000 ;    s.cun2 = 2000 ;    System.out.println(s.cun1);    System.out.println(s.cun2);    s.swap1(s) ;    System.out.println(s.cun1);    System.out.println(s.cun2);&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing33</title>
      <link href="/2025/12/19/acwing33/"/>
      <url>/2025/12/19/acwing33/</url>
      
        <content type="html"><![CDATA[<p>判断日期合理 : 闰年 : %400 &#x3D;&#x3D; 0 || % 4 &#x3D;&#x3D; 0 &amp;&amp; %100 !&#x3D; 0  ;   日期 : 30 , 31 , 二月 : 判断28 ? 29  ;</p><p>实现找树的重心 :<br>#include<iostream><br>#include<cstring><br>using namespace std;<br>const int N &#x3D; 1e5 + 17, M &#x3D; 2 * N;<br>int n;<br>int e[M], ne[M], idx , h[N];<br>int ans &#x3D; N;<br>bool st[N]; </p><p>void add(int a, int b) {<br>e[idx] &#x3D; b;<br>ne[idx] &#x3D; h[a];<br>h[a] &#x3D; idx++;<br>}</p><p>int dfs(int x) {<br>st[x] &#x3D; true;<br>int sum &#x3D; 1, res &#x3D; 0;   &#x2F;&#x2F;res &#x3D;  删除当前节点后，最大连通块的大小<br><br>for (int i &#x3D; h[x]; i !&#x3D; -1; i &#x3D; ne[i]) {<br><br>int j &#x3D; e[i];<br><br>if (!st[j]) {<br>int s &#x3D; dfs(j); <br>sum +&#x3D; s ;              &#x2F;&#x2F;sum记录当前加节点的子树大小<br>res &#x3D; max(res, s);     &#x2F;&#x2F;更新最大子连通块<br>}<br>}<br>res &#x3D; max(res, n - sum);           &#x2F;&#x2F;计算一边的子联通块 , 快捷计算另外的子连通块<br><br>ans &#x3D; min(ans, res);          &#x2F;&#x2F;更新最小最大连通块的大小;<br><br>return sum;                         &#x2F;&#x2F;返回子数 的大小<br>}</p><p>int main() {<br>memset(h, -1, sizeof h);<br>cin &gt;&gt; n;<br>for (int i &#x3D; 1; i &lt;  n ; i ++ ) {<br>int a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>add(a, b);<br>add(b, a);<br>}<br>dfs(1);<br>cout &lt;&lt; ans;<br>return 0;<br>}</p><p>实现找数的层次 , 找出最短路径<br>#include <iostream><br>#include <cstring><br>using namespace std;</p><p>const int N &#x3D; 100010;<br>int n, m;<br>int h[N], e[N], ne[N], idx;  &#x2F;&#x2F; 邻接表<br>int d[N];                    &#x2F;&#x2F; 距离数组<br>int q[N];                    &#x2F;&#x2F; 数组模拟队列</p><p>void add(int a, int b) {<br>    e[idx] &#x3D; b;<br>    ne[idx] &#x3D; h[a];<br>    h[a] &#x3D; idx++;<br>}</p><p>int bfs() {<br>    &#x2F;&#x2F; 初始化距离为-1（表示未访问）<br>    memset(d, -1, sizeof d);</p><pre><code>// 初始化队列int hh = 0, tt = -1;  // 队列头尾指针// 起点入队并标记距离q[++tt] = 1;d[1] = 0;while (hh &lt;= tt) &#123;  // 队列不为空    int t = q[hh++];  // 取出队头        // 提前终止：如果已经到达终点    if (t == n) break;        // 遍历所有邻接点    for (int i = h[t]; i != -1; i = ne[i]) &#123;        int j = e[i];        if (d[j] == -1) &#123;  // 未访问过            d[j] = d[t] + 1;  // 更新距离            q[++tt] = j;      // 入队        &#125;    &#125;&#125;return d[n];  // 返回到达n的最短距离，无法到达则返回-1</code></pre><p>}</p><p>int main() {<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);</p><pre><code>// 初始化邻接表memset(h, -1, sizeof h);cin &gt;&gt; n &gt;&gt; m;while (m--) &#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    add(a, b);  // 添加有向边&#125;cout &lt;&lt; bfs() &lt;&lt; endl;return 0;</code></pre><p>}</p><p>使用动态规划实现斐波那契数列<br>long test(int x ){<br>    if(x &lt;&#x3D; 0 ) return 0 ;<br>    if(x  &lt; 3 ) return 1 ;<br>    long [] dp &#x3D; new long [ x + 1 ];<br>    dp[0] &#x3D; 0 ;<br>    dp[1] &#x3D; 1 ;<br>    dp[2] &#x3D; 1 ;<br>    for(int i &#x3D; 3 ; i &lt;&#x3D; x ; i ++){<br>        dp[i] &#x3D; dp[i - 1] + dp[i -2 ] ;<br>    }<br>    return dp[x] ;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing32</title>
      <link href="/2025/12/18/acwing32/"/>
      <url>/2025/12/18/acwing32/</url>
      
        <content type="html"><![CDATA[<p>Bell-man算法 ( O（n * m）)  :  求最多不超过K的最短路径 ( 存在负权回路  但最多k次不会受负环影响 )<br>使用min 记录最小路径值 , 使用 K 去卡住循环次数 , 防止更新<br>int n, m, k;               &#x2F;&#x2F;n：顶点数        m：边数      k：最多允许经过的边数<br>const int N &#x3D; 10010;<br>int arr[N];              &#x2F;&#x2F;从起点 1 到顶点 i 的当前最短距离<br>int arr2[N];            &#x2F;&#x2F;上一轮迭代的距离数组（避免本轮更新相互影响）</p><p>struct Bian {<br>int x, y, z;          &#x2F;&#x2F;&#x2F;&#x2F; 从x到y的有向边，权重为z<br>}bian[N];</p><p>int bf() {<br>memset(arr , 0x3f , sizeof(arr));<br><br>arr[1] &#x3D; 0;<br><br>for (int i &#x3D; 0   ;    i &lt; k  ;   i++) {             &#x2F;&#x2F;限制迭代 k 次<br><br>memcpy(arr2, arr, sizeof(arr));            拷贝上一轮的结果 ( strcpy：专门用于复制 字符串（以 \0 结尾）<br>  memcpy：用于复制 任意内存块 , 会复制到 &#x2F;0 之后需要严格设计大小（不关心内容类型） )<br>for (int j &#x3D; 0; j &lt; m; j++) {<br>int  a , b , w ;<br>a &#x3D; bian[j].x       ;           b &#x3D; bian[j].y    ;        w &#x3D; bian[j].z;<br>arr[b] &#x3D; min(arr[b], arr2[a] + w);            &#x2F;&#x2F;arr初始化时为系统最大值<br>}<br>}<br><br>if (arr[n] &gt; 0x3f3f3f3f &#x2F; 2)return -1;                &#x2F;&#x2F; 如果出现负权边 会减小arr[ n ] 的值 , 使用 max &#x2F; 2 去卡值<br><br>return arr[n];<br>}</p><p>int main() {</p><pre><code>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;for (int i = 0;  i &lt; m;  i++) &#123;int x, y, z;cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;bian[i] = &#123; x,y,z &#125;;&#125;int t = bf();if (t == -1) puts(&quot;impossible&quot;);else printf(&quot;%d\n&quot;, t);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing31</title>
      <link href="/2025/12/17/acwing31/"/>
      <url>/2025/12/17/acwing31/</url>
      
        <content type="html"><![CDATA[<p>拓扑排序 : 实现判断有无环 , 找到单向序列<br>int h[N], idx , e[N] , ne[N] , n ,  m ;<br>int p[N],    d[N]  入度;  </p><p>void add(int a, int b) {       &#x2F;&#x2F;头插法插入数据<br>e[idx] &#x3D; b;<br>ne[idx] &#x3D; h[a];<br>h[a] &#x3D; idx++;<br>}</p><p>bool topsort() {                &#x2F;&#x2F;拓扑函数<br>int hh &#x3D; 0, tt &#x3D; -1;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {            &#x2F;&#x2F;先全局遍历找无入权的点<br>if (!d[i]) {                <br>p[++tt] &#x3D; i;<br>}     <br>}<br>while (hh &lt;&#x3D; tt) {<br>int t &#x3D; p[hh++];  <br>for (int i &#x3D; h[t]; i !&#x3D; -1 ; i &#x3D; ne[i]) {       &#x2F;&#x2F;在入队的点中去找下一个标记点<br>int j &#x3D; e[i]; &#x2F;&#x2F;找到下一个点所对应的下标<br>d[j]--; &#x2F;&#x2F;将入权减减实现找点<br>if (!d[j]) {<br>p[++tt] &#x3D; j ;<br>}<br>}<br>}<br> &#x2F;*<br> {   while (hh &lt;&#x3D; tt) {<br>        int t &#x3D; p[hh++];  &#x2F;&#x2F; 出队<br>        &#x2F;&#x2F; 遍历 t 的所有出边<br>        for (int i &#x3D; h[t]; i !&#x3D; -1 ; i &#x3D; ne[i]) {<br>            int j &#x3D; e[i];  &#x2F;&#x2F; 邻接节点<br>            d[j]--;        &#x2F;&#x2F; 入度减1<br>            if (!d[j]) {   &#x2F;&#x2F; 如果入度为0<br>                p[++tt] &#x3D; j ;  &#x2F;&#x2F; 入队<br>            }<br>        }<br>    }<br>}<br>*&#x2F;<br>return tt &#x3D;&#x3D; n - 1;                             <br>}</p><p>int main() {<br>cin &gt;&gt; n &gt;&gt; m ; <br>memset(h, -1, sizeof(h));<br>while (m--) {<br>int a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>add(a, b);<br>d[b]++;<br>}</p><pre><code>if (topsort()) &#123;for (int i = 0 ; i &lt; n; i++) &#123;cout &lt;&lt; p[i] &lt;&lt; &#39; &#39;; &#125;&#125;else &#123;cout &lt;&lt; -1; &#125;return 0; </code></pre><p>}</p><p>类食物链问题 : 找所有路径<br>&#x2F;&#x2F;增加dp动态规划,实现找出所有路径<br>f[1]&#x3D;x1, f[2]&#x3D;x2, f[3]&#x3D;x3, f[4]&#x3D;x4, f[5]&#x3D; x5,  f[6]&#x3D;x6<br>通过叠加路径数 , 实现找到所有的路径数<br>const int N &#x3D; 5e5 + 17;<br>const int mod &#x3D; 80112002;<br>int n, m;<br>int h[N], e[N], ne[N], idx;<br>int q[N], d[N] , f[N ] , c[N]; </p><p>void add(int a, int b) {<br>e[idx] &#x3D; b;<br>ne[idx] &#x3D; h[a];<br>h[a] &#x3D; idx++;<br>}</p><p>void topsort() {<br>int hh &#x3D; 0, tt &#x3D; -1;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>if (!d[i]) {<br>q[++tt] &#x3D; i;<br>f[i] &#x3D; 1;<br>}<br>}<br>while (hh &lt;&#x3D; tt) {<br>int t &#x3D; q[hh++];<br>for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]) {<br>int j &#x3D; e[i];<br>f[j] &#x3D; (f[j] + f[t]) % mod;<br>d[j]--;<br>if (!d[j]) q[++tt] &#x3D; j;<br>}<br>}<br>int ans &#x3D; 0;<br>for (int i &#x3D; 0; i &lt;&#x3D; n; i++) {<br>if (!c[i]) {<br>ans &#x3D; (ans + f[i]) % mod;<br>}<br>}<br>cout &lt;&lt; ans &lt;&lt; endl;<br>}</p><p>signed main() {<br>memset(h, -1, sizeof h);<br><br>cin &gt;&gt; n &gt;&gt; m;<br><br>while (m--) {<br>int a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>add(a, b);<br>d[b]++;<br>c[a]++;<br>}<br>topsort();<br>return 0;<br>}</p><p>&#x2F;&#x2F;寻找最长路径 :    &#x2F;&#x2F;增加数组w 来记录权重 ;<br>const int N &#x3D; 1e5 + 17;<br>const int INF &#x3D; -0x3f3f3f3f;<br>int n , m ;<br>int e[N], ne[N], idx , h[N] , w[N];<br>int p[N], d[N], f[N]; </p><p>void add(int a, int b , int c ) {<br>e[idx] &#x3D; b;<br>w[idx] &#x3D; c;<br>ne[idx] &#x3D; h[a];<br>h[a] &#x3D; idx++;<br>}</p><p>bool topsort() {<br>int hh &#x3D; 0, tt &#x3D; -1;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>f[i] &#x3D; INF;<br>}<br>f[1] &#x3D; 0;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>if (!d[i]) {<br>p[++tt] &#x3D; i;<br>}<br>}<br>while (hh &lt;&#x3D; tt) {<br>int t &#x3D; p[hh++];<br>for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]) {<br>int j &#x3D; e[i];<br>if (f[t] &gt; INF) {<br>f[j] &#x3D; max(f[j], f[t] + w[i]);<br>}<br>d[j]--;<br>if (!d[j]) p[++tt] &#x3D; j;<br>}<br>}<br>return tt &#x3D;&#x3D; n - 1;<br>}</p><p>int main() {<br>memset(h, -1, sizeof(h));<br>cin &gt;&gt; n &gt;&gt; m;<br>while (m--) {<br>int a, b , c ;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c ;<br>add(a, b , c );<br>d[b]++;<br>}<br>if (topsort()) {<br>if (f[n] &gt; INF) {<br>cout &lt;&lt; f[n];<br>}<br>else {<br>cout &lt;&lt; -1;<br>}<br>}<br>else {<br>cout &lt;&lt; -1;<br>}<br>return 0;<br>}</p><p>找最短权重和的路径 :<br>int n;<br>int h[N], e[N], ne[N], idx;<br>int q[N], d[N] ,t[N] , f[N];</p><p>void add(int a , int b ) {<br>e[idx] &#x3D; b;<br>ne[idx] &#x3D; h[a];<br>h[a] &#x3D; idx++;<br>}</p><p>void  topsort() {<br>int hh &#x3D; 0, tt &#x3D; -1;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>if (!d[i]) {<br>q[++tt] &#x3D; i;<br>f[i] &#x3D; t[i];<br>}<br>}<br>while (hh &lt;&#x3D; tt) {<br>int s &#x3D; q[hh++];<br>for (int i &#x3D; h[s]; i !&#x3D; -1; i &#x3D; ne[i]) {<br>int j &#x3D; e[i]; <br>f[j] &#x3D; max(f[j] , f[s] + t[j] ) ;<br>d[j]--;<br>if (!d[j]) q[++tt] &#x3D; j;<br>}<br>}<br>int ans &#x3D; 0;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>ans &#x3D; max(ans, f[i]);<br>}<br>cout &lt;&lt; ans &lt;&lt; endl ;<br>}</p><p>signed main() {<br>memset(h, -1, sizeof h);<br>cin &gt;&gt; n;<br>int total &#x3D; n;<br>while (total--) {<br>int x;<br>cin &gt;&gt; x;<br>cin &gt;&gt; t[x];<br>int m;<br>while (cin &gt;&gt; m) {<br>if (m) {<br>add(x, m);<br>d[m]++;<br>}<br>else break;<br>}<br>}<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) f[i] &#x3D; t[i];<br>topsort();<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing30</title>
      <link href="/2025/12/16/acwing30/"/>
      <url>/2025/12/16/acwing30/</url>
      
        <content type="html"><![CDATA[<p>floyd 求多源汇最短路( 多源指任一点可以当作原点 )<br>路径分类  : 1 : 不经过 K 点( d[k, i , j ] &#x3D; d[k - 1 , i , j ] )<br>   2:  经过K点 ( d[k , i , j ] &#x3D; d[k -1 , i , k]  + d[k - 1 , k , j])<br>const int N &#x3D; 210, INF &#x3D; 1e9;</p><p>int n, m, k;<br>int d[N][N];</p><p>void floyd()<br>{<br>    for(int k &#x3D; 1; k &lt;&#x3D; n; k ++)<br>        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);<br>}</p><p>int main()<br>{<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)<br>       for(int j &#x3D; 1; j &lt;&#x3D; n; j ++)<br>           if(i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;<br>           else d[i][j] &#x3D; INF;<br>    while(m --)<br>    {<br>        int a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        d[a][b] &#x3D; min(d[a][b], c);<br>    }</p><pre><code>floyd();while(k --)&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    if(d[a][b] &gt; INF / 2) puts(&quot;impossible&quot;);    else cout &lt;&lt; d[a][b] &lt;&lt; endl;    &#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing29</title>
      <link href="/2025/12/15/acwing29/"/>
      <url>/2025/12/15/acwing29/</url>
      
        <content type="html"><![CDATA[<p>找数状图 : 先序是中左右 , 中序是左中右 , 后序时左右中<br>特殊技巧：后序的最后一个是根节点<br>&#x2F;&#x2F;通过中序和后序找出先序<br>map&lt;char, int&gt; arr;<br>string a, b; </p><p>void dfs(int l1 , int r1 , int l2 , int r2) {<br>if (l1 &gt; r1 ) return;<br>char jie &#x3D; b[r2];<br>cout &lt;&lt; jie;<br>int pos &#x3D; arr[jie];<br>int l_size &#x3D; pos - l1;                  &#x2F;&#x2F;找出中序分界点<br>dfs(l1, pos - 1, l2, l2 + l_size - 1);    &#x2F;&#x2F;在中序和后序中分别找出左子树<br>dfs(pos + 1, r1, l2 + l_size, r2 - 1);&#x2F;&#x2F;在中序和后序中分别找出右子树<br>}</p><p>int main() {<br>cin &gt;&gt; a &gt;&gt; b;<br>int n &#x3D; a.length();<br>for (int i &#x3D; 0; i &lt; a.length(); i++) {<br>arr[a[i]] &#x3D; i;<br>}<br>dfs(0, n-1, 0, n-1);<br>return 0;<br>}</p><p>BFS算法:( BFS 中不会重复调用bfs函数 )<br>线性  :<br>步骤1：初始化　: </p><p>queue<int> q;<br>q.push(start);<br>visited[start] &#x3D; true;        &#x2F;&#x2F;记录位置是否取过<br>dist[start] &#x3D; 0;   &#x2F;&#x2F;记录到达终点的步数</p><p>步骤二  : 队列循环 : </p><p>while (!q.empty()) {<br>    int current &#x3D; q.front(); q.pop();</p><p>步骤三 : 检查是否为终点：</p><p>if (current &#x3D;&#x3D; target) return dist[current];    &#x2F;&#x2F; dist[现在节点]  一步一步+1 利用数组实现前和得到步数</p><p>步骤四：生成下一层节点 :</p><p>(每个可能的下一步位置 next)<br>        if (位置有效 &amp;&amp; !visited[next]) {<br>            visited[next] &#x3D; true;<br>            dist[next] &#x3D; dist[current] + 1;<br>            q.push(next);</p><p>步骤五  : 无解返回 :<br>return - 1 ; </p><p>非线性:<br>步骤一 : 定义状态和初始化 :<br>const int N &#x3D; 110;<br>char grid[N][N];<br>bool visited[N][N];<br>int dist[N][N];<br>int n, m, sx, sy, tx, ty;      &#x2F;&#x2F;网格数 , 起点横 , 起点竖 , 终点横 , 终点竖 </p><p>&#x2F;&#x2F; 方向数组：上、右、下、左<br>int dx[4] &#x3D; {-1, 0, 1, 0};<br>int dy[4] &#x3D; {0, 1, 0, -1};</p><p> queue&lt;pair&lt;int, int&gt;&gt; q;  &#x2F;&#x2F; 使用 pair 存储坐标<br> q.push({sx, sy});<br> visited[sx][sy] &#x3D; true;<br> dist[sx][sy] &#x3D; 0;</p><p>步骤二 : 队列循环 :<br>while (!q.empty()) { &#x2F;&#x2F; 获取队首元素<br>int x &#x3D; q.front().first, y &#x3D; q.front().second;<br>q.pop();</p><p>步骤三 ：检查终点<br>if (x &#x3D;&#x3D; tx &amp;&amp; y &#x3D;&#x3D; ty) {<br>            return dist[x][y];<br>}<br><br>步骤四  : 生成下一层节点  :<br>for (int i &#x3D; 0; i &lt; 4; i++) {<br>            int nx &#x3D; x + dx[i];<br>            int ny &#x3D; y + dy[i];<br>            if (nx &gt;&#x3D; 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;&#x3D; 0 &amp;&amp; ny &lt; m &amp;&amp;<br>                grid[nx][ny] !&#x3D; &#39;#&#39; &amp;&amp; !visited[nx][ny]) {<br>                visited[nx][ny] &#x3D; true;<br>                dist[nx][ny] &#x3D; dist[x][y] + 1;<br>                q.push({nx, ny});  &#x2F;&#x2F; 直接构造 pair<br><br>步骤五 : 无解返回:<br>return -1 ;</p><p>一块记录连通块数目的板子：<br>通过ｄｆｓ算法将八向位值的目标块标记<br>void dfs(int x, int y) {<br>    visit[x][y] &#x3D; true;</p><pre><code>for (int i = 0; i &lt; 8; i++) &#123;    int nx = x + dx[i];    int ny = y + dy[i];    if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp;        !visit[nx][ny] &amp;&amp; g[nx][ny] == &#39;W&#39;) &#123;        dfs(nx, ny);    &#125;&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;实现查找所有连通块<br>&#x2F;&#x2F; 遍历整个矩阵<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>    for (int j &#x3D; 0; j &lt; m; j++) {<br>        if (g[i][j]  &#x3D;&#x3D; &#39;W&#39; &amp;&amp; !visit[i][j]) {<br>            count++;<br>            dfs(i, j);<br>        }<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing28</title>
      <link href="/2025/12/14/acwing28/"/>
      <url>/2025/12/14/acwing28/</url>
      
        <content type="html"><![CDATA[<p>板子 :<br>#include<iostream><br>using namespace std;<br>const int N &#x3D; 1e3 + 17;<br>int n;<br>int path[N];<br>bool std[N]; </p><p>void dfs(int x) {<br>if (x &#x3D;&#x3D; n) {<br>for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;<br>cout &lt;&lt; &#39;\n&#39;;<br>return;<br>}<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>if (!std[i]) {<br>path[x] &#x3D; i;<br>std[i] &#x3D; true;                对放入数据标记<br>dfs(x + 1);实现找全<br>std[i] &#x3D; false;<br>}<br>}<br>}</p><p>int main(){<br>cin &gt;&gt; n;<br>dfs(0);<br>return 0;<br>}<br>&#x2F;&#x2F;DFS算法:      &#x2F;&#x2F;实现找路径总数   ( 关键就是回溯之前要恢复原状 )<br>int n;<br>int arr[N];<br>void dfs(int x, int pos) {   &#x2F;&#x2F;pos : 表示二进制位<br>    if (x &#x3D;&#x3D; n) {                 &#x2F;&#x2F;递归返回n 个数时;<br>        for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; arr[i];<br>        cout &lt;&lt; &#39;\n&#39;;<br>        return;<br>    }<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        if (!(pos &gt;&gt; i &amp; 1)) {               通过判断该二进制位上是否为0, 判断是否被使用<br>            arr[x] &#x3D; i + 1; 下标从0开始用+ 1;    &#x2F;&#x2F;在arr数组中下标为 x 的位置存入当前的未标记数<br>            dfs(x + 1, pos + (1 &lt;&lt; i));<br>        }<br>    }<br>}<br>int main() {<br>    cin &gt;&gt; n;<br>    dfs(0, 0);<br>    return 0;<br>}</p><p>传入数据以 1 为下标传入<br>void dfs(int x, int p) {<br>if (x &#x3D;&#x3D; n + 1 ) {<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; arr[i];<br>cout &lt;&lt; endl;<br>return;<br>}<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>if (!(p &gt;&gt; i &amp; 1)) {<br>arr[x] &#x3D; i;<br>dfs(x + 1, p + (1 &lt;&lt; i));<br>}<br>}<br>}</p><p>int main() {<br>cin &gt;&gt; n;<br>dfs(1, 0);<br>return 0 ;<br>}<br>经典 皇后问题(下的棋要在盘上不同行列斜行) :<br>B站版本:<br>#include<iostream><br>using namespace std;<br>const int N &#x3D; 10;<br>int n, ans;<br>int pos[N], c[N], p[N  *2 ], q[N * 2 ]; </p><p>void println() {<br>if (ans &lt;&#x3D; 3) {     &#x2F;&#x2F;题目要求输出前3组解<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; pos[i]&lt;&lt; &#39; &#39;;<br>cout &lt;&lt; endl;<br>}<br>return;<br>}</p><p>void dfs(int i) {<br>if (i &gt; n) {<br>ans++;<br>println();<br>return;<br>}<br>for (int j &#x3D; 1; j &lt;&#x3D; n; j++) {<br>if (c[j] || p[i + j] || q[i - j + n]) continue;            &#x2F;&#x2F;遍历 , 判断 , 传值 ,标记,  向下递归 , 恢复现场  ( 难点: 标记位置 , 传值内容 )<br>pos[i] &#x3D; j;<br>c[j] &#x3D; p[i + j] &#x3D; q[i - j + n] &#x3D; 1;     &#x2F;&#x2F;对位置标记<br>dfs(i + 1);<br>c[j] &#x3D; p[i + j] &#x3D; q[i - j + n] &#x3D; 0;     &#x2F;&#x2F;解除标记<br>}<br>}<br>int main() {<br>cin &gt;&gt; n;<br>dfs(1);<br>cout &lt;&lt; ans &lt;&lt; endl;<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing27</title>
      <link href="/2025/12/12/acwing27/"/>
      <url>/2025/12/12/acwing27/</url>
      
        <content type="html"><![CDATA[<p>模拟散序列二:<br>&#x2F;&#x2F;开放寻址法<br>&#x2F;&#x2F;蹲坑函数find()<br>int find(int x) {<br>int t &#x3D; (x % N + N) % N;<br>while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x) {<br>t++;<br>if (t &#x3D;&#x3D; N) t &#x3D; 0;<br>}<br>return t;<br>}</p><p>int main() {<br>memset(h, 0x3f, sizeof(h)); </p><pre><code>int n; cin &gt;&gt; n; while (n--) &#123;string s;int x; cin &gt;&gt; s &gt;&gt; x; if (s == &quot;I&quot;) h[find(x)] = x;else &#123;if (h[find(x)] == null) cout &lt;&lt; &quot;No\n&quot;;else cout &lt;&lt; &quot;Yes\n&quot;; &#125;&#125;return 0; </code></pre><p>}</p><p>字符串哈希:<br>1.将字母映射为数字;( 尽量不要映射到0 )( AA &#x3D; 0 , A  &#x3D; 0 ; )<br>2.只需要映射到0 ~ Q : 不存在哈希冲突<br>3.一般取值时 将P 取为131 或者 1331 , 将Q取为2的64次方   ( 经验值 : 99.99% 不会出错 )<br>计算前缀和实现找到字符哈希值:<br>h[i] &#x3D; h[i - 1] * p + s[i]  , h[0] &#x3D; 0 ;<br>h[l , r] &#x3D; h[r] - h[l - r ] * p^(r - l +1 ) ;<br>#include<iostream><br>#include&lt;string.h&gt;<br>using namespace std;<br>typedef unsigned long long ULL;<br>int  n, m;<br>string s;<br>const int P &#x3D; 1331;<br>const int N &#x3D; 1e5 + 10;<br>&#x2F;&#x2F;预处理p[i] &#x3D; P ^ i, h[i] &#x3D; s[1 ~ i ]的 hash 值;<br>ULL p[N], h[N]; </p><p>&#x2F;&#x2F;预处理整个字符串(求前缀和)<br>void init() {<br>p[0] &#x3D; 1; h[0] &#x3D; 0;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>p[i] &#x3D; p[i - 1] * P;<br>h[i] &#x3D; h[i - 1] * P + s[i -1];<br>}<br>}</p><p>ULL get(int l, int r) {       &#x2F;&#x2F;限制上限为2的64次方 , 一旦超出会出现整数溢出,自动实现mod 2 ^ 64 的功能<br>return  h[r] - h[l - 1] * p[r - l + 1];<br>}</p><p>bool substr(int l1, int r1, int l2, int r2) {<br>if (get(l1, r1) &#x3D;&#x3D; get(l2, r2)) return true;<br>else return false;<br>}<br>int main() {<br>cin &gt;&gt; n &gt;&gt; m;<br>cin &gt;&gt; s;<br><br>init(); &#x2F;&#x2F;初始化前缀和和各个子字符的哈希值<br><br>while (m--) {<br>int l1, r1, l2, r2;<br>cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;<br>if (substr(l1, r1, l2, r2)) cout &lt;&lt; &quot;Yes\n&quot;;<br>else cout &lt;&lt; &quot;No\n&quot;;<br>}</p><pre><code>return 0; </code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing26</title>
      <link href="/2025/12/11/acwing26/"/>
      <url>/2025/12/11/acwing26/</url>
      
        <content type="html"><![CDATA[<p>栈的使用:<br>ph[] : 实现找出第K个插入数的下标( 指针有单向性 ,索引出需要使用另外数组)<br>hp[] : 实现找出下标为K的数的插入序号<br>hp[i] &#x3D; j ; ph[j] &#x3D; i ; </p><p>&#x2F;&#x2F;实现交换下标和插入顺序的交换<br>void heap_swap(int a, int b)<br>{<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>}</p><p>&#x2F;&#x2F;实现下沉操作<br>void down(int u)<br>{<br>    int t &#x3D; u;<br>    if (u * 2 &lt;&#x3D; cnt &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;<br>    if (u * 2 + 1 &lt;&#x3D; cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;<br>    if (u !&#x3D; t)<br>    {<br>        heap_swap(u, t);<br>        down(t);<br>    }<br>}</p><p>&#x2F;&#x2F;实现上浮操作<br>void up(int u)<br>{<br>    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])<br>    {<br>        heap_swap(u, u &#x2F; 2);<br>        u &gt;&gt;&#x3D; 1;<br>    }<br>}</p><p>int main()<br>{<br>    int n, m &#x3D; 0;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    while (n -- )<br>    {<br>        char op[5];<br>        int k, x;<br>        scanf(&quot;%s&quot;, op);<br>        if (!strcmp(op, &quot;I&quot;))<br>        {<br>            scanf(&quot;%d&quot;, &amp;x);<br>            cnt ++ ;<br>            m ++ ;<br>            ph[m] &#x3D; cnt, hp[cnt] &#x3D; m;<br>            h[cnt] &#x3D; x;<br>            up(cnt);<br>        }<br>        else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\n&quot;, h[1]);<br>        else if (!strcmp(op, &quot;DM&quot;))<br>        {<br>            heap_swap(1, cnt);<br>            cnt -- ;<br>            down(1);<br>        }<br>        else if (!strcmp(op, &quot;D&quot;))<br>        {<br>            scanf(&quot;%d&quot;, &amp;k);<br>            k &#x3D; ph[k];<br>            heap_swap(k, cnt);<br>            cnt -- ;<br>            up(k);<br>            down(k);<br>        }<br>        else<br>        {<br>            scanf(&quot;%d%d&quot;, &amp;k, &amp;x);<br>            k &#x3D; ph[k];<br>            h[k] &#x3D; x;<br>            up(k);<br>            down(k);<br>        }<br>    }</p><pre><code>return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;模拟散序列<br>一:拉链法(数组模拟链表实现)<br>#include<iostream><br>#include<cstring><br>using namespace std;<br>const int N &#x3D; 1e5 + 3;<br>int h[N], e[N], ne[N], idx; </p><p>&#x2F;&#x2F;实现哈希找数<br>int hash_(int x) {<br>return (x % N + N) % N;<br>}</p><p>&#x2F;&#x2F;实现存储数值<br>void insert(int x) {<br>int  k &#x3D; hash_(x);<br>e[idx] &#x3D; x;<br>ne[idx] &#x3D; h[k];<br>h[k] &#x3D; idx++;<br>}</p><p>&#x2F;&#x2F;实现查找功能<br>bool find(int x) {<br>int k &#x3D; hash_(x);<br>for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i]) {<br>if (e[i] &#x3D;&#x3D; x) return true;<br>}<br>return false;<br>}</p><p>&#x2F;&#x2F;实现删除功能<br>void remove(int x) {<br>int k &#x3D; hash_(x);<br>int head &#x3D; -1;<br>for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i]) {<br>if (e[i] &#x3D;&#x3D; x) {<br>if (head &#x3D;&#x3D; -1) {   &#x2F;&#x2F; i是头节点 ;<br>h[k] &#x3D; ne[i];    &#x2F;&#x2F;头指针直接向下一个☞<br>}<br>else {    &#x2F;&#x2F;i是中间节点或尾节点情况<br>ne[head] &#x3D; ne[i];   &#x2F;&#x2F;跳过 i , 连接 i 的下一个<br>}<br>return;<br>}<br>head &#x3D; i;     &#x2F;&#x2F;更新head为当前节点,成为下一个的前一个节点<br>}<br>}</p><p>int main() {<br>memset(h, -1, sizeof(h));<br>int n;<br>cin &gt;&gt; n;<br><br>while (n--) {<br>string s;<br>int x;<br>cin &gt;&gt; s&gt;&gt; x;<br>if (s &#x3D;&#x3D; &quot;I&quot;) insert(x);<br>else if (s &#x3D;&#x3D; &quot;D&quot;) {<br>remove(x);<br>}<br>else {<br>if (find(x)) cout &lt;&lt; &quot;Yes\n&quot;;<br>else cout &lt;&lt; &quot;No\n&quot;;<br>}<br>}<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing25</title>
      <link href="/2025/12/10/acwing25/"/>
      <url>/2025/12/10/acwing25/</url>
      
        <content type="html"><![CDATA[<p>实现最小堆<br>上浮操作:<br>void up(int x) {<br>    while (x &#x2F; 2 &amp;&amp; h[x] &lt; h[x &#x2F; 2]) {<br>        swap(h[x], h[x &#x2F; 2]);<br>        x &#x2F;&#x3D; 2;<br>    }<br>}</p><p>下沉操作:<br>void down(int x) {<br>    int t &#x3D; x;<br>    if (x * 2 &lt;&#x3D; cnt &amp;&amp; h[t] &gt; h[2 * x])  t &#x3D; 2 * x;<br>    if (x * 2 + 1 &lt;&#x3D; cnt &amp;&amp; h[t] &gt; h[2 * x + 1]) t &#x3D; 2 * x + 1;<br>    if (t !&#x3D; x) {<br>        swap(h[x], h[t]);<br>        down(t);<br>    }<br>}</p><p>void insert(int val) {      &#x2F;&#x2F;插入元素<br>    h[++cnt] &#x3D; val;<br>    up(cnt);<br>}</p><p>&#x2F;&#x2F; 获取堆顶（最小值）<br>int get_min() {<br>    return h[1];<br>}</p><p>&#x2F;&#x2F; 删除堆顶<br>void remove_min() {<br>    h[1] &#x3D; h[cnt--];<br>    down(1);<br>}<br>const int N &#x3D; 1e5 + 17;<br>int arr[N];<br>int cnt;<br>void huan(int x) {<br>int p &#x3D; x;<br>if (2* x &lt;&#x3D; cnt &amp;&amp; arr[x] &gt; arr[x*2]) p &#x3D; x * 2;<br>if (2 * x + 1 &lt;&#x3D; cnt &amp;&amp; arr[x] &gt; arr[x * 2 + 1]) p &#x3D; x * 2 + 1;<br>if (p !&#x3D; x) {<br>swap(arr[p], arr[x]);<br>huan(p);<br>}<br>}<br>int main() {<br>int n;<br>cin &gt;&gt; n;<br>cnt &#x3D; n;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; arr[i];<br>for (int i &#x3D; n &#x2F; 2; i ; i--) huan(i);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>cout &lt;&lt; arr[1]&lt;&lt;&#39; &#39;;<br>arr[1] &#x3D; arr[cnt--];<br>huan(1);<br>}<br>return 0;<br>}</p><p>&#x2F;&#x2F;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acking24</title>
      <link href="/2025/12/09/acwing24/"/>
      <url>/2025/12/09/acwing24/</url>
      
        <content type="html"><![CDATA[<p>并查集(夹带数据间关系)   可以计算实现最小环问题  &#x2F;&#x2F; res 计算假话数 ,  t &#x3D; 1 同级关系<br>int p[N], d[N];<br>int n, m;</p><p>int find(int x) {<br>    if (p[x] !&#x3D; x) {<br>        int t &#x3D; find(p[x]);<br>        d[x] +&#x3D; d[p[x]];<br>        p[x] &#x3D; t;<br>    }<br>    return p[x];<br>}</p><p>int main() {<br>    cin &gt;&gt; n &gt;&gt; m;<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) p[i] &#x3D; i;<br>    int res &#x3D; 0;<br>    while (m--) {<br>        int t, x, y;<br>        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;<br>        if (x &gt; n || y &gt; n) res++;<br>        else {<br>            int px &#x3D; find(x);<br>            int py &#x3D; find(y);<br>            if (t &#x3D;&#x3D; 1) {<br>                if (px &#x3D;&#x3D; py &amp;&amp; (d[x] - d[y]) % 3) res++;<br>                else if (px !&#x3D; py) {<br>                    p[px] &#x3D; py;<br>                    d[px] &#x3D; d[y] - d[x];  &#x2F;&#x2F;判断同类: x , y 需要在同一层 , x , y 到跟py 的距离需要相等 ;<br>                }<br>            }<br>            else {<br>                if (px &#x3D;&#x3D; py &amp;&amp; (d[x] - d[y] - 1) % 3) res++;<br>                else if (px !&#x3D; py) {<br>                    p[px] &#x3D; py;<br>                    d[px] &#x3D; d[y] - d[x] + 1;  &#x2F;&#x2F;判断被吃问题: x 应该在 y  的下一层 , x 到跟py 的距离需要比y 到py的距离 +1  ;<br>                }<br>            }<br>        }<br>    }<br>    cout &lt;&lt; res;<br>    return 0;<br>}</p><p>解决最小环问题(d[]记录x到祖节点的距离) ;<br>int find(int x) {<br>    if (parent[x] !&#x3D; x) {<br>        int root &#x3D; find(parent[x]);<br>        dist[x] +&#x3D; dist[parent[x]];<br>        parent[x] &#x3D; root;<br>    }<br>    return parent[x];<br>}<br>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        parent[i] &#x3D; i;<br>        dist[i] &#x3D; 0;<br>    }<br>    int ans &#x3D; n + 1;<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        int t;<br>        cin &gt;&gt; t;<br>        find(i);<br>        find(t);<br>        int root_i &#x3D; find(i);<br>        int root_t &#x3D; find(t);<br>        if (root_i !&#x3D; root_t) {<br>            parent[root_i] &#x3D; root_t;<br>            dist[root_i] &#x3D; 1 + dist[t] - dist[i];   (d[px] + d[x] &#x3D; d[y] +  1] )  &#x2F;&#x2F;数学推导得出x根节点到祖节点的长度<br>        }<br>        else {<br>            ans &#x3D; min(ans, abs(dist[i] - dist[t]) + 1);<br>        }<br>    }<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acking23</title>
      <link href="/2025/12/07/acwing23/"/>
      <url>/2025/12/07/acwing23/</url>
      
        <content type="html"><![CDATA[<p>tree:<br>#include<iostream><br>using namespace std;<br>const int N &#x3D; 1e4 + 17 ;<br>int son[N][26], cnt[N], idx;<br>void insert(string s ) {<br>int p &#x3D; 0;<br>for (int i &#x3D; 0; s[i]; i++) {<br>int u &#x3D; s[i] - &#39;a&#39;;<br>if (!son[p][u]) son[p][u] &#x3D; ++idx;<br>p &#x3D; son[p][u];<br>}<br>cnt[p]++;<br>}<br>int query(string s) {<br>int p &#x3D; 0;<br>for (int i &#x3D; 0; s[i]; i++) {<br>int  u &#x3D; s[i] - &#39;a&#39;;<br>if (!son[p][u]) return 0;<br>p &#x3D; son[p][u];<br>}<br>return cnt[p];<br>}<br>int main() {<br>int n;<br>cin &gt;&gt; n;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>string s1;<br>string s2;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br>if (s1 &#x3D;&#x3D; &quot;I&quot;) insert(s2);<br>else cout &lt;&lt; query(s2);<br>}<br>return 0;<br>}<br>&#x2F;&#x2F;并查集 (包含查询a值所在的集合的大小)<br>#include<iostream><br>using namespace std;<br>const int N &#x3D; 1e7 + 17;<br>int p[N] , size1[N];<br>int find(int x) {<br>if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);<br>return p[x];<br>}<br>int main() {<br>int n, m ;<br>cin &gt;&gt; n&gt;&gt; m ;<br>for (int i &#x3D; 0; i &lt; n ; i++) {<br>p[i] &#x3D; i;<br>size1[i] &#x3D; 1;<br>}<br>while (m--) {<br>string s;<br>if (s &#x3D;&#x3D; &quot;Q&quot;) {<br>int a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>size1[b] +&#x3D; size1[a];      &#x2F;&#x2F;注意特判情况<br>p[find(a)] &#x3D; find(b);<br>}<br>else if (s &#x3D;&#x3D; &quot;P&quot;) {<br>int a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>if (find(a) &#x3D;&#x3D; find(b)) cout &lt;&lt; &quot;YES\n&quot;;<br>else cout &lt;&lt; &quot;NO\n&quot;;<br>}<br>else {<br>int a;<br>cin &gt;&gt; a;<br>cout &lt;&lt; size1[find(a)];<br>}<br>}<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing22</title>
      <link href="/2025/12/05/acwing22/"/>
      <url>/2025/12/05/acwing22/</url>
      
        <content type="html"><![CDATA[<p>练习单调栈code :<br>#include<iostream><br>#include<vector><br>#include<stack><br>#define int long long<br>using namespace std;<br>stack<int> brr;<br>signed main() {<br>ios::sync_with_stdio(false);<br>cin.tie(nullptr);<br>int n;<br>cin &gt;&gt; n;<br>vector<int> arr(n + 1);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>cin &gt;&gt; arr[i];<br>}<br>vector<int> result(n + 1, 0);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>while (!brr.empty() &amp;&amp; arr[brr.top()] &lt; arr[i]) {<br>result[brr.top()] &#x3D; i;<br>brr.pop();<br>}<br>brr.push(i);<br>}<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>cout &lt;&lt; result[i] &lt;&lt; &#39; &#39;;<br>}<br>return 0;<br>}</p><p>#并查集<br>#include<iostream><br>#include<vector><br>using namespace std;<br>const int N &#x3D; 2e5+17;<br>vector<int> p(N + 1);<br>int find(int x) {<br>if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);<br>return p[x];<br>}<br>int main() {<br>    ios::sync_with_stdio(false) ;<br>    cin.tie(nullptr) ;<br>int n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>p[i] &#x3D; i;<br>}<br>while (m--) {<br>int x;<br>int x1, x2;<br>cin &gt;&gt; x;<br>cin &gt;&gt; x1 &gt;&gt; x2;<br>if (x &#x3D;&#x3D; 1) {<br>p[find(x1)] &#x3D; find(x2);            &#x2F;&#x2F;连接的都是祖宗节点,不要连错了<br>}<br>if (x &#x3D;&#x3D; 2)  find(x1) &#x3D;&#x3D; find(x2) ? cout&lt;&lt;&quot;Y\n&quot; : cout&lt;&lt;&quot;N\n&quot;;<br>}<br>return 0;<br>}</p><p>基础模板<br>include<iostream><br>include<vector><br>using namespace std;<br>const int N &#x3D; 1e4;<br>vector<int> q(N);<br>int find(int x) {<br>if (q[x] !&#x3D; x) q[x] &#x3D; find(q[x]);<br>return q[x];<br>}<br>int main() {<br>int  n, m, p;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>q[i] &#x3D; i;<br>}<br>while (m--) {<br>int x1 , x2 ;<br>cin &gt;&gt; x1 &gt;&gt; x2;<br>q[find(x1)] &#x3D; find(x2);<br>}<br>while (p--) {<br>int y1, y2;<br>cin &gt;&gt; y1 &gt;&gt; y2;<br>find(y1) &#x3D;&#x3D; find(y2) ? cout &lt;&lt; &quot;Yes\n&quot; : cout &lt;&lt; &quot;No\n&quot;;<br>}<br>return 0;<br>}</p><p>KMP算法:<br>ne[1] &#x3D; 0;<br>for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i++) {<br>while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];<br>if (p[i] &#x3D;&#x3D; p[j + 1]) j++;<br>ne[i] &#x3D; j;<br>}                                       &#x2F;&#x2F;先对子串使用一次.才能实现查找</p><p>for (int i &#x3D; 1; j &#x3D; 0; i &lt;&#x3D; m; i++) {<br>while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];<br>if (s[i] &#x3D;&#x3D; p[j + 1]) j++;<br>if (j &#x3D;&#x3D; n) cout &lt;&lt; i - n + 1;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/12/04/acwing21/"/>
      <url>/2025/12/04/acwing21/</url>
      
        <content type="html"><![CDATA[<p>#修行算法的第二十一天(未传档)</p><hr><h2 id="title-ackwing21date-2025-12-04-20-14-52tags"><a href="#title-ackwing21date-2025-12-04-20-14-52tags" class="headerlink" title="title: ackwing21date: 2025-12-04 20:14:52tags:"></a>title: ackwing21<br>date: 2025-12-04 20:14:52<br>tags:</h2><p>单调栈(递减或者递增)  &#x2F;&#x2F;brr存储原始数,arr是栈存储下标<br>#include<iostream><br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>while (!arr.empty() &amp;&amp; brr[arr.top()] &gt; brr[i]) {      &#x2F;&#x2F;arr.top() 返回目前左侧第一个大于数<br>对不同题目要求存储进外部数组result ;<br>arr.pop();<br>}<br>arr.push(i);<br>}<br>&#x2F;&#x2F;从左往右但能实现找右侧第一个最大数<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        &#x2F;&#x2F; 当前元素arr[i]比栈顶大，为栈顶元素找到答案<br>        while (!brr.empty() &amp;&amp; arr[brr.top()] &lt; arr[i]) {<br>            result[brr.top()] &#x3D; i;  &#x2F;&#x2F; 栈顶元素的答案是i<br>            brr.pop();<br>        }<br>        brr.push(i);<br>    }<br>&#x2F;&#x2F;实现从右往左<br>for (int i &#x3D; n; i &gt; 0 ; i--) {<br>while (!arr.empty() &amp;&amp; brr[arr.top()] &gt; brr[i]) {   &#x2F;&#x2F;arr.top() 返回目前右侧第一个大于数<br>对不同题目要求存储进外部数组result ;<br>arr.pop();<br>}<br>arr.push(i);<br>}<br>&#x2F;&#x2F;从右往左但能实现找左侧第一个最大数<br>for (int i &#x3D; n; i &gt; 0 ; i--) {<br>        &#x2F;&#x2F; 当前元素arr[i]比栈顶大，为栈顶元素找到答案<br>        while (!brr.empty() &amp;&amp; arr[brr.top()] &lt; arr[i]) {<br>            result[brr.top()] &#x3D; i;  &#x2F;&#x2F; 栈顶元素的答案是i<br>            brr.pop();<br>        }<br>        brr.push(i);<br>    }<br>&#x2F;&#x2F;单调队列(滑动窗口)<br>#include<iostream><br>int k , n ;<br>vector<int> brr;<br>deque<int> arr;<br>vectot<int> dd_lie() {<br>vector<int> result;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>if (!arr.empty() &amp;&amp; arr.front() &lt; i - k + 1) {<br>arr.pop_front();<br>}<br>if (!arr.empty() &amp;&amp; brr[arr.end()] &gt;&#x3D; x)  {                &#x2F;&#x2F;实现找最大最小时的符号改一下就行哈<br>arr.pop_back();<br>}<br>arr.push_back(i);<br>if (i &gt; k - 1) result.push_back(brr[arr.back()]);<br>}<br>return result;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing20</title>
      <link href="/2025/12/03/acwing20/"/>
      <url>/2025/12/03/acwing20/</url>
      
        <content type="html"><![CDATA[<p>汉诺塔函数实现<br>void hanni(n , char a , char b , char c ){<br>if(n &#x3D;&#x3D; 1 ) {<br>cout&lt;&lt;a&lt;&lt;&quot; -&gt;&quot;&lt;&lt;b &lt;&lt;endl;<br>return ;<br>}<br>hanni(n - 1,  a , c , b ) ;<br>cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;<br>hanni(n -1 , c , b , a ) ;<br>return ;<br>}</p><p>实现单链表<br>#include<iostream><br>#include<cstdlib><br>using namespace std;<br>typedef struct node {      &#x2F;&#x2F;创建节点(里面是数据和下一节点的位置)<br>int data;<br>struct node* next;<br>};<br>typedef struct {               &#x2F;&#x2F;创建整个链表(里面是头 , 尾节点和链表内的数据多少)<br>node* head;<br>node* end;<br>int size;<br>} lian;<br>node* add_arr (int x) {<br>node* newnode &#x3D; (node*)malloc(sizeof(node));  &#x2F;&#x2F;malloc需要头文件cstdlib<br>newnode-&gt;data &#x3D; x;<br>newnode-&gt;next &#x3D; NULL;<br>return newnode;<br>}<br>void init(lian* arr) {<br>arr-&gt;head &#x3D; NULL;<br>arr-&gt;end &#x3D; NULL;<br>arr-&gt;size &#x3D; 0;<br>}<br>void add_lian1(int x ,lian <em>arr ) {      &#x2F;&#x2F;头插法<br>node</em> newcode &#x3D; add_arr(x);<br>if (newcode &#x3D;&#x3D; NULL) return;<br>if (arr-&gt;size &#x3D;&#x3D; 0) {<br>arr-&gt;head &#x3D; newcode;<br>arr-&gt;end &#x3D; newcode;<br>}<br>else {<br>newcode-&gt;next &#x3D; arr-&gt;head;<br>arr-&gt;head &#x3D; newcode;<br>}<br>arr-&gt;size++;<br>}<br>void add_lian2(int x, lian* arr) {  &#x2F;&#x2F;尾插法<br>node* newcode &#x3D; add_arr(x);<br>if (newcode &#x3D;&#x3D; NULL) return;<br>if (arr-&gt;size &#x3D;&#x3D; 0) {<br>arr-&gt;head &#x3D; newcode;<br>arr-&gt;end &#x3D; newcode;<br>}<br>else {<br>arr-&gt;end -&gt; next &#x3D;  newcode;<br>arr-&gt;end &#x3D; newcode;<br>}<br>arr-&gt;size++;<br>}<br>node* find_node(lian* arr, int x) {<br>node* k &#x3D; arr-&gt;head;<br>while (k !&#x3D; NULL) {<br>if (k -&gt; d ata &#x3D;&#x3D; x) {<br>return k;<br>}<br>k &#x3D; k-&gt;next;<br>}<br>return NULL;<br>}<br>void delete_head(lian* arr) {<br>if (arr-&gt;size &#x3D;&#x3D; 0) {<br>return;<br>}</p><pre><code>node* temp = arr-&gt;head;arr-&gt;head = arr-&gt;head-&gt;next;if (arr-&gt;size == 1) &#123;  arr-&gt;end = NULL;&#125;free(temp);arr-&gt;size--;</code></pre><p>}<br>void display(lian* arr) {<br>node* chu &#x3D; arr-&gt;head;<br>while (chu !&#x3D; NULL) {<br>cout &lt;&lt; chu-&gt;data ;<br>chu &#x3D; chu-&gt;next;<br>}<br>cout &lt;&lt; arr-&gt;size;<br>}<br>int main() {<br>lian arr;<br>init(&amp;arr);<br>return 0;<br>}</p><p>&#x2F;&#x2F;双链表实现<br>#include<iostream><br>#include<cstdlib><br>using namespace std;</p><p>&#x2F;&#x2F; 双向链表节点结构<br>typedef struct node {<br>    int data;<br>    struct node* prev;  &#x2F;&#x2F; 前驱指针（应该是prev，不是l）<br>    struct node* next;  &#x2F;&#x2F; 后继指针（应该是next）<br>} node;</p><p>&#x2F;&#x2F; 双向链表结构<br>typedef struct list {<br>    int size;<br>    node* head;<br>    node* end;<br>} lian;</p><p>&#x2F;&#x2F; 创建新节点<br>node* create_node(int x) {<br>    node* newnode &#x3D; (node*)malloc(sizeof(node));<br>    if (newnode &#x3D;&#x3D; NULL) {<br>        return NULL;<br>    }<br>    newnode-&gt;data &#x3D; x;<br>    newnode-&gt;prev &#x3D; NULL;<br>    newnode-&gt;next &#x3D; NULL;<br>    return newnode;<br>}</p><p>&#x2F;&#x2F; 初始化链表<br>void init(lian* arr) {<br>    arr-&gt;head &#x3D; NULL;<br>    arr-&gt;end &#x3D; NULL;<br>    arr-&gt;size &#x3D; 0;<br>}</p><p>&#x2F;&#x2F; 头插法<br>void add_to_head(int x, lian* arr) {<br>    node* newnode &#x3D; create_node(x);<br>    if (newnode &#x3D;&#x3D; NULL) return;</p><pre><code>if (arr-&gt;size == 0) &#123;    arr-&gt;head = newnode;    arr-&gt;end = newnode;&#125;else &#123;    newnode-&gt;next = arr-&gt;head;    arr-&gt;head-&gt;prev = newnode;    arr-&gt;head = newnode;&#125;arr-&gt;size++;</code></pre><p>}</p><p>&#x2F;&#x2F; 尾插法<br>void add_to_tail(int x, lian* arr) {<br>    node* newnode &#x3D; create_node(x);<br>    if (newnode &#x3D;&#x3D; NULL) return;</p><pre><code>if (arr-&gt;size == 0) &#123;    arr-&gt;head = newnode;    arr-&gt;end = newnode;&#125;else &#123;    newnode-&gt;prev = arr-&gt;end;    arr-&gt;end-&gt;next = newnode;    arr-&gt;end = newnode;&#125;arr-&gt;size++;</code></pre><p>}</p><p>&#x2F;&#x2F; 在指定位置插入（位置从0开始）<br>void insert_at(int x, int pos, lian* arr) {<br>    if (pos &lt; 0 || pos &gt; arr-&gt;size) {<br>        cout &lt;&lt; &quot;位置无效！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>if (pos == 0) &#123;    add_to_head(x, arr);    return;&#125;if (pos == arr-&gt;size) &#123;    add_to_tail(x, arr);    return;&#125;node* newnode = create_node(x);if (newnode == NULL) return;// 找到插入位置的前一个节点node* current;if (pos &lt;= arr-&gt;size / 2) &#123;    // 从前向后找    current = arr-&gt;head;    for (int i = 0; i &lt; pos - 1; i++) &#123;        current = current-&gt;next;    &#125;&#125;else &#123;    // 从后向前找    current = arr-&gt;end;    for (int i = arr-&gt;size - 1; i &gt; pos - 1; i--) &#123;        current = current-&gt;prev;    &#125;&#125;// 插入新节点newnode-&gt;next = current-&gt;next;newnode-&gt;prev = current;current-&gt;next-&gt;prev = newnode;current-&gt;next = newnode;arr-&gt;size++;</code></pre><p>}</p><p>&#x2F;&#x2F; 删除头节点<br>void delete_head(lian* arr) {<br>    if (arr-&gt;size &#x3D;&#x3D; 0) {<br>        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>node* temp = arr-&gt;head;if (arr-&gt;size == 1) &#123;    arr-&gt;head = NULL;    arr-&gt;end = NULL;&#125;else &#123;    arr-&gt;head = arr-&gt;head-&gt;next;    arr-&gt;head-&gt;prev = NULL;&#125;free(temp);arr-&gt;size--;</code></pre><p>}</p><p>&#x2F;&#x2F; 删除尾节点<br>void delete_tail(lian* arr) {<br>    if (arr-&gt;size &#x3D;&#x3D; 0) {<br>        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>node* temp = arr-&gt;end;if (arr-&gt;size == 1) &#123;    arr-&gt;head = NULL;    arr-&gt;end = NULL;&#125;else &#123;    arr-&gt;end = arr-&gt;end-&gt;prev;    arr-&gt;end-&gt;next = NULL;&#125;free(temp);arr-&gt;size--;</code></pre><p>}</p><p>&#x2F;&#x2F; 删除指定值的节点（删除第一个匹配的）<br>void delete_value(int x, lian* arr) {<br>    if (arr-&gt;size &#x3D;&#x3D; 0) {<br>        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>node* current = arr-&gt;head;while (current != NULL) &#123;    if (current-&gt;data == x) &#123;        if (current == arr-&gt;head) &#123;            delete_head(arr);        &#125;        else if (current == arr-&gt;end) &#123;            delete_tail(arr);        &#125;        else &#123;            current-&gt;prev-&gt;next = current-&gt;next;            current-&gt;next-&gt;prev = current-&gt;prev;            free(current);            arr-&gt;size--;        &#125;        cout &lt;&lt; &quot;删除成功！&quot; &lt;&lt; endl;        return;    &#125;    current = current-&gt;next;&#125;cout &lt;&lt; &quot;未找到值为 &quot; &lt;&lt; x &lt;&lt; &quot; 的节点！&quot; &lt;&lt; endl;</code></pre><p>}</p><p>&#x2F;&#x2F; 删除指定位置的节点<br>void delete_at(int pos, lian* arr) {<br>    if (pos &lt; 0 || pos &gt;&#x3D; arr-&gt;size) {<br>        cout &lt;&lt; &quot;位置无效！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>if (pos == 0) &#123;    delete_head(arr);    return;&#125;if (pos == arr-&gt;size - 1) &#123;    delete_tail(arr);    return;&#125;// 找到要删除的节点node* current;if (pos &lt;= arr-&gt;size / 2) &#123;    current = arr-&gt;head;    for (int i = 0; i &lt; pos; i++) &#123;        current = current-&gt;next;    &#125;&#125;else &#123;    current = arr-&gt;end;    for (int i = arr-&gt;size - 1; i &gt; pos; i--) &#123;        current = current-&gt;prev;    &#125;&#125;// 删除节点current-&gt;prev-&gt;next = current-&gt;next;current-&gt;next-&gt;prev = current-&gt;prev;free(current);arr-&gt;size--;cout &lt;&lt; &quot;删除成功！&quot; &lt;&lt; endl;</code></pre><p>}</p><p>&#x2F;&#x2F; 查找节点<br>node* find_node(int x, lian* arr) {<br>    node* current &#x3D; arr-&gt;head;<br>    while (current !&#x3D; NULL) {<br>        if (current-&gt;data &#x3D;&#x3D; x) {<br>            return current;<br>        }<br>        current &#x3D; current-&gt;next;<br>    }<br>    return NULL;<br>}</p><p>&#x2F;&#x2F; 查找节点（反向查找）<br>node* find_node_reverse(int x, lian* arr) {<br>    node* current &#x3D; arr-&gt;end;<br>    while (current !&#x3D; NULL) {<br>        if (current-&gt;data &#x3D;&#x3D; x) {<br>            return current;<br>        }<br>        current &#x3D; current-&gt;prev;<br>    }<br>    return NULL;<br>}</p><p>&#x2F;&#x2F; 修改节点值<br>void update_value(int old_value, int new_value, lian* arr) {<br>    node* target &#x3D; find_node(old_value, arr);<br>    if (target !&#x3D; NULL) {<br>        target-&gt;data &#x3D; new_value;<br>        cout &lt;&lt; &quot;修改成功！&quot; &lt;&lt; endl;<br>    }<br>    else {<br>        cout &lt;&lt; &quot;未找到值为 &quot; &lt;&lt; old_value &lt;&lt; &quot; 的节点！&quot; &lt;&lt; endl;<br>    }<br>}</p><p>&#x2F;&#x2F; 修改指定位置的节点值<br>void update_at(int pos, int new_value, lian* arr) {<br>    if (pos &lt; 0 || pos &gt;&#x3D; arr-&gt;size) {<br>        cout &lt;&lt; &quot;位置无效！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>node* current;if (pos &lt;= arr-&gt;size / 2) &#123;    current = arr-&gt;head;    for (int i = 0; i &lt; pos; i++) &#123;        current = current-&gt;next;    &#125;&#125;else &#123;    current = arr-&gt;end;    for (int i = arr-&gt;size - 1; i &gt; pos; i--) &#123;        current = current-&gt;prev;    &#125;&#125;current-&gt;data = new_value;cout &lt;&lt; &quot;修改成功！&quot; &lt;&lt; endl;</code></pre><p>}</p><p>&#x2F;&#x2F; 正向显示链表<br>void display_forward(lian* arr) {<br>    if (arr-&gt;size &#x3D;&#x3D; 0) {<br>        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>node* current = arr-&gt;head;cout &lt;&lt; &quot;正向遍历: &quot;;while (current != NULL) &#123;    cout &lt;&lt; current-&gt;data;    if (current-&gt;next != NULL) &#123;        cout &lt;&lt; &quot; &lt;-&gt; &quot;;    &#125;    current = current-&gt;next;&#125;cout &lt;&lt; endl &lt;&lt; &quot;链表大小: &quot; &lt;&lt; arr-&gt;size &lt;&lt; endl;</code></pre><p>}</p><p>&#x2F;&#x2F; 反向显示链表<br>void display_backward(lian* arr) {<br>    if (arr-&gt;size &#x3D;&#x3D; 0) {<br>        cout &lt;&lt; &quot;链表为空！&quot; &lt;&lt; endl;<br>        return;<br>    }</p><pre><code>node* current = arr-&gt;end;cout &lt;&lt; &quot;反向遍历: &quot;;while (current != NULL) &#123;    cout &lt;&lt; current-&gt;data;    if (current-&gt;prev != NULL) &#123;        cout &lt;&lt; &quot; &lt;-&gt; &quot;;    &#125;    current = current-&gt;prev;&#125;cout &lt;&lt; endl &lt;&lt; &quot;链表大小: &quot; &lt;&lt; arr-&gt;size &lt;&lt; endl;</code></pre><p>}</p><p>&#x2F;&#x2F; 释放链表内存<br>void free_list(lian* arr) {<br>    node* current &#x3D; arr-&gt;head;<br>    while (current !&#x3D; NULL) {<br>        node* temp &#x3D; current;<br>        current &#x3D; current-&gt;next;<br>        free(temp);<br>    }<br>    arr-&gt;head &#x3D; NULL;<br>    arr-&gt;end &#x3D; NULL;<br>    arr-&gt;size &#x3D; 0;<br>}</p><p>int main() {<br>    lian list;<br>    init(&amp;list);</p><pre><code>cout &lt;&lt; &quot;=== 双向链表操作演示 ===&quot; &lt;&lt; endl;// 增加操作cout &lt;&lt; &quot;\n1. 增加节点测试：&quot; &lt;&lt; endl;add_to_tail(1, &amp;list);add_to_tail(2, &amp;list);add_to_tail(3, &amp;list);add_to_head(0, &amp;list);add_to_head(-1, &amp;list);insert_at(99, 2, &amp;list);display_forward(&amp;list);display_backward(&amp;list);// 查找操作cout &lt;&lt; &quot;\n2. 查找节点测试：&quot; &lt;&lt; endl;node* found = find_node(2, &amp;list);if (found != NULL) &#123;    cout &lt;&lt; &quot;找到节点: &quot; &lt;&lt; found-&gt;data &lt;&lt; endl;&#125;else &#123;    cout &lt;&lt; &quot;未找到节点&quot; &lt;&lt; endl;&#125;// 修改操作cout &lt;&lt; &quot;\n3. 修改节点测试：&quot; &lt;&lt; endl;update_value(2, 20, &amp;list);update_at(3, 30, &amp;list);display_forward(&amp;list);// 删除操作cout &lt;&lt; &quot;\n4. 删除节点测试：&quot; &lt;&lt; endl;cout &lt;&lt; &quot;删除头节点: &quot;;delete_head(&amp;list);display_forward(&amp;list);cout &lt;&lt; &quot;删除尾节点: &quot;;delete_tail(&amp;list);display_forward(&amp;list);cout &lt;&lt; &quot;删除值为20的节点: &quot;;delete_value(20, &amp;list);display_forward(&amp;list);cout &lt;&lt; &quot;删除位置1的节点: &quot;;delete_at(1, &amp;list);display_forward(&amp;list);// 清理cout &lt;&lt; &quot;\n5. 释放链表内存：&quot; &lt;&lt; endl;free_list(&amp;list);display_forward(&amp;list);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acking19</title>
      <link href="/2025/11/28/acwing19/"/>
      <url>/2025/11/28/acwing19/</url>
      
        <content type="html"><![CDATA[<p>\移动窗口问题<br>int n;<br>int k; &#x2F;&#x2F;滑动窗口大小<br>vector<int> brr;    &#x2F;&#x2F;存储所有所给的数字<br>vector<int> yd_down() {<br>vector<int> result;<br>deque<int> arr;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>if (!arr.empty() &amp;&amp; arr.front() &lt; i - k + 1) {<br>arr.pop_front();<br>}<br>while (!arr.empty() &amp;&amp; brr[arr.back()] &gt;&#x3D; brr[i]) {<br>arr.pop_back();<br>}<br>arr.push_back(i);<br>if (i &gt;&#x3D; k - 1) {<br>result.push_back(brr[arr.front()]);<br>}<br>}<br>return result;<br>}</p><p>今天的模拟赛一共有 n 名学生参加，包含 m 道题。学生的编号范围是 1～n，学生 i 在题目 j 的得分为 ai,j。<br>小黄是其中的学生 x。当某位学生在某道题目获得了该题的最高分或最低分（包括并列最高分或并列最低分）时就有可能被选中上台讲题。<br>小黄准备篡改自己不超过 c 道题目的得分。请你告诉她，她是否可以通过这样的方式，使自己完全不可能被选中上台讲题呢？</p><p>输入格式:<br>本题包含多组测试。<br>第一行一个整数 T，表示测试点中的测试数据组数。<br>对于每组测试数据：<br>第一行三个整数 n,m,x，表示学生数、题数和小黄的编号。<br>接下来 n 行，每行 m 个整数，第 i 行的第 j 个整数表示学生 i 在题目 j 的得分 ai,j?。<br>最后一行一个整数 c，表示小黄最多可以篡改的题目得分数量。</p><p>输出格式:<br>一行一个字符串，up 或 down。<br>up 表示小黄仍然有可能被选中上台讲题，<br>down 表示小黄不可能被选中上台讲题。</p><p>输入样例1:<br>2<br>3 3 1<br>40 50 50<br>60 40 50<br>70 45 55<br>3<br>3 3 1<br>50 50 50<br>60 40 55<br>70 45 50<br>2<br>输出样例1:<br>down<br>up<br>#include<iostream><br>#include<vector><br>#include<algorithm><br>#include<climits><br>using namespace std;<br>void dunc() {<br>    int n, m, x;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    x--;<br>    vector&lt;vector<int>&gt; scores(n, vector<int>(m));<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        for (int j &#x3D; 0; j &lt; m; j++) {<br>            cin &gt;&gt; scores[i][j];<br>        }<br>    }</p><pre><code>int need_change = 0;for (int j = 0; j &lt; m; j++) &#123;    int x_score = scores[x][j];    bool is_min = true, is_max = true;    for (int i = 0; i &lt; n; i++) &#123;        if (scores[i][j] &lt; x_score) &#123;            is_min = false;            break;        &#125;    &#125;    for (int i = 0; i &lt; n; i++) &#123;        if (scores[i][j] &gt; x_score) &#123;            is_max = false;            break;        &#125;    &#125;    if (is_min || is_max) &#123;        need_change++;    &#125;&#125;int c;cin &gt;&gt; c;if (need_change &lt;= c) &#123;    cout &lt;&lt; &quot;down&quot;;&#125;else &#123;    cout &lt;&lt; &quot;up&quot;;&#125;</code></pre><p>}<br>int main() {<br>    int T;<br>    cin &gt;&gt; T;<br>    while (T--) {<br>        dunc();<br>        if (T !&#x3D; 0) {<br>            cout &lt;&lt; &#39;\n&#39;;<br>        }<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing18</title>
      <link href="/2025/11/26/acwing18/"/>
      <url>/2025/11/26/acwing18/</url>
      
        <content type="html"><![CDATA[<p>##双链表<br>const int N &#x3D; 1e9 + 17;<br>int idx, r[N], l[N], e[N];<br>&#x2F;&#x2F;初始化<br>void init() {<br>r[0] &#x3D; 1; l[1] &#x3D; 0;<br>idx &#x3D; 2;<br>}<br>&#x2F;&#x2F;增<br>void add(int k, int x) {<br>e[idx] &#x3D; x;<br>r[idx] &#x3D; r[k];<br>l[idx] &#x3D; k;<br>l[r[k]] &#x3D; idx;<br>r[k] &#x3D; idx;<br>idx++;<br>}<br>&#x2F;&#x2F;修改左节点<br>void add_left(int x)<br>{<br>add(0, x);<br>}<br>&#x2F;&#x2F;修改右节点<br>void add_right(int x)<br>{<br>add(l[1], x);<br>}<br>&#x2F;&#x2F;除去下标为k元素<br>void remove(int k ) {<br>r[l[k]] &#x3D; r[k];<br>l[r[k]] &#x3D; l[k];<br>}<br>&#x2F;&#x2F;查找元素下标<br>void check(int x) {<br>int i &#x3D; r[0];<br>while (i !&#x3D; 1) {<br>if (e[i] &#x3D;&#x3D; x) {<br>cout &lt;&lt; i;<br>return;<br>}<br>else {<br>i &#x3D; r[i];<br>}<br>}<br>return;<br>}<br>&#x2F;&#x2F;修改元素<br>void update(int k, int x) {<br>e[k] &#x3D; x;<br>}<br>###双链表修改为循环链表<br>&#x2F;&#x2F;初始化<br>void init() {<br>    r[0] &#x3D; 1;  &#x2F;&#x2F; 头节点右指针指向尾节点<br>    l[1] &#x3D; 0;  &#x2F;&#x2F; 尾节点左指针指向头节点<br>    l[0] &#x3D; 1;  &#x2F;&#x2F; 新增：头节点左指针指向尾节点（形成循环）<br>    r[1] &#x3D; 0;  &#x2F;&#x2F; 新增：尾节点右指针指向头节点（形成循环）<br>    idx &#x3D; 2;<br>}<br>####遍历时后查找是到左端点####<br>&#x2F;&#x2F;头插<br>void add_left(int x) {<br>    add(0, x);  &#x2F;&#x2F; 正确<br>}<br>&#x2F;&#x2F;尾插<br>void add_right(int x) {<br>    add(l[1], x);  &#x2F;&#x2F; 正确<br>}<br>##模拟栈(先入后出)<br>int tt &#x3D; 0,m;<br>int stack[N];<br>void push(int x) {<br>    stack[tt++] &#x3D; x;<br>}<br>void pop() {<br>    tt--;<br>}<br>bool isEmpty() {<br>    if (tt &#x3D;&#x3D; 0) {<br>        return true;<br>    }<br>    else {<br>        return false;<br>    }<br>}<br>int query() {     &#x2F;&#x2F;查找栈顶元素<br>    return stack[tt - 1];<br>}<br>&#x2F;&#x2F;利用STL库中的stack栈函数<br>#创建栈<br>stack<int> arr;<br>#压入元素<br>arr.push();<br>#访问栈顶元素<br>&#x2F;&#x2F;必须先判断栈是否为空,会报runtime错误<br>arr.top();<br>#检查栈是否为空<br>if(!arr.empty)<br>#可以使用arr.size()查看栈的大小<br>(isdigit(c)<br>(isalpha(c)</p><p>##队列<br>#include<queue>  &#x2F;&#x2F;队列<br>queue<int> arr ;<br>arr.push(x) ;      &#x2F;&#x2F;尾部插入<br>arr.pop() ;         &#x2F;&#x2F;头部删除<br>arr.front();         &#x2F;&#x2F;访问队首元素(针对出队元素)<br>arr.back() ;         &#x2F;&#x2F;访问队尾元素(针对入队元素)<br>#include<deque> &#x2F;&#x2F; 双端队列<br>deque<int> arr ;<br>arr.push_front(x) ;      &#x2F;&#x2F;头部插入<br>arr.push_back(x) ;      &#x2F;&#x2F;尾部插入<br>arr.pop_front() ;         &#x2F;&#x2F;弹出头部<br>arr.pop_back() ;         &#x2F;&#x2F;弹出尾部<br>arr.front() ;                &#x2F;&#x2F;访问首元素<br>arr.back() ;                &#x2F;&#x2F;访问尾元素<br>arr[i] ||   arr.at(i)        &#x2F;&#x2F;支持O(1) 访问    &#x2F;&#x2F;类似下标访问位置是固定的值位置会变无法实现追踪<br>arr.size() 和  arr.empty()      &#x2F;&#x2F;同样支持   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing17</title>
      <link href="/2025/11/24/acwing17/"/>
      <url>/2025/11/24/acwing17/</url>
      
        <content type="html"><![CDATA[<p>#开始数据结构学习<br>#include<iostream><br>using namespace std;<br>#define int long long<br>const int N &#x3D; 1e9 + 17;<br>int head, e[N], ne[N], idx;<br>void init() {<br>head &#x3D; -1;<br>idx &#x3D; 0;<br>}<br>&#x2F;&#x2F;增<br>&#x2F;&#x2F;新增的下标为idx元素会插在head和下标为0的元素之间<br>&#x2F;&#x2F;这里的head &#x3D; idx++ 实际上是  head &#x3D; idx ; idx ++ ;<br>void add_head(int x) {<br>e[idx] &#x3D; x;<br>ne[idx] &#x3D; head;<br>head &#x3D; idx++;<br>}<br>void add(int k, int x) {<br>e[idx] &#x3D; x;<br>ne[idx] &#x3D; ne[k];<br>ne[k] &#x3D; idx++;<br>}<br>&#x2F;&#x2F;删<br>void remove(int k) {<br>ne[idx] &#x3D; ne[ne[k]];<br>}<br>void remove_head() {<br>if (head &#x3D;&#x3D; -1) {      &#x2F;&#x2F;head正常条件下指向0节点<br>return;<br>}<br>head &#x3D; ne[head];<br>}<br>&#x2F;&#x2F;查<br>int find_index(int x) {<br>int find &#x3D; head;<br>while (find !&#x3D; -1) {<br>if (e[find] &#x3D;&#x3D; x) {      &#x2F;&#x2F; e 查找的是值ok?<br>return find;<br>}<br>find &#x3D; ne[find];<br>}<br>return -1;<br>}<br>&#x2F;&#x2F;改<br>void gai(int k, int x) {<br>e[k] &#x3D; x;<br>}<br>int main() {<br>init();<br>add_head(x) ;<br>tail &#x3D; head ;<br>for (int i &#x3D; 1; i &lt; n; i++) {<br>        cin &gt;&gt; x;<br>        add(tail, x);<br>        tail &#x3D; ne[tail];<br>    }<br>&#x2F;&#x2F;调用函数输出即可<br>for (int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i])  cout &lt;&lt; e[i] &lt;&lt; &#39; &#39;;<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing16</title>
      <link href="/2025/11/22/acwing15/"/>
      <url>/2025/11/22/acwing15/</url>
      
        <content type="html"><![CDATA[<p>###约数<br>#1:筛出约数<br>vector<int> check(int n ) {<br>vector<int> arr;<br>for (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; i; i++) {<br>if (n % i &#x3D;&#x3D; 0) {<br>arr.push_back(i);<br>if (i !&#x3D; n &#x2F; i) arr.push_back(n &#x2F; i);<br>}<br>}<br>sort(arr.begin(), arr.end());<br>return arr;<br>}</p><p>#2.计算约数个数<br>#include<unordered_map><br>#define int long long<br>const int N &#x3D; 1e9 + 17;<br>void yue_s() {<br>int n;<br>cin &gt;&gt; n;<br>unordered_map&lt;int , int&gt; arr;<br>for (int i &#x3D; 2; i &lt;&#x3D; n &#x2F; i; i++) {<br>while (n % i &#x3D;&#x3D; 0) {<br>n &#x2F;&#x3D; i;<br>arr[i]++;<br>}<br>}<br>if (n &gt; 1) arr[n]++;<br>int s &#x3D; 1;<br>for (auto it : arr) s &#x3D; s * (it.second + 1) % N;<br>cout &lt;&lt; s;<br>}</p><p>#3.计算约数之和<br>void yue_s() {<br>int n;<br>cin &gt;&gt; n;<br>unordered_map&lt;int , int&gt; arr;<br>for (int i &#x3D; 2; i &lt;&#x3D; n &#x2F; i; i++) {<br>while (n % i &#x3D;&#x3D; 0) {<br>n &#x2F;&#x3D; i;<br>arr[i]++;<br>}<br>}<br>if (n &gt; 1) arr[n]++;<br>int s &#x3D; 1;<br>for (auto it : arr) {<br>int p &#x3D; it.first, a &#x3D; it.second;<br>int sum &#x3D; 1;<br>while (a--) sum &#x3D; (sum * p + 1 ) % N;<br>s &#x3D; s * sum % N;<br>}<br>cout &lt;&lt; s;<br>}<br>&#x2F;&#x2F;上面的老是超时采用下面1ms的<br>\计算区间整数的约数总和 &#x3D; sum(r) - sum(l - 1);<br>优化(数论分块):   计算从1到n 所有数的约数之和:计算单一值时:sum(n) - sum(n - 1);<br>ll sum(int n) {<br>    if (n &lt;&#x3D; 1) return n;<br>    ll ans &#x3D; 0;<br>    for (ll l &#x3D; 1, r; l &lt;&#x3D; n; l &#x3D; r + 1) {<br>        int yue &#x3D; (n &#x2F; l);<br>        r &#x3D; n &#x2F; yue;<br>        ans +&#x3D; yue * (l + r) * (r - l + 1) &#x2F; 2;<br>    }<br>    return ans;<br>}</p><p>#4.找最大公约数(比自带的更好)<br>int gcd(int a, int b) {<br>    while (b !&#x3D; 0) {<br>        int temp &#x3D; b;<br>        b &#x3D; a % b;<br>        a &#x3D; temp;<br>    }<br>    return a;<br>}</p><p>#5.快速幂<br>int kuai_mi(int x, int n,int ) {<br>int res &#x3D; 1;<br>while (n) {<br>if (n &amp; 1) {<br>res *&#x3D; x;<br>}<br>x *&#x3D; x;<br>n &gt;&gt;&#x3D; 1;<br>}<br>return res;<br>}</p><p>#6.十进制转化为2 - 10 进制<br>int huan(int x, int k) {<br>if (x &#x3D;&#x3D; 0) return 0;<br>int step &#x3D; 1;<br>int result &#x3D; 0;<br>while (x) {<br>int m &#x3D; x % k;<br>x &#x3D; x &#x2F; k;<br>result &#x3D; m * step + result;<br>step *&#x3D; 10;<br>}<br>return result;<br>}</p><p>#7.快速幂求逆元:<br>int kuai_ni(int x, int p, int k) {<br>    int res &#x3D; 1;<br>    while (p &gt; 0) {<br>        if (p &amp; 1) {<br>            res &#x3D; (res * x) % k;<br>        }<br>        x &#x3D; (x * x) % k;<br>        p &gt;&gt;&#x3D; 1;<br>    }<br>    return res;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing15</title>
      <link href="/2025/11/21/acwing16/"/>
      <url>/2025/11/21/acwing16/</url>
      
        <content type="html"><![CDATA[<p>##动态规划<br>背包问题(0 - 1)<br>int bei_1(vector<int> wei, vector<int>values, int max_wei) {<br>    int n &#x3D; wei.size();<br>    vector<int> dp(max_wei + 1, 0);<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        for (int w &#x3D; max_wei; w &gt;&#x3D; we[i]; w--) {<br>            dp[w] &#x3D; max(dp[w], values[i] + dp[w - wei[i]]);<br>        }<br>    }<br>    return dp[max_wei];<br>}<br>完全背包问题(每一个都是无限的数目)<br>int wan_bei(vector<int> wei, vector<int> values, int max_wei) {<br>    int n &#x3D; wei.size();<br>    vector<int> dp( max_wei+ 1, 0);<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        &#x2F;&#x2F; 正序遍历，允许重复选择同一物品<br>        for (int w &#x3D; wei[i]; w &lt;&#x3D; max_wei; w++) {<br>            dp[w] &#x3D; max(dp[w], values[i] + dp[w - wei[i]]);<br>        }<br>    }<br>    return dp[max_wei];<br>}<br>多重背包问题(每个物品都有其固定的个数)<br> vector<int> new_wei, new_value;<br>    for (int i &#x3D; 0; i &lt; wei.size(); i++) {<br>        int count &#x3D; counts[i];    &#x2F;&#x2F;单个物品的数目<br>        for (int k &#x3D; 1; k &lt;&#x3D; count; k *&#x3D; 2) {<br>            new_wei.push_back(wei[i] * k);<br>            new_value.push_back(value[i] * k);<br>            count -&#x3D; k;<br>        }<br>        if (count &gt; 0) {<br>            new_wei.push_back(wei[i] * count);<br>            new_value.push_back(value[i] * count);<br>        }<br>    }<br>    &#x2F;&#x2F; 2. 0-1背包求解（就是您问的这段代码）<br>    vector<int> dp(max_wei+ 1, 0);<br>    for (int i &#x3D; 0; i &lt; new_wei.size(); i++) {<br>        for (int w &#x3D; max_wei; w &gt;&#x3D; new_wei[i]; w--) {<br>            dp[w] &#x3D; max(dp[w], new_value[i] + dp[w - new_wei[i]]);<br>        }<br>    }</p><pre><code>return dp[max_wei];</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing14</title>
      <link href="/2025/11/20/acwing14/"/>
      <url>/2025/11/20/acwing14/</url>
      
        <content type="html"><![CDATA[<p>##判断质数<br>bool check(int x ) {<br>if (x &lt; 2) return false;<br>for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i++) {<br>if (x % i &#x3D;&#x3D; 0) {<br>return false;<br>}<br>}<br>return true;<br>}<br>##寻找质因数<br>void check(int x) {<br>for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i++) {<br>if (x % i &#x3D;&#x3D; 0) {<br>int count &#x3D; 0;<br>while (x % i &#x3D;&#x3D; 0) {<br>x &#x3D; x &#x2F; i;<br>count++;      &#x2F;&#x2F;count 代表i 的指数<br>}<br>cout &lt;&lt; i &lt;&lt;&#39; &#39;&lt;&lt; count;<br>}<br>}<br>if (x &gt; 1) {<br>cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1;<br>}<br>}</p><p>##寻找序列质数<br>const int N &#x3D; 1e5;<br>vector<int> arr(N);<br>int cnt;<br>bool brr[N];<br>void check(int x) {<br>for (int i &#x3D; 2; i &lt;&#x3D; x; i++) {<br>if (!brr[i]) {<br>arr[cnt++] &#x3D; i;<br>for (int j &#x3D; i + i; j &lt;&#x3D; x; j +&#x3D; i) {<br>brr[j] &#x3D; true;<br>}<br>}<br>}<br>for (int i &#x3D; 0; i &lt;cnt; i++) {<br>cout &lt;&lt; arr[i];<br>}<br>}<br>for (int i &#x3D; 0; i &lt; ans; i++) {<br>        for (int j &#x3D; max(2LL * arr[i], ((M + arr[i] - 1) &#x2F; arr[i]) * arr[i]); j &lt;&#x3D; N; j +&#x3D; arr[i]) {<br>            if (j - M &gt;&#x3D; 0) {<br>                crr[j - M] &#x3D; 1;<br>            }<br>        }<br>    }<br>&#x2F;&#x2F;找区间质数的数目</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java_01</title>
      <link href="/2025/11/14/java-01/"/>
      <url>/2025/11/14/java-01/</url>
      
        <content type="html"><![CDATA[<p>JDK( Java development kit)是JAVA语言的软件开发工具包 ( JVM  + 开发工具 + 核心类库) ;<br>包含JRE( java运行环境 [ JVM  + 运行工具] + 核心类库 )      JDK  &gt; JRE &gt; JVM ( java virtual machine )<br>java源文件 -&gt;(javac.exe[ 后缀有java ] ) JVM文件.class -&gt; ( java.exe [后缀不含Java]) -&gt; 输出结果   { 基础编译 }<br>public static  void main( String[]args ) 定义一个叫 class 的类<br>1.public : 程序访问权限 , 任何场合都可被引用<br>2.static : 方法是静态的,不依赖类的对象的<br>3.void : 表示无返回值<br>4:参数Stirng[]args 是字符串数组,接收程序执行时传入参数</p><p>常见CMD命令 : </p><ol><li>盘符 加 &quot; : &quot; ; </li><li>dir 查看当前路径全部内容</li><li>cd 进入当前文件夹 </li><li>cd\ 回退到盘符 </li><li>cls 清屏 </li><li>exit 退出CMD窗口</li></ol><p>####输入输出流<br>import java.io.<em>;   &#x2F;&#x2F;导入java.io包中的所有类。这个包提供了输入&#x2F;输出相关的功能<br>import java.util.</em>; &#x2F;&#x2F;这个包包含了很多实用工具，比如：<br>集合框架（List, Map, Set, ArrayList, HashMap）<br>日期时间类（旧版的Date, Calendar，但新版推荐用java.time）<br>随机数生成（Random）<br>扫描器（Scanner）等<br>&#x2F;&#x2F;关闭输入流 : scanner.close(); 关闭scanner ;<br>    public static void main(String[] args) {<br>        Scanner 变量名 &#x3D; new Scanner(System.in);      &#x2F;&#x2F;键盘录入 , s 处可以随便命名<br>        double n &#x3D; 变量名. nextDouble() ;                          &#x2F;&#x2F;设置变量<br>        System.out.println(1 + 1 ) ;<br>变量名.close() ;<br>next()读取一个字符串（到空白符）String s &#x3D; scanner.next();<br>nextLine()读取一行 String line &#x3D; scanner.nextLine();<br>next().charAt(0)读取第一个字符char c &#x3D; scanner.next().charAt(0);<br>nextBoolean()读取布尔值boolean b &#x3D; scanner.nextBoolean();<br>最快输入流:<br>public class CompetitiveIO {<br>    static BufferedReader br;<br>    static StringTokenizer st;<br>    static PrintWriter pw;<br>    public static void main(String[] args) throws IOException {<br>        br &#x3D; new BufferedReader(new InputStreamReader(System.in));<br>        pw &#x3D; new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));<br>        &#x2F;&#x2F; 读取整数<br>        int n &#x3D; nextInt();<br>        int m &#x3D; nextInt();<br>        &#x2F;&#x2F; 读取长行并分割<br>        st &#x3D; new StringTokenizer(br.readLine());<br>        int[] arr &#x3D; new int[n];<br>        for (int i &#x3D; 0; i &lt; n; i++) {<br>            arr[i] &#x3D; Integer.parseInt(st.nextToken());<br>        }<br>        pw.println(n + m);<br>        pw.flush();<br>    }<br>    static int nextInt() throws IOException {<br>        while (st &#x3D;&#x3D; null || !st.hasMoreTokens()) {<br>            st &#x3D; new StringTokenizer(br.readLine());<br>        }<br>        return Integer.parseInt(st.nextToken());<br>    }<br>    static String next() throws IOException {<br>        while (st &#x3D;&#x3D; null || !st.hasMoreTokens()) {<br>            st &#x3D; new StringTokenizer(br.readLine());<br>        }<br>        return st.nextToken();<br>    }<br>}<br>####类型区别:<br>byte 是有符号整数类型(-128 到 127)<br>boolean 是布尔型的定义类型</p><p>java : Random 类 :生成随机数<br>导包  , 创建对象<br>Random r &#x3D; new Randow() ;<br>int number &#x3D; r.nextInt(随机数的范围[ bound : 100  ] + n  {通过加n 来实现在n ~ m 的随机数} ) ;  &#x2F;&#x2F; 0 ~ 99 包头不包尾  (和 python 内的 range相同)</p><p>####变量 :<br>全局变量  ;<br>public static int onlineUserCount &#x3D; 0;<br>定义常量 :<br>public static final int N &#x3D; 1000; </p><p>####定义数组:<br>声明后指定大小<br>一维 : int[] arr1 &#x3D; new int[5];  &#x2F;&#x2F; 创建一个长度为5的int数组，默认值为0<br>二维 : int[][] arr &#x3D; new int[row][col] ;<br>   实现自定义边界 [控制单行的列数]　:<br>   int[][] arr &#x3D; new[3 ][] ;<br>   arr[n] &#x3D; new int[ x ] ;   &#x2F;&#x2F; 控制第n行输出x列<br><br>####万能类型转化公式<br>String s &#x3D; String.valueOf(a); 可实现任意类型转化为String形式的变量<br>int num &#x3D; Integer.parseInt(&quot;123&quot;); 实现String 型转化为 int 类型的变量<br>double d &#x3D; Double.parseDouble(str); 实现 String 型转化为 double 类型的变量</p><p>####类似STL : vector : ApI 包中的动态数组 ArrayList<Integer> ;<br>int 和 integer :     特性int (基本类型)Integer (引用类型&#x2F;包装类)<br>                            类型基本数据类型对象（包装类）<br>        内存4字节（栈内存）对象开销（堆内存）<br>默认值0null<br>比较值比较 (&#x3D;&#x3D;)需要.equals()或拆箱<br>集合❌ 不能直接放入集合✅ 可以放入集合<br>泛型❌ 不能用于泛型✅ 可以用于泛型<br>&#x2F;&#x2F;1.实现初始化动态数组<br>ArrayList<Integer> list &#x3D; new ArrayLisrt&lt;&gt;() ; </p><pre><code>// 2. 添加元素（自动扩容）    变量名.add(10);     // 末尾添加  = (C++) arr . push_back( 10 ) ;     变量名.add(20);    变量名.add(30);    变量名 .add(1, 15);  // 在索引1处插入15//3.判断数组是否为空变量名.isEmpty( ) ;         // 4. 清空列表    变量名.clear();    // 5. 获取元素    变量名.get(x));  // 获取索引是x 的数    //6.获取数组大小变量名.size() ;      // 7. 修改元素    list.set(1, 250);  // 将索引1改为250    System.out.println(&quot;修改后: &quot; + list);  // [100, 250, 300]        // 8. 删除元素    list.remove(x);  // 删除索引x 所指的数      //9.判断类似find函数 :     变量名.contains(250)); </code></pre><p> ####实现自动推导( var )类型 :<br>直接用于遍历数组 :<br>for(var it : 数组) {}  </p><p> ####方法 :    最小执行单元  ( 要么全执行  , 要么全不执行 )    重复且独立  会复用 </p><p> &#x2F;&#x2F;注意这里的<br> 有static : 静态方法 : 属于类 , 类加载时初始化 , 不支持重写<br> 无static :  实例方法 , 属于对象 , 随对象创建  , 支持重写<br> &#x2F;&#x2F;参数:<br> 形参 : 形式参数 : 定义方法时里面定义的<br> 实参 : 调用方法 : 传入方法中进行计算<br> &#x2F;&#x2F;可以实现各种调用<br> public static void main(String[] args)   mian 方法 , 主方法     调用方法：方法名() ;<br> public static void 类名{ 方法体 }     设计一个空类型的类 ( 等同于 void 函数[C++])<br> public static void 类名( int a , int b ) {}   实现传值 ;<br> public 返回值类型 方法名{}   设计一个返回类型的方法   也是在方法体最后补上return 返回值 ;<br>方法之间是平级的 , 和C ++ 类似 : 可在main函数之前定义方法 即 编写顺序和执行顺序无关<br>&#x2F;&#x2F;方法的重载 JVM通过找参数( 个数 , 类型 )相同 区分 不同方法<br>好处 :  调用方法时 :<br>&#x2F;&#x2F;在一个类中, 定义多个同名方法 , 同名方法具有相同功能<br>&#x2F;&#x2F;每个方法具有不同的参数类型和参数个数 , 这些同名方法,  构成重载关系<br>&#x2F;&#x2F;提高API的易用性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/11/14/acwing13/"/>
      <url>/2025/11/14/acwing13/</url>
      
        <content type="html"><![CDATA[<p>####修行算法的第十三天</p><hr><h2 id="title-ackwing13date-2025-11-14-10-21-29tags"><a href="#title-ackwing13date-2025-11-14-10-21-29tags" class="headerlink" title="title: ackwing13date: 2025-11-14 10:21:29tags:"></a>title: ackwing13<br>date: 2025-11-14 10:21:29<br>tags:</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing12</title>
      <link href="/2025/11/13/acwing12/"/>
      <url>/2025/11/13/acwing12/</url>
      
        <content type="html"><![CDATA[<p>###二分结束:<br>#不必求值,卡范围带入数值测试即可<br>##分数列code:<br>#include<iostream><br>#include<vector><br>using namespace std;<br>#define int long long<br>int n, m;<br>const int N &#x3D; 3e6 + 17 + 3e5;<br>vector<int>arr(N);<br>int check(int x) {<br>    int num &#x3D; 0, count &#x3D; 0 ;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        if (num + arr[i] &gt;&#x3D; x) {<br>            count++;<br>            num &#x3D; arr[i];<br>        }<br>        else {<br>            num +&#x3D; arr[i];<br>        }<br>    }<br>    return count &gt;&#x3D; m ;<br>}<br>signed main() {<br>    cin &gt;&gt; n &gt;&gt; m;<br>    int l &#x3D; 0, r &#x3D; 0;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        cin &gt;&gt; arr[i];<br>        l &#x3D; max(l, arr[i]);<br>        r +&#x3D; arr[i];<br>    }<br>    if (m &#x3D;&#x3D; n) {<br>        cout &lt;&lt; l;<br>        return 0;<br>    }<br>    while (l + 1 &lt; r) {<br>        int mid &#x3D; (l + r) &gt;&gt; 1;<br>        if (check(mid)) l &#x3D; mid;<br>        else r &#x3D; mid;<br>    }<br>    cout &lt;&lt; l;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>crawler1</title>
      <link href="/2025/11/12/crawler1/"/>
      <url>/2025/11/12/crawler1/</url>
      
        <content type="html"><![CDATA[<p>构建虚拟环境C:\Crawler\venv\Scripts\python.exe (此处路径包含所有爬虫库函数)&quot;项目地址指向目标文件.py&quot;<br>##爬取图片code:<br>import request ; &#x2F;&#x2F; https 请求<br>url  &#x3D; &quot; &quot;<br>response &#x3D; request.get(url)<br>with open(&#39;项目名.格式&#39; ,&#39;wb&#39;(图片类型)) as f:<br>        f.write(response.content)<br>##爬取MP3<br>import os : 文件和目录操作<br>import requests<br>from lxml import etree<br> headers &#x3D; {请求头(user_agent + cookies)}    &#x2F;&#x2F; 做一个请求头的池子<br> url &#x3D; &quot;地址&quot;<br> response &#x3D; request.get(url ,headers &#x3D; headers)<br> html &#x3D; etree.HTML(response.text)    &#x2F;&#x2F; 抓取HTML内容<br> song_ids &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@class&#x3D;&quot;f-hide&quot;]&#x2F;li&#x2F;a&#x2F;@href&#39;)<br>song_names &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@class&#x3D;&quot;f-hide&quot;]&#x2F;li&#x2F;a&#x2F;text()&#39;)   (xpath选择器)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acking11</title>
      <link href="/2025/11/12/acwing11/"/>
      <url>/2025/11/12/acwing11/</url>
      
        <content type="html"><![CDATA[<p>##计算joker的数目code:<br>#include<iostream><br>#include<vector><br>#include<cmath><br>#define int long long<br>using namespace std;<br>int n , m ;<br>const int N &#x3D; 5e6 + 17;<br>vector<int> arr(N);<br>bool check(int x ){<br>    int ans &#x3D; 0  ;<br>    for(int i &#x3D; 0 ; i &lt; n ; i ++){<br>        if(arr[i] &gt; x) continue;<br>        ans +&#x3D; (x - arr[i]);<br>        if(ans &gt; m) return false ;<br>    }<br>    return ans &lt;&#x3D; m;<br>}<br>signed main(){<br>    cin&gt;&gt;n&gt;&gt;m;<br>    int right &#x3D; 5e8+17;<br>    for(int i &#x3D; 0 ; i &lt; n ; i++ ) {<br>        cin&gt;&gt;arr[i];<br>    }<br>    int left &#x3D; -1 ;<br>    while(left + 1 &lt; right){<br>        int mid &#x3D; (left + right ) &gt;&gt; 1 ;<br>        if(check(mid)) left &#x3D; mid;<br>        else right &#x3D; mid;<br>    }<br>    cout&lt;&lt;left;<br>    return 0 ;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acking10</title>
      <link href="/2025/11/10/acwing10/"/>
      <url>/2025/11/10/acwing10/</url>
      
        <content type="html"><![CDATA[<p> ##鼠标不好用了<br> 复习了一天代码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing9</title>
      <link href="/2025/11/07/acwing9/"/>
      <url>/2025/11/07/acwing9/</url>
      
        <content type="html"><![CDATA[<p>###离散化练习<br>#数列离散code:</p><p>int er_f(int x,const vector<int>&amp;brr ){         &#x2F;&#x2F;返回下标<br>    int l &#x3D; -1 , r &#x3D; brr.size();<br>    while(l+1 &lt; r){<br>        int mid &#x3D; (l + r)&gt;&gt;1;<br>        if(brr[mid] &lt; x) l &#x3D; mid;<br>        else r &#x3D; mid;<br>    }<br>    return l+1 ;<br>}</p><p>void mq(){<br>int m ;<br>        cin&gt;&gt;m;<br>        vector<int> arr(m);<br>        for(int i &#x3D; 0 ; i &lt; m ; i++) cin&gt;&gt;arr[i];<br>        vector<int>brr &#x3D; arr;<br>        sort(brr.begin(),brr.end());<br>        brr.erase(unique(brr.begin(),brr.end()),brr.end());       &#x2F;&#x2F; 去重brr数组;    &#x2F;&#x2F; 保留单调性<br>        for(int i &#x3D; 0 ; i&lt; m ; i++){<br>            int count &#x3D; er_f(arr[i],brr);<br>            cout&lt;&lt;count+1&lt;&lt;&#39; &#39;;<br>        }<br>        cout&lt;&lt;&#39;\n&#39;;<br>}</p><p>#火烧赤壁(合并序列):<br>typedef pair&lt;int , int&gt; Q;<br>int n;<br>vector<Q> arr;<br>void lsan(vector<Q>&amp;arr){<br>    vector<Q> brr;<br>    sort(arr.begin(),arr.end());<br>    int  st &#x3D; -1e9 , ed &#x3D; -1e9;<br>    for(auto it : arr){<br>        if(it.first &gt; ed){<br>          if(st !&#x3D; -1e9) brr.push_back({st,ed});<br>            st &#x3D; it.first;<br>            ed &#x3D; it.second;<br>        } else{<br>            ed &#x3D; max(ed , it.second);<br>        }<br>    }<br>    if(st !&#x3D; -1e9) brr.push_back({st,ed});<br>    arr &#x3D; brr;<br>}</p><p>##位运算<br>#原反补码的定义:正数这三个均相同(右移1会可以实现 &#x2F; 2)<br>#补码取反+1<br>##^按位异或两个位不同时结果为11010 ^ 1100 &#x3D; 0110<br>##~按位取反所有位取反（0变1，1变0）~1010 &#x3D; 0101<br>###找出x二进制中所有的1<br>&#x2F;&#x2F;找到x最低位所代表的数字<br>int lowbit(int x)<br>{<br>    return x &amp; -x;<br>}<br>    while (n -- )<br>    {<br>        int x;<br>        cin &gt;&gt; x;<br>        int res &#x3D; 0;<br>        while (x)<br>        {<br>            x -&#x3D; lowbit(x); &#x2F;&#x2F; 去掉最低位一去找下一个1<br>            res++;          &#x2F;&#x2F; 计数加1<br>        }<br><br>####实现快速幂的做法(控制2进制)<br>long long binpow(long long a, long long b, long long mod) {<br>    long long res &#x3D; 1;<br>    while (b &gt; 0) {<br>        if (b &amp; 1) {  &#x2F;&#x2F; 检查当前二进制位是否为1  (若是二进制位是1 幂之和要加a的幂)<br>            res &#x3D; res * a % mod;  &#x2F;&#x2F; 如果为1，乘入结果<br>        }<br>        a &#x3D; a * a % mod;  &#x2F;&#x2F; a自乘，计算下一轮的a^(2^k)<br>        b &gt;&gt;&#x3D; 1;          &#x2F;&#x2F; 右移，处理下一位<br>    }<br>    return res;<br>&#x3D;<br>&#x2F;&#x2F;递归快速幂(略逊于迭代)<br>int QuickPow(int N, int x, int mod)<br>{<br>    if(x &#x3D;&#x3D; 0) return 1;<br>    if(x &#x3D;&#x3D; 1) return N % mod;<br>    long long result;<br>    if(x &amp; 1) {  &#x2F;&#x2F; 奇数<br>        result &#x3D; (long long)N * QuickPow(N, x-1, mod) % mod;<br>    } else {     &#x2F;&#x2F; 偶数<br>        long long temp &#x3D; QuickPow((long long)N * N % mod, x&#x2F;2, mod);<br>        result &#x3D; temp % mod;<br>    }<br>    return result;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing8</title>
      <link href="/2025/11/06/acwing8/"/>
      <url>/2025/11/06/acwing8/</url>
      
        <content type="html"><![CDATA[<p>##选画家code(寻找最短固定子序列):<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; arr[i];<br>    int cnt &#x3D; 0, len &#x3D; n + 1, left &#x3D; 0, right &#x3D; 0;<br>    for (int i &#x3D; 1, j &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        if (s[arr[i]] &#x3D;&#x3D; 0) {<br>            cnt++;<br>        }<br>        s[arr[i]]++;<br>        while (cnt &#x3D;&#x3D; m &amp;&amp; j &lt;&#x3D; i) {<br>            if (i - j + 1 &lt; len) {<br>                len &#x3D; i - j + 1;<br>                left &#x3D; j;<br>                right &#x3D; i;<br>            }<br>            s[arr[j]]--;<br>            if (s[arr[j]] &#x3D;&#x3D; 0) {<br>                cnt--;<br>            }<br>            j++;<br>        }<br>    }<br>if (len &lt; n + 1) {<br>    cout &lt;&lt; left &lt;&lt; &#39; &#39; &lt;&lt; right;<br>    return  0;<br>}</p><p>###算法一 : 离散化(在含重复数组中先排序再去重再进行操作)(常和二分一起使用)<br>    while (n--) {<br>        int m;<br>        cin &gt;&gt; m;<br>        vector<int> arr(m);<br>        for (int i &#x3D; 0; i &lt; m; i++) cin &gt;&gt; arr[i];<br>        vector<int> brr &#x3D; arr;<br>        sort(brr.begin(),brr.end());<br>        brr.erase(unique(brr.begin(), brr.end()), brr.end());<br>        for (int i &#x3D; 0; i &lt; m; i++) {<br>            cout &lt;&lt; er_f(arr[i], brr , brr.size()) + 1&lt;&lt;&#39; &#39;;<br>        }<br>}<br>#离散化求取数列和<br>int n, m;<br>int a[N], s[N];<br>vector<int> alls;<br>vector<PII> add, query;</p><p>int find(int x) {<br>    int l &#x3D; --1, r &#x3D; alls.size() ;<br>    while (l +1&lt; r) {<br>        int mid &#x3D; l + r &gt;&gt; 1;<br>        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;<br>        else l &#x3D; mid + 1;<br>    }<br>    return l ;<br>}</p><p>int main() {<br>    cin &gt;&gt; n &gt;&gt; m;</p><pre><code>for (int i = 0; i &lt; n; i++) &#123;    int x, c;    cin &gt;&gt; x &gt;&gt; c;    add.push_back(&#123;x, c&#125;);    alls.push_back(x);&#125;for (int i = 0; i &lt; m; i++) &#123;    int l, r;    cin &gt;&gt; l &gt;&gt; r;    query.push_back(&#123;l, r&#125;);    alls.push_back(l);    alls.push_back(r);&#125;#核心:将离散坐标变成连续小坐标   // 离散化sort(alls.begin(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end());// 处理添加操作for (auto item : add) &#123;    int x = find(item.first);    a[x] += item.second;                      &#125;int max_index = alls.size();for (int i = 1; i &lt;= max_index; i++) &#123;    s[i] = s[i - 1] + a[i];&#125;// 处理查询for (auto item : query) &#123;    int l = find(item.first), r = find(item.second);    cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;&#125;</code></pre><p>}<br>###算法二: 区间合并<br>code:<br>void merge(vector<PII> &amp;segs)<br>{<br>    vector<PII> res;<br>    sort(segs.begin(), segs.end());<br>    int st &#x3D; -2e9, ed &#x3D; -2e9;<br>    for (auto seg : segs) {<br>        if (ed &lt; seg.first) {<br>            if (st !&#x3D; -2e9) res.push_back({st, ed});<br>            st &#x3D; seg.first;<br>            ed &#x3D; seg.second;<br>        } else {<br>            ed &#x3D; max(ed, seg.second);<br>        }<br>    }<br>    if (st !&#x3D; -2e9) res.push_back({st, ed});<br>    segs &#x3D; res;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing7</title>
      <link href="/2025/11/05/acwing7/"/>
      <url>/2025/11/05/acwing7/</url>
      
        <content type="html"><![CDATA[<p>###练习前缀和(卡边界i最大j最小矩形的边界条件)<br>炸弹问题code:<br>#include<iostream><br>#include<algorithm><br>#define int long long<br>using namespace std;<br>const int N &#x3D; 1e4+17;<br>int arr[N][N],brr[N][N];<br>int n, m;<br>int qian_he(int x1, int y1,int x2 ,int y2) {<br>return brr[x2][y2] - brr[x1 - 1][y2] - brr[x2][y1 - 1] + brr[x1 - 1][y1 - 1];<br>}<br>signed main() {<br>ios::sync_with_stdio(false);<br>cin.tie(nullptr);<br>int x, y, v;<br>cin &gt;&gt; n &gt;&gt; m;<br>int max_x &#x3D; 0;<br>int max_y &#x3D; 0;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;<br>max_x &#x3D; max(max_x, x);<br>max_y &#x3D; max(max_y, y);<br>arr[x + 1][y + 1] +&#x3D; v;<br>}<br>int size &#x3D; max(max_x, max_y) + m + 10;<br>for (int i &#x3D; 1; i &lt;&#x3D; size; i++) {<br>for (int j &#x3D; 1; j &lt;&#x3D; size; j++) {<br>brr[i][j] &#x3D; arr[i][j] + brr[i - 1][j] + brr[i][j - 1] - brr[i - 1][j - 1];<br>}<br>}<br>int ans &#x3D; 0;<br>for (int i &#x3D; 1; i + m &lt;&#x3D; size + 1; i++) {<br>for (int j &#x3D; 1; j + m &lt;&#x3D; size + 1; j++) {<br>int count &#x3D; qian_he(i, j , i + m - 1, j + m - 1);<br>ans &#x3D; max(count, ans);<br>}<br>}<br>cout &lt;&lt; ans;<br>return 0;<br>}<br>####算法一:双指针<br>##1.查找不重复最长子序列(滑动窗口)<br>int ans &#x3D; 0;<br>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i++) {<br>    s[a[i]]++;<br>    while (s[a[i]] &gt; 1) {<br>        s[a[j]]--;<br>        j++;<br>    }<br>    ans &#x3D; max(ans, i - j + 1);<br>}</p><p>##2.找到两个升序数组中和为定值的唯一解<br>for (int i &#x3D; 0, j &#x3D; m - 1; i &lt; n; i++) {<br>    while (j &gt;&#x3D; 0 &amp;&amp; a[i] + b[j] &gt; x) j--;<br>    if (a[i] + b[j] &#x3D;&#x3D; x) cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j;<br>}<br>return 0;</p><p>##3.判断b数列是否为a的子序列<br>#要求:a元素必须中的在b中按相同顺序出现(不要求绝对连续)<br>int i &#x3D; 0;<br>int j &#x3D; 0;<br>while (i &lt; n &amp;&amp; j &lt; m) {<br>    if (a[i] &#x3D;&#x3D; b[j]) i ++;<br>    j ++;<br>}<br>if (i &#x3D;&#x3D; n) cout &lt;&lt; &quot;yes&quot;;<br>else cout &lt;&lt; &quot;no&quot;;</p><p>##4.实现在所给区间的递增(s- &#x3D;i 的传递窗口很好)<br>    for(int i &#x3D; 1,j &#x3D; 1 ; i&lt; M &#x2F; 2 + 1 ; i++){<br>        while(j &lt;&#x3D;  M   &amp;&amp; s  &lt; M){<br>            s +&#x3D; j ;<br>            j ++ ;<br>        }<br>    if(s &#x3D;&#x3D; M &amp;&amp; j - i &gt;&#x3D; 2){<br>        cout&lt;&lt; i &lt;&lt; &#39; &#39;&lt;&lt; j -1 &lt;&lt; &#39;\n&#39;;<br>    }<br>    s -&#x3D; i;  &#x2F;&#x2F;避免重复计算<br>}</p><p>##5.实现在所给区间找到差为定值(数列中含重复元素)<br>int j &#x3D; 0 ;<br>    int r1 &#x3D; 0 ,r2 &#x3D; 0 ;<br>    for(int i &#x3D; 0 ; i &lt;  n ; i ++) {<br>while(r1 &lt; n &amp;&amp; arr[r1] - arr[i] &lt;&#x3D; c) r1 ++;<br>while(r2 &lt; n &amp;&amp; arr[r2] - arr[i] &lt; c ) r2 ++;<br>if(arr[r2] - arr[i] &#x3D;&#x3D; c &amp;&amp; arr[r1 - 1] - arr[i] &#x3D;&#x3D; c &amp;&amp; r1 - 1 &gt;&#x3D; 1) <br>count +&#x3D; r1 - r2;<br>}<br>    printf(&quot;%lld&quot;,count);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing6</title>
      <link href="/2025/11/03/acwing6/"/>
      <url>/2025/11/03/acwing6/</url>
      
        <content type="html"><![CDATA[<p>##练习前缀和和差分的一天<br>##巡视领地(传送门)code:<br>#include<iostream><br>#include<vector><br>#include<algorithm><br>#define int long long<br>using namespace std;<br>signed main() {<br>int n, k;<br>scanf_s(&quot;%lld%lld&quot;, &amp;n, &amp;k);<br>vector<int>  brr(n + 1, 0);<br>for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++) {<br>int p;<br>scanf_s(&quot;%lld&quot;, &amp;p);<br>brr[i] &#x3D; brr[i - 1] + p;<br>}<br>if (k &gt;&#x3D; n - 1) {<br>printf(&quot;0&quot;);<br>return 0;<br>}<br>if (k &#x3D;&#x3D; 0) {<br>printf(&quot;%lld&quot;, brr[n -1]);<br>}<br>int len &#x3D; 0;<br>for (int i &#x3D; 1; i + k &lt;&#x3D; n ; i++) {<br>int tempt &#x3D; brr[i + k -1] - brr[i -1 ];<br>len &#x3D; max(len, tempt);<br>}<br>int result &#x3D; brr[n - 1] - len;<br>printf(&quot;%lld&quot;, result);<br>return 0;<br>}</p><p>##在已知的前缀和区间中找一段连续和为n倍数的最长区间长:<br>使用同余定理:两个前缀和对 n 同余时，它们之间的区间和能被 n 整除。<br>#include<iostream><br>#include<vector><br>#include<algorithm><br>#define int long long<br>using namespace std;<br>const int N &#x3D; 5e4 + 17;<br>vector<int> arr(N, 0);<br>int find_len(int n ) {<br>int max_len &#x3D; 0;<br>vector<int> brr(7, -1);<br>brr[0] &#x3D; 0;<br>for (int i &#x3D; 0; i &lt;&#x3D; n; i++) {<br>int x &#x3D; arr[i] % 7;<br>if (x &lt; 0) x +&#x3D; 7;<br>if (brr[x] &#x3D;&#x3D; -1) {<br>brr[x] &#x3D; i;<br>}else{<br>max_len &#x3D; max(max_len, i - brr[x]);<br>}<br>}<br>return max_len;<br>}<br>signed main() {<br>int n;<br>scanf(&quot;%lld&quot;, &amp;n);<br>int count &#x3D; 0;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>int  p;<br>scanf(&quot;%lld&quot;, &amp;p);<br>arr[i] &#x3D; arr[i - 1] + p;<br>}<br>printf(&quot;%lld&quot;, find_len(n));<br>return 0;<br>}</p><p>##找到和最大子矩阵<br>#include<iostream><br>#include<vector><br>#include<algorithm><br>#define int long long<br>using namespace std;<br>const int N &#x3D; 1017;<br>vector&lt;vector<int>&gt; arr(N, vector<int>(N)),brr(N,vector<int>(N));<br>int n, m, c;<br>void find_len(int i , int j  ) {<br>brr[i][j] &#x3D; brr[i - 1][j] + brr[i][j - 1] - brr[i - 1][j - 1]+arr[i][j];<br>}<br>int find_max(int x1, int y1, int x2, int y2) {<br>return brr[x2][y2] - brr[x2][y1 - 1] - brr[x1 - 1][y2] + brr[x1 -1][y1 -1];<br>}<br>signed main() {<br>scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;c);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>for (int j &#x3D; 1; j &lt;&#x3D; m; j++) {<br>scanf(&quot;%lld&quot;, &amp;arr[i][j]);<br>find_len(i, j);<br>}<br>}<br>int max_da &#x3D; 0;<br>int p &#x3D; 0;<br>int q &#x3D; 0;<br>for (int i &#x3D; 1; i + c - 1 &lt;&#x3D; n; i++) {<br>for (int j &#x3D; 1; j + c - 1 &lt;&#x3D; m; j++) {<br>int x2 &#x3D; i + c - 1;<br>int y2 &#x3D; j + c - 1;<br>int current &#x3D; find_max(i, j, x2, y2);</p><pre><code>if (current &gt; max_da) &#123;max_da = current;p = i;q = j;&#125;&#125;&#125;printf(&quot;%lld %lld&quot;, p, q);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing5</title>
      <link href="/2025/11/02/acwing5/"/>
      <url>/2025/11/02/acwing5/</url>
      
        <content type="html"><![CDATA[<p>###算法一:前缀和(i&#x3D;1适合处理边界)<br>const int N &#x3D; 1e5 + 17;<br>int arr[N], brr[N];<br>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;arr[i]);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) brr[i] +&#x3D; brr[i - 1] + arr[i];<br>while (m--) {<br>scanf(&quot;%d%d&quot;, &amp;l, &amp;r);<br>int x &#x3D; brr[r] - brr[l - 1];<br>}</p><p>####算法二:子矩阵的和<br>&#x2F;&#x2F;计算s[i][j]的方法<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>for (int j &#x3D; 1; j &lt;&#x3D; m; j++) {<br>s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];<br>}<br>}<br>&#x2F;&#x2F;计算(x1,y1)到(x2,y2)子矩阵的方法<br>while (p--) {<br>int x1, y1, x2, y2;<br>scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>printf(&quot;%d&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);<br>}</p><p>###算法三:差分(主要实现简化对目的区间的加减操作)<br>void cha_f(int l, int r, int c) {<br>b[l] +&#x3D; c;<br>b[r + 1] -&#x3D; c;<br>}<br>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);<br>&#x2F;&#x2F;获取差分数组将(转化为a[i] - a[i -1])<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cha_f(i, i, a[i]);<br>while (m--) {<br>int l, r, c;<br>scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);<br>cha_f(l, r, c);<br>}<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) b[i] +&#x3D; b[i - 1];<br>&#x2F;&#x2F;输出原数组</p><p>###算法四:差分矩阵<br>void cha_f(int x1, int y1, int x2, int y2,int c) {<br>b[x1][y1] +&#x3D; c;<br>b[x2 + 1][y1] -&#x3D; c;<br>b[x1][y2 + 1] -&#x3D; c;<br>b[x2 + 1][y2 + 1] +&#x3D; c;<br>}<br>&#x2F;&#x2F;创建差分数组<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>for (int j &#x3D; 1; j &lt;&#x3D; m; j++) {<br>cha_f(i, j, i , j , a[i][j]);<br>}<br>}<br>while (p--) {<br>int x1, y1, x2, y2,c;<br>scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2,&amp;c);<br>cha_f(x1, y1, x2, y2, c);<br>}<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>for (int j &#x3D; 1; j &lt;&#x3D; m; j++) {<br>b[i][j] +&#x3D; b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];<br>}<br>}<br>&#x2F;&#x2F;输出目的子矩阵</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing4</title>
      <link href="/2025/11/01/acwing4/"/>
      <url>/2025/11/01/acwing4/</url>
      
        <content type="html"><![CDATA[<p>###练习二分答案的一天<br>##切割树的长度code:<br>#include<iostream><br>#define int long long<br>using namespace std;<br>const int N &#x3D; 1e6 + 17;<br>int n, m;<br>int arr[N];<br>bool check(int h) {<br>int len &#x3D; 0;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>if (arr[i] &gt; h) len +&#x3D; (arr[i] - h );<br>}<br>return len &gt;&#x3D; m;<br>}<br>signed main() {<br>scanf(&quot;%lld%lld&quot;, &amp;n,&amp;m);<br>int max &#x3D; 0 ;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>scanf(&quot;%lld&quot;, &amp;arr[i]);<br>if (arr[i] &gt; max) max &#x3D; arr[i];<br>}<br>int left &#x3D; 0, right &#x3D; max;<br>while (left + 1 &lt; right) {<br>int mid &#x3D; (left + right) &gt;&gt; 1;<br>if (check(mid))left &#x3D; mid;<br>else right &#x3D; mid;<br>}<br>if (check(right)) {<br>printf(&quot;%lld&quot;, right);<br>}<br>else {<br>printf(&quot;%lld&quot;, left);<br>}<br>return 0;<br>}<br>##切割树的长度code:计算最小差和问题code:<br>#include<iostream><br>#define int long long<br>using namespace std;<br>const int N &#x3D; 1e6 + 17;<br>int n, m;<br>int arr[N];<br>bool check(int h) {<br>int len &#x3D; 0;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>if (arr[i] &gt; h) len +&#x3D; (arr[i] - h );<br>}<br>return len &gt;&#x3D; m;<br>}<br>signed main() {<br>scanf(&quot;%lld%lld&quot;, &amp;n,&amp;m);<br>int max &#x3D; 0 ;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>scanf(&quot;%lld&quot;, &amp;arr[i]);<br>if (arr[i] &gt; max) max &#x3D; arr[i];<br>}<br>int left &#x3D; 0, right &#x3D; max;<br>while (left + 1 &lt; right) {<br>int mid &#x3D; (left + right) &gt;&gt; 1;<br>if (check(mid))left &#x3D; mid;<br>else right &#x3D; mid;<br>}<br>if (check(right)) {<br>printf(&quot;%lld&quot;, right);<br>}<br>else {<br>printf(&quot;%lld&quot;, left);<br>}<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/31/new-skills/"/>
      <url>/2025/10/31/new-skills/</url>
      
        <content type="html"><![CDATA[<p>####进化之路</p><hr><h2 id="title-new-skillsdate-2025-10-31-12-19-44tags"><a href="#title-new-skillsdate-2025-10-31-12-19-44tags" class="headerlink" title="title: new_skillsdate: 2025-10-31 12:19:44tags:"></a>title: new_skills<br>date: 2025-10-31 12:19:44<br>tags:</h2><p>###skill 1 : 重载操作符: operator<br>返回类型 operator 重载运算符(const Range&amp; W) const{<br>return 需要重载的操作<br>}<br>###skil 2: pair排序方式:先排first 再看second;<br>###skil 3:使用cmp实现对map的自定义排序:<br>bool cmp_shen(const pair&lt;int,int&gt; &amp;a,const pair&lt;int ,int &gt; &amp;b) {<br>if (a.second &#x3D;&#x3D;  b.second) {<br>return a.first &lt; b.first;<br>}<br>return a.second &lt; b.second;<br>}<br>map&lt;int, int&gt; arr;<br>for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>int p;<br>cin &gt;&gt; p;<br>arr[i] &#x3D; p;<br>}<br>vector&lt;pair&lt;int, int&gt;&gt; brr(arr.begin(), arr.end());<br>sort(brr.begin(), brr.end(), cmp_shen<br>###skill 3:memset:C++内置函数<br> int arr[100];<br>    memset(arr, 0, sizeof(arr));<br>(指向指针,输入数值 , 空间大小);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/31/luogu1/"/>
      <url>/2025/10/31/luogu1/</url>
      
        <content type="html"><![CDATA[<p>####找一元三次方程解(二分查找)</p><hr><h2 id="title-luogu1date-2025-10-31-12-04-11tags"><a href="#title-luogu1date-2025-10-31-12-04-11tags" class="headerlink" title="title: luogu1date: 2025-10-31 12:04:11tags:"></a>title: luogu1<br>date: 2025-10-31 12:04:11<br>tags:</h2><p>#include<iostream><br>#include<vector><br>#include <iomanip><br>#include<cmath><br>using namespace std;<br>vector<double> arr;<br>double a, b, c, d;<br>double f_x(double x) {<br>    return (a * x * x * x + b * x * x + c * x + d);<br>}<br>vector<double> ef_find() {<br>    for (double i &#x3D; -100; i &lt;&#x3D; 100; i++) {<br>        double left &#x3D; i, right &#x3D; i + 1;<br>        if (fabs(f_x(left)) &#x3D;&#x3D; 0) {<br>            arr.push_back(left);<br>            continue;<br>        }<br>        if (f_x(left) * f_x(right) &lt; 0) {<br>            for (int i &#x3D; 10; i &gt;&#x3D; 0; i--) {<br>                double mid &#x3D; (left + right) &#x2F; 2;<br>                if (f_x(mid) * f_x(left) &gt;&#x3D; 0) left &#x3D; mid;<br>                else right &#x3D; mid;<br>            }<br>            arr.push_back(right);<br>        }<br>        if (arr.size() &#x3D;&#x3D; 3) break;<br>    }<br>    if (fabs(f_x(100) &lt; 1e-8)) {<br>        arr.push_back(100);<br>    }<br>    return arr;<br>}<br>int main() {<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cout &lt;&lt; fixed &lt;&lt; setprecision(2);<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>    arr &#x3D; ef_find();<br>    for (const auto&amp; x : arr) {<br>        cout &lt;&lt; x &lt;&lt; &#39; &#39;;<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing3</title>
      <link href="/2025/10/31/acwing3/"/>
      <url>/2025/10/31/acwing3/</url>
      
        <content type="html"><![CDATA[<p>###算法一:贪心算法:<br>##区间选点:<br>#include<iostream><br>#include<iomanip><br>#include<algorithm><br>using namespace std;</p><p>const int N &#x3D; 1e5 + 17;<br>int n;</p><p>struct Range {<br>int l, r;<br>bool operator&lt; (const Range &amp;W) const {<br>return r &lt; W.r;<br>}<br>}range[N];</p><p>int main() {<br>scanf(&quot;%d&quot;, &amp;n);<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>int l  , r;<br>scanf(&quot;%d%d&quot;, &amp;l, &amp;r);<br>range[i] &#x3D; { l,r };<br>}<br>sort(range, range + n);<br>int res &#x3D; 0, end &#x3D; -2e9;<br>for (int i &#x3D; 0; i &lt; n; i++) {<br>if (range[i].l &gt; end) {<br>res++;<br>end &#x3D; range[i].r;<br>}<br>}<br>cout &lt;&lt; res;<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ackwing2</title>
      <link href="/2025/10/30/acwing2/"/>
      <url>/2025/10/30/acwing2/</url>
      
        <content type="html"><![CDATA[<p>###算法一:二分求立方数(已知求未知)(浮点数)  (实现更加精确的取数)<br>double ef_find(double vaule){<br>    double l &#x3D; -1e6, r &#x3D; 1e6;<br>    while(r - l &gt; 1e-8){<br>        double mid &#x3D; (l + r)&#x2F; 2;<br>        if(mid<em>mid</em>mid &gt;&#x3D; vaule) r &#x3D; mid;<br>        else l &#x3D; mid;<br>    }<br>    return r;<br>}</p><p>###算法二:实现高精度<br>##加法:<br>vector<int> add(vector<int>&amp; arr, vector<int>&amp; brr) {<br>    vector<int> crr;<br>int t &#x3D; 0 ;<br>for(int i &#x3D; 0 ; i&lt;arr.size() || i&lt; brr.size(); i++){<br>if(i&lt; arr.size())  t +&#x3D; arr[i];<br>if(i&lt;brr.size())   t+&#x3D; brr[i];<br>crr.push_back(t%10);<br>t &#x2F;&#x3D; 10;<br>}<br>if(t) crr.push_back(1);  &#x2F;&#x2F;循环后的进位<br>return crr;<br>}<br>&#x2F;&#x2F;实现高精度,利用string实现每一位数字的拷贝<br>vector<int> arr, brr;<br>string a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br>for (int i &#x3D; arr.length()-1; i &gt;&#x3D; 0; i--) arr.push_back(a[i] - &#39;0&#39;);    &#x2F;&#x2F;实现从个位取数存储<br>for (int i &#x3D; arr.length()-1; i &gt;&#x3D; 0; i--) brr.push_back(b[i] - &#39;0&#39;);   &#x2F;&#x2F;实现从个位取数存储<br>auto crr &#x3D; add(arr,brr);  &#x2F;&#x2F;使用push_back计入数据<br>for (int i &#x3D; crr.length()-1;i &gt;&#x3D; 0 ; i--) </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/29/my-blog-is-over/"/>
      <url>/2025/10/29/my-blog-is-over/</url>
      
        <content type="html"><![CDATA[<h2 id="从10月13号到10月29号"><a href="#从10月13号到10月29号" class="headerlink" title="从10月13号到10月29号"></a>从10月13号到10月29号</h2><h2 id="title-my-blog-is-overdate-2025-10-29-21-40-56tags"><a href="#title-my-blog-is-overdate-2025-10-29-21-40-56tags" class="headerlink" title="title: my_blog is overdate: 2025-10-29 21:40:56tags:"></a>title: my_blog is over<br>date: 2025-10-29 21:40:56<br>tags:</h2><p>一直在为进团队准备,所以一直没更新这个my_blog,<br>之后在团队就是学算法了,只有ackwing系列了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwking1</title>
      <link href="/2025/10/29/acwing1/"/>
      <url>/2025/10/29/acwing1/</url>
      
        <content type="html"><![CDATA[<p>##算法一:排序<br>&#x2F;&#x2F;实现快排的算法<br>void quick_sort(int arr[],int l ,int r) {<br>if (l &gt;&#x3D; r) return;  &#x2F;&#x2F;终止条件不要忘记<br>int x &#x3D; arr[l];<br>int i &#x3D; l - 1; int j &#x3D; r + 1;<br>while (i &lt; j) {    &#x2F;&#x2F;控制指针移动<br>do i++; while (arr[i] &lt; x);<br>do j--; while (arr[j] &gt; x);<br>if (i &lt; j)swap(arr[i], arr[j]);<br>}<br>quick_sort(arr, l, j);<br>quick_sort(arr, j+1, r);<br>}(在调用函数时传入r &#x3D;n-1,控制全部范围)<br>(部分时候调用中间值(即x &#x3D; arr[(l+r)&gt;&gt;1])快排会优化最坏(O(nlog(n))))<br>&#x2F;&#x2F;通过快速排序找数字(注意下返回的是数组的元素int)<br>int quick_sort(int arr[],int k ,int l , int r){<br>    if(l&gt;&#x3D;r) return arr[l];<br>    int i &#x3D; l-1;int j &#x3D; r+1;<br>    int x &#x3D; arr[(l+r)&#x2F;2];<br>    while(i&lt;j){<br>        do i++;while(arr[i]&lt;x);<br>        do j--;while(arr[j]&gt;x);<br>        if(i&lt;j) swap(arr[i],arr[j]);<br>    }<br>    int pos &#x3D; j - l + 1;<br>    if(pos&gt;&#x3D;k) return quick_sort(arr,k,l,j);<br>    return quick_sort(arr,k - pos,j+1,r);<br>}<br>##算法二:二分<br>&#x2F;&#x2F;二分查找(最小化(first)) (return right)(满足条件的第一个&gt;&#x3D;)<br>int find1(int value) {<br>int left &#x3D; -1; int right &#x3D; n;<br>while (left + 1 &lt; right) {<br>int mid &#x3D; (left + right) &gt;&gt; 1;<br>if (arr[mid] &gt;&#x3D; value) right &#x3D; mid;   ()<br>else  left &#x3D; mid;<br>}<br>return right;<br>}<br>&#x2F;&#x2F;二分查找(最大化(last)) (return left)(满足条件的最后一个&lt;&#x3D;)<br>int find2(int value) {<br>int left &#x3D; -1; int right &#x3D; n;<br>while (left + 1 &lt; right) {<br>int mid &#x3D; (left + right) &gt;&gt; 1;<br>if (arr[mid] &lt;&#x3D; value) left &#x3D; mid; &#x2F;&#x2F;满足条件的最后一个<br>else right &#x3D; mid;<br>}<br>return left;     (需要返回个数的时候可以控制返回值加一)<br>}<br>##算法三:归并排序 (j++)  (传入的r值为  n - 1) (i 值为 0)<br>&#x2F;&#x2F;归并排序(O(nlog(n)))  (全是&gt;&#x3D;,&lt;&#x3D;)<br>void merge_sort(int arr[], int l, int r) {<br>    if (l &gt;&#x3D; r) return;<br>    int mid &#x3D; (l + r) &gt;&gt; 1;<br>    merge_sort(arr, l, mid); merge_sort(arr, mid + 1, r);<br>    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;<br>    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) {<br>        if (arr[i] &lt;&#x3D; arr[j]) brr[k++] &#x3D; arr[i++];<br>        else brr[k++] &#x3D; arr[j++];<br>    }<br>while (i &lt;&#x3D; mid) brr[k++] &#x3D; arr[i++];<br>    while (j &lt;&#x3D; r) brr[k++] &#x3D; arr[j++];<br>    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i++, j++) {<br>        arr[i] &#x3D; brr[j];   (传值时i&#x3D; l)<br>    }<br>}<br>&#x2F;&#x2F;题目常要求去重<br>&#x2F;*<br> while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) {<br>        if (arr[i] &lt; arr[j]) {<br>            brr[k++] &#x3D; arr[i++];<br>        } else if (arr[i] &gt; arr[j]) {<br>            brr[k++] &#x3D; arr[j++];<br>        } else {<br>            &#x2F;&#x2F; 相等时只添加一个，两个指针都前进<br>            brr[k++] &#x3D; arr[i++];<br>            j++;<br>        }<br>    }<br>*&#x2F;</p><p>&#x2F;&#x2F;逆序对的数量(传入的r值:n-1)<br>int merge_sort(int l, int r) {   &#x2F;&#x2F; 一般数字较大,用long long(#define int long long:输入输出时需要使用lld)<br>    if(l &gt;&#x3D; r) return 0;<br>    int mid &#x3D; (l + r) &gt;&gt; 1;<br>    int res &#x3D; merge_sort(l, mid) + merge_sort(mid + 1, r);<br>    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;<br>    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) {<br>        if(arr[i] &lt;&#x3D; arr[j]) brr[k++] &#x3D; arr[i++];<br>        else {<br>            res +&#x3D; mid - i + 1;<br>            brr[k++] &#x3D; arr[j++];<br>        }<br>    }<br>    while(i &lt;&#x3D; mid) brr[k++] &#x3D; arr[i++];<br>    while(j &lt;&#x3D; r) brr[k++] &#x3D; arr[j++];<br>    for(i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i++, j++) arr[i] &#x3D; brr[j];<br>    return res;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog54</title>
      <link href="/2025/10/13/my-blog54/"/>
      <url>/2025/10/13/my-blog54/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog53</title>
      <link href="/2025/10/13/my-blog53/"/>
      <url>/2025/10/13/my-blog53/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog52</title>
      <link href="/2025/10/13/my-blog52/"/>
      <url>/2025/10/13/my-blog52/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog51</title>
      <link href="/2025/10/10/my-blog51/"/>
      <url>/2025/10/10/my-blog51/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>typedef long long ll ;<br>using namespace std;<br>typedef vector<string>arr;<br>int main(){<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cout.tie(nullptr);<br>    ll n ;<br>    cin&gt;&gt;n;<br>    string mi &#x3D;&quot;&quot;;<br>    arr shuzu;<br>    ll count_L &#x3D; 0, count_E &#x3D; 0, count_C &#x3D; 0, count_W &#x3D; 0;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        string a;<br>        cin &gt;&gt; a;<br>        char first_char &#x3D; a[0];<br>        if (first_char &#x3D;&#x3D; &#39;L&#39;) {<br>            count_L++;<br>        } else if (first_char &#x3D;&#x3D; &#39;E&#39;) {<br>            count_E++;<br>        } else if (first_char &#x3D;&#x3D; &#39;C&#39;) {<br>            count_C++;<br>        } else if (first_char &#x3D;&#x3D; &#39;W&#39;) {<br>            count_W++;<br>        }<br>    }<br>    ll total &#x3D; count_L * count_E * count_C<br>             + count_L * count_E * count_W<br>             + count_L * count_C * count_W<br>             + count_E * count_C * count_W;<br>    cout &lt;&lt; total &lt;&lt; endl;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog50</title>
      <link href="/2025/10/09/my-blog50/"/>
      <url>/2025/10/09/my-blog50/</url>
      
        <content type="html"><![CDATA[<p>int CountDigit(int number, int digit) {<br>    if (number &#x3D;&#x3D; 0 &amp;&amp; digit &#x3D;&#x3D; 0){<br>    return 1;<br>}<br>    int count &#x3D; 0;<br>    long long n &#x3D; number;<br>    if (n &lt; 0) {<br>        n &#x3D; -n;<br>    }<br>    while (n &gt; 0) {<br>        int d &#x3D; n % 10;<br>        if (d &#x3D;&#x3D; digit) {<br>            count++;<br>        }<br>        n &#x2F;&#x3D; 10;<br>    }<br>    return count;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog49</title>
      <link href="/2025/10/09/my-blog49/"/>
      <url>/2025/10/09/my-blog49/</url>
      
        <content type="html"><![CDATA[<p>int narcissistic(int number) {<br>    int a &#x3D; number;<br>    int n &#x3D; 0;<br>    int sum &#x3D; 0;</p><pre><code>int temp = number;while (temp != 0) &#123;    n++;    temp /= 10;&#125;temp = number;while (temp != 0) &#123;    int digit = temp % 10;    sum += pow(digit, n);    temp /= 10;&#125;if (sum == a) &#123;    return 1;&#125; else &#123;    return 0;&#125;</code></pre><p>}</p><p>void PrintN(int m, int n) {<br>    for (int i &#x3D; m + 1; i &lt; n; i++) {<br>        if (narcissistic(i)) {<br>            printf(&quot;%d\n&quot;, i);<br>        }<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog48</title>
      <link href="/2025/10/09/my-blog48/"/>
      <url>/2025/10/09/my-blog48/</url>
      
        <content type="html"><![CDATA[<p>int fn(int a, int n) {<br>    int temp &#x3D; 1;<br>    int arr &#x3D; 0;<br>    while(n &gt; 0) {<br>        arr +&#x3D; a * temp;<br>        temp *&#x3D; 10;<br>        n--;<br>    }<br>    return arr;<br>}</p><p>int SumA(int a, int n) {<br>     static int sum &#x3D; 0;<br>    if(n &#x3D;&#x3D; 0) {<br>        int result &#x3D; sum;<br>        sum &#x3D; 0;<br>        return result;<br>    } else {<br>        sum +&#x3D; fn(a, n);<br>        return SumA(a, n - 1);<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog47</title>
      <link href="/2025/10/09/my-blog47/"/>
      <url>/2025/10/09/my-blog47/</url>
      
        <content type="html"><![CDATA[<p>int reverse(int number) {<br>    if (number &#x3D;&#x3D; 0) return 0;</p><pre><code>long long reversed = 0;int num = (number &lt; 0) ? -number : number;while (num != 0) &#123;    reversed = reversed * 10 + num % 10;    num /= 10; // ← 关键！&#125;if (number &lt; 0) reversed = -reversed;// 检查溢出（如需要）if (reversed &gt; 2147483647 || reversed &lt; -2147483648)     return 0;    return (int)reversed;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog46</title>
      <link href="/2025/10/05/my-blog46/"/>
      <url>/2025/10/05/my-blog46/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n ;<br>    cin&gt;&gt;n;<br>    vector<int> arr(n);<br>    for(int i &#x3D; 0 ; i &lt; n ; i++){<br>        cin&gt;&gt;arr[i];<br>    }<br>    reverse(arr.begin(),arr.end());<br>    for(int j &#x3D; 0 ; j &lt; n ; j++){<br>        cout&lt;&lt;arr[j];<br>        if(j &lt; (n-1)){<br>            cout&lt;&lt;&#39; &#39;;<br>        }<br>    }<br>    return 0 ;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog45</title>
      <link href="/2025/10/05/my-blog45/"/>
      <url>/2025/10/05/my-blog45/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector<int> arr;<br>    for(int i &#x3D; 1 ; i &lt;&#x3D; n; i++){<br>        arr.push_back(i);<br>    }<br>    int wei &#x3D; 0  ;<br>    while(arr.size()&gt;1){<br>        int s &#x3D; (wei+k-1) % arr.size();<br>        arr.erase(arr.begin()+s);<br>        wei &#x3D; s % arr.size();<br>    }<br>    cout&lt;&lt;arr[0];<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog44</title>
      <link href="/2025/10/05/my-blog44/"/>
      <url>/2025/10/05/my-blog44/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    int m,e;<br>    int sum &#x3D; 20;<br>    if((n&gt;0)&amp;&amp;(n&lt;&#x3D;20)){<br>    while(cin&gt;&gt;m&gt;&gt;e){<br>           sum -&#x3D; m ;<br>           if(sum &gt; 0 ){<br>               cout&lt;&lt;&quot;属于你的故事，才刚刚开始&quot;;<br>               break;<br>           } else{<br>        cout&lt;&lt;&quot;此程未果，再战！&quot;;<br>           }<br>        }<br>    }  else{<br>         cout&lt;&lt;&quot;此程未果，再战！&quot;;<br>    }</p><pre><code>return 0 ;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog43</title>
      <link href="/2025/10/02/my-blog43/"/>
      <url>/2025/10/02/my-blog43/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main() {<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    int n;<br>    cin &gt;&gt; n;<br>    vector<long long> even(n), odd(n);<br>    vector<int> len(n);<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        string s;<br>        cin &gt;&gt; s;<br>        len[i] &#x3D; s.size();<br>        for (int j &#x3D; 0; j &lt; s.size(); j++) {<br>            int digit &#x3D; s[j] - &#39;0&#39;;<br>            if (j % 2 &#x3D;&#x3D; 0) even[i] +&#x3D; digit;<br>            else            odd[i]  +&#x3D; digit;<br>        }<br>    }<br>    long long count &#x3D; 0;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        for (int j &#x3D; 0; j &lt; n; j++) {<br>            if (i &#x3D;&#x3D; j) continue;</p><pre><code>        long long total_even, total_odd;        if (len[i] % 2 == 0) &#123;            total_even = even[i] + even[j];            total_odd  = odd[i]  + odd[j];        &#125; else &#123;            total_even = even[i] + odd[j];            total_odd  = odd[i]  + even[j];        &#125;        long long diff = total_odd - total_even;        if (diff % 11 == 0) &#123;            count++;        &#125;    &#125;&#125;cout &lt;&lt; count &lt;&lt; &#39;\n&#39;;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/01/my-blog42/"/>
      <url>/2025/10/01/my-blog42/</url>
      
        <content type="html"><![CDATA[<h2 id="十月一日发"><a href="#十月一日发" class="headerlink" title="十月一日发"></a>十月一日发</h2><h2 id="title-my-blog42date-2025-10-01-15-04-57tags"><a href="#title-my-blog42date-2025-10-01-15-04-57tags" class="headerlink" title="title: my_blog42date: 2025-10-01 15:04:57tags:"></a>title: my_blog42<br>date: 2025-10-01 15:04:57<br>tags:</h2><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    string s,q;<br>    cin&gt;&gt;s&gt;&gt;q;<br>    for (char &amp;c : s) c &#x3D; tolower(c);<br>    for (char &amp;c : q) c &#x3D; tolower(c);<br>    if(s&gt;q) cout&lt;&lt;1;<br>    else if(s&lt;q) cout&lt;&lt;-1;<br>    else cout&lt;&lt;0;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/01/my-blog41/"/>
      <url>/2025/10/01/my-blog41/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月三十日"><a href="#补档九月三十日" class="headerlink" title="补档九月三十日"></a>补档九月三十日</h2><h2 id="title-my-blog41date-2025-10-01-15-04-40tags"><a href="#title-my-blog41date-2025-10-01-15-04-40tags" class="headerlink" title="title: my_blog41date: 2025-10-01 15:04:40tags:"></a>title: my_blog41<br>date: 2025-10-01 15:04:40<br>tags:</h2><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br>int main(){<br>    ll n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    vector&lt;set<int>&gt; arr(k + 1);<br>    for(int i &#x3D; 0; i &lt; n; i++){<br>        for(int j &#x3D; 0; j &lt; m; j++){<br>            int day;<br>            cin &gt;&gt; day;<br>            arr[day].insert(j + 1);<br>        }<br>    }<br>    for(int day &#x3D; 1; day &lt;&#x3D; k; day++){<br>        cout &lt;&lt; arr[day].size();<br>        if(day &lt; k) {<br>            cout &lt;&lt; &quot; &quot;;<br>        }<br>    }<br>    cout &lt;&lt; endl;</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/01/my-blog40/"/>
      <url>/2025/10/01/my-blog40/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月二十九"><a href="#补档九月二十九" class="headerlink" title="补档九月二十九"></a>补档九月二十九</h2><h2 id="title-my-blog40date-2025-10-01-15-04-21tags"><a href="#title-my-blog40date-2025-10-01-15-04-21tags" class="headerlink" title="title: my_blog40date: 2025-10-01 15:04:21tags:"></a>title: my_blog40<br>date: 2025-10-01 15:04:21<br>tags:</h2><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    string str1,str2;<br>    getline(cin,str1);<br>    getline(cin,str2);<br>    for(auto&amp; c : str1 ){<br>        c &#x3D; tolower(static_cast<unsigned char> (c));<br>    }<br>    for(auto&amp; m: str2 ){<br>        m &#x3D; tolower(static_cast<unsigned char> (m));<br>    }<br>    int count &#x3D; -1;<br>    int n &#x3D; 0;<br>    int j &#x3D; 0 ;<br>    int y &#x3D; -1;<br>    int b &#x3D; 0;<br>    for(int i &#x3D; 0; i &lt;&#x3D; (int)(str2.size() - str1.size()); i++) {<br>        if(i &#x3D;&#x3D; 0 || str2[i-1] &#x3D;&#x3D; &#39; &#39;) {<br>            bool match &#x3D; true;<br>            for(n &#x3D; 0; n &lt; (int)str1.size(); n++) {<br>                if(str2[i + n] !&#x3D; str1[n]) {<br>                    match &#x3D; false;<br>                    break;<br>                }<br>            }<br>            if(match &amp;&amp; (i + str1.size() &#x3D;&#x3D; str2.size() || str2[i + str1.size()] &#x3D;&#x3D; &#39; &#39;)) {<br>                b++;<br>                if(b &#x3D;&#x3D; 1) {<br>                    count &#x3D; i;<br>                }<br>            }<br>        }<br>    }</p><pre><code>if(b == 0)&#123;    cout&lt;&lt;-1;&#125;else&#123;    cout&lt;&lt;b&lt;&lt;&#39; &#39;&lt;&lt;count;&#125;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog39</title>
      <link href="/2025/09/28/my-blog39/"/>
      <url>/2025/09/28/my-blog39/</url>
      
        <content type="html"><![CDATA[<p>#include <iostream><br>using namespace std;</p><p>int main() {<br>    long long M;<br>    cin &gt;&gt; M;<br>    long long a &#x3D; 0;<br>    long long b &#x3D; 1;<br>    for (int n &#x3D; 1; n &lt;&#x3D; M * M + 1; n++) {<br>        long long next &#x3D; (a + b) % M;<br>        a &#x3D; b;<br>        b &#x3D; next;<br>        if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 1) {<br>            cout &lt;&lt; n &lt;&lt; endl;<br>            return 0;<br>        }<br>    }<br>    cout &lt;&lt; M * M &lt;&lt; endl;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog38</title>
      <link href="/2025/09/27/my-blog38/"/>
      <url>/2025/09/27/my-blog38/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog37</title>
      <link href="/2025/09/26/my-blog37/"/>
      <url>/2025/09/26/my-blog37/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main() {<br>    vector<string> arr, brr;<br>    string n, x;<br>    while (getline(cin, n) &amp;&amp; n !&#x3D; &quot;EOF&quot;) {<br>        arr.push_back(n);<br>    }<br>    while (getline(cin, x) &amp;&amp; x !&#x3D; &quot;EOF&quot;) {<br>        brr.push_back(x);<br>    }<br>    vector<string> drr;<br>    for (int i &#x3D; 0; i &lt; arr.size(); i++) {<br>        string temp &#x3D; &quot;&quot;;<br>        for (char c : arr[i]) {<br>            if (c &#x3D;&#x3D; &#39;&lt;&#39;) {<br>                if (!temp.empty()) {<br>                    temp.pop_back();<br>                }<br>            } else {<br>                temp.push_back(c);<br>            }<br>        }<br>        drr.push_back(temp);<br>    }<br>    vector<string> crr;<br>    for (int i &#x3D; 0; i &lt; brr.size(); i++) {<br>        string temp &#x3D; &quot;&quot;;<br>        for (char c : brr[i]) {<br>            if (c &#x3D;&#x3D; &#39;&lt;&#39;) {<br>                if (!temp.empty()) {<br>                    temp.pop_back();<br>                }<br>            } else {<br>                temp.push_back(c);<br>            }<br>        }<br>        crr.push_back(temp);<br>    }<br>    int count &#x3D; 0;<br>    int ming &#x3D; min((int)drr.size(), (int)crr.size());<br>    for (int i &#x3D; 0; i &lt; ming; i++) {<br>        int len &#x3D; min((int)drr[i].size(), (int)crr[i].size());<br>        for (int j &#x3D; 0; j &lt; len; j++) {<br>            if (drr[i][j] &#x3D;&#x3D; crr[i][j]) {<br>                count++;<br>            }<br>        }<br>    }<br>    int y;<br>    cin &gt;&gt; y;</p><pre><code>if (y == 0) &#123;    cout &lt;&lt; 0 &lt;&lt; endl;    return 0;&#125;double k = (double)count * 60.0 / y;cout &lt;&lt; (int)round(k) &lt;&lt; endl;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog36</title>
      <link href="/2025/09/25/my-blog36/"/>
      <url>/2025/09/25/my-blog36/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    vector<int> arr;<br>    for(int i &#x3D; 0 ; i &lt; 12 ; i ++){<br>        int j ;<br>        cin&gt;&gt;j;<br>        arr.push_back(j);<br>    }<br>    int sum &#x3D; 300;<br>    int sheng &#x3D; 0;<br>    int cun &#x3D; 0;<br>    int j &#x3D; 1;<br>    for(const auto&amp; c: arr ){<br>         if(sheng + sum &lt; c){<br>            cout&lt;&lt;&#39;-&#39;&lt;&lt; j;<br>            return 0 ;<br>            }<br>        sheng +&#x3D; (sum - c);<br>        if(sheng &gt;&#x3D; 100){<br>            int i &#x3D; sheng &#x2F;100;<br>            sheng -&#x3D; 100 * i;<br>            cun +&#x3D; 100 * i ;<br>            }<br>        j++;<br>    }<br>    int money &#x3D; cun * 6 &#x2F; 5  + sheng;<br>    cout&lt;&lt;money;<br>    return 0 ;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog35</title>
      <link href="/2025/09/24/my-blog35/"/>
      <url>/2025/09/24/my-blog35/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int func(int n, int m){<br>    if(n % m !&#x3D; 0 ){<br>        int count &#x3D; 0;<br>        count &#x3D; n &#x2F; m + 1;<br>        return count;<br>    } else{<br>        int count &#x3D; n &#x2F; m;<br>        return count;<br>    }<br>}<br>int main(){<br>    int n ;<br>    cin&gt;&gt;n;<br>    vector<int> arr,brr;<br>    for(int i &#x3D; 0 ; i &lt; 6; i++){<br>        int a;<br>        cin&gt;&gt;a;<br>        arr.push_back(a);<br>    }<br>    for(int j &#x3D; 0 ; j &lt; 3 ;j++){<br>        int q &#x3D; func(n,arr[2<em>j]);<br>        int sum &#x3D; q * arr[2</em>j+1];<br>        brr.push_back(sum);<br>    }<br>    sort(brr.begin(),brr.end());<br>    cout&lt;&lt;brr[0];<br>    return 0 ;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog34/"/>
      <url>/2025/09/23/my-blog34/</url>
      
        <content type="html"><![CDATA[<h2 id="九月二十三"><a href="#九月二十三" class="headerlink" title="九月二十三"></a>九月二十三</h2><h2 id="title-my-blog34date-2025-09-23-22-25-23tags"><a href="#title-my-blog34date-2025-09-23-22-25-23tags" class="headerlink" title="title: my-blog34date: 2025-09-23 22:25:23tags:"></a>title: my-blog34<br>date: 2025-09-23 22:25:23<br>tags:</h2><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef string str;<br>int main() {<br>str a, b;<br>getline(cin, a);<br>getline(cin, b);<br>bool stl[1000] &#x3D; { false };<br>for (char c : b) {<br>stl[(unsigned char)c] &#x3D; true;<br>}<br>for (char c : a) {<br>if (!stl[(unsigned char)c]) {<br>cout &lt;&lt; c;<br>}<br>}<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog33/"/>
      <url>/2025/09/23/my-blog33/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月二十二"><a href="#补档九月二十二" class="headerlink" title="补档九月二十二"></a>补档九月二十二</h2><h2 id="title-my-blog33date-2025-09-23-22-25-03tags"><a href="#title-my-blog33date-2025-09-23-22-25-03tags" class="headerlink" title="title: my-blog33date: 2025-09-23 22:25:03tags:"></a>title: my-blog33<br>date: 2025-09-23 22:25:03<br>tags:</h2><p>#include <iostream><br>#include <iomanip><br>#include <vector><br>#include <string><br>using namespace std;</p><p>struct People {<br>    string name;<br>    float qian0;<br>    float qian1;<br>    float hua;<br>    float qian2() {<br>        return qian0 + qian1 - hua;<br>    }<br>};</p><p>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    vector<People> peoples(n);<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        cin &gt;&gt; peoples[i].name<br>            &gt;&gt; peoples[i].qian0<br>            &gt;&gt; peoples[i].qian1<br>            &gt;&gt; peoples[i].hua;<br>    }<br>    cout &lt;&lt; fixed &lt;&lt; setprecision(2);<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        cout &lt;&lt; peoples[i].name &lt;&lt; &quot; &quot; &lt;&lt; peoples[i].qian2() &lt;&lt; endl;<br>    }</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog32/"/>
      <url>/2025/09/23/my-blog32/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月二十一"><a href="#补档九月二十一" class="headerlink" title="补档九月二十一"></a>补档九月二十一</h2><h2 id="title-my-blog32date-2025-09-23-22-24-55tags"><a href="#title-my-blog32date-2025-09-23-22-24-55tags" class="headerlink" title="title: my-blog32date: 2025-09-23 22:24:55tags:"></a>title: my-blog32<br>date: 2025-09-23 22:24:55<br>tags:</h2><p>#include <iostream><br>#include <vector><br>#include <string><br>using namespace std;<br>struct Student {<br>    string id, name;<br>    int scores[3];</p><pre><code>int total() &#123;    return scores[0] + scores[1] + scores[2];&#125;</code></pre><p>};<br>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    vector&lt; Student &gt; students(n);<br>    int max &#x3D; 0;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        cin &gt;&gt; students[i].id &gt;&gt; students[i].name;<br>        for (int j &#x3D; 0; j &lt; 3; j++) {<br>            cin &gt;&gt; students[i].scores[j];<br>        }<br>        if (students[i].total() &gt; students[max].total()) {<br>            max &#x3D; i;<br>        }<br>    }</p><pre><code>cout &lt;&lt; students[max].name &lt;&lt; &quot; &quot;      &lt;&lt; students[max].id &lt;&lt; &quot; &quot;      &lt;&lt; students[max].total() &lt;&lt; endl;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog31/"/>
      <url>/2025/09/23/my-blog31/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月二十"><a href="#补档九月二十" class="headerlink" title="补档九月二十"></a>补档九月二十</h2><h2 id="title-my-blog31date-2025-09-23-22-24-28tags"><a href="#title-my-blog31date-2025-09-23-22-24-28tags" class="headerlink" title="title: my-blog31date: 2025-09-23 22:24:28tags:"></a>title: my-blog31<br>date: 2025-09-23 22:24:28<br>tags:</h2><p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef vector&lt;vector<long long>&gt; a;<br>int main() {<br>    a arr(4, vector<long long>(5));<br>    for(int i &#x3D; 0; i &lt; 4; i++) {<br>        for(int j &#x3D; 0; j &lt; 5; j++) {<br>            cin &gt;&gt; arr[i][j];<br>        }<br>    }<br>    for(int j &#x3D; 0; j &lt; 5; j++) {<br>        for(int k &#x3D; 0; k &lt; 3; k++) {<br>            for(int i &#x3D; 0; i &lt; 3 - k; i++) {<br>                if(arr[i][j] &gt; arr[i+1][j]) {<br>                    long long tempt &#x3D; arr[i][j];<br>                    arr[i][j] &#x3D; arr[i+1][j];<br>                    arr[i+1][j] &#x3D; tempt;<br>                }<br>            }<br>        }<br>    }<br>    for(int i &#x3D; 0; i &lt; 4; i++) {<br>        for(int j &#x3D; 0; j &lt; 5; j++) {<br>            cout &lt;&lt; setw(4) &lt;&lt; arr[i][j];<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog30/"/>
      <url>/2025/09/23/my-blog30/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月十九"><a href="#补档九月十九" class="headerlink" title="补档九月十九"></a>补档九月十九</h2><h2 id="title-my-blog30date-2025-09-23-22-22-53tags"><a href="#title-my-blog30date-2025-09-23-22-22-53tags" class="headerlink" title="title: my-blog30date: 2025-09-23 22:22:53tags:"></a>title: my-blog30<br>date: 2025-09-23 22:22:53<br>tags:</h2><p>#include <iostream><br>#include <vector><br>#include <cmath><br>using namespace std;</p><p>const double q &#x3D; 1e-10;</p><p>bool func1(vector<double>&amp; arr) {<br>    if (arr.size() &#x3D;&#x3D; 1) {<br>        return fabs(arr[0] - 24) &lt; q;<br>    }</p><pre><code>int n = arr.size();for (int i = 0; i &lt; n; i++) &#123;    for (int j = i + 1; j &lt; n; j++) &#123;        double a = arr[i], b = arr[j];        vector&lt;double&gt; next;        for (int k = 0; k &lt; n; k++) &#123;            if (k != i &amp;&amp; k != j) &#123;                next.push_back(arr[k]);            &#125;        &#125;        vector&lt;double&gt; brr = &#123;a + b, a - b, b - a, a * b&#125;;        if (fabs(b) &gt; q) brr.push_back(a / b);        if (fabs(a) &gt; q) brr.push_back(b / a);        for (const auto&amp; v : brr) &#123;            next.push_back(v);            if (func1(next)) &#123;                return true;            &#125;            next.pop_back();        &#125;    &#125;&#125;return false;</code></pre><p>}</p><p>bool func(vector<int>&amp; nums) {<br>    vector<double> arr(nums.begin(), nums.end());<br>    return func1(arr);<br>}</p><p>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    bool first &#x3D; true;</p><pre><code>while (n &gt; 0) &#123;    vector&lt;int&gt; nums(4);    for (int i = 0; i &lt; 4; i++) &#123;        cin &gt;&gt; nums[i];    &#125;        if (!first) cout &lt;&lt; &quot; &quot;;    first = false;    if (func(nums)) &#123;        cout &lt;&lt; &quot;True&quot;;    &#125; else &#123;        cout &lt;&lt; &quot;False&quot;;    &#125;    n--;&#125;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog29/"/>
      <url>/2025/09/23/my-blog29/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月十八"><a href="#补档九月十八" class="headerlink" title="补档九月十八"></a>补档九月十八</h2><h2 id="title-my-blog29date-2025-09-23-22-22-14tags"><a href="#title-my-blog29date-2025-09-23-22-22-14tags" class="headerlink" title="title: my-blog29date: 2025-09-23 22:22:14tags:"></a>title: my-blog29<br>date: 2025-09-23 22:22:14<br>tags:</h2><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;</p><p>void func(vector<string> arr, int n, int m) {<br>    for(int i &#x3D; 0; i &lt; n; i +&#x3D; 2) {<br>        cout &lt;&lt; arr[i] &lt;&lt; &#39;\n&#39;;<br>    }<br>    int start &#x3D; n - 1;<br>    if (n % 2 &#x3D;&#x3D; 1) {<br>        start &#x3D; n - 2;<br>    }</p><pre><code>for(int i = start; i &gt;= 0; i -= 2) &#123;    cout &lt;&lt; arr[i] &lt;&lt; &#39;\n&#39;;&#125;</code></pre><p>}</p><p>int main() {<br>    int n &#x3D; 1;<br>    int count &#x3D; 1;</p><pre><code>while (cin &gt;&gt; n &amp;&amp; n != 0) &#123;    vector&lt;string&gt; arr;        for(int i = 0; i &lt; n; i++) &#123;        string str;        cin &gt;&gt; str;        arr.push_back(str);    &#125;    cout &lt;&lt; &quot;SET &quot; &lt;&lt; count &lt;&lt; &#39;\n&#39;;    func(arr, n, 0);    count++;&#125;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/23/my-blog28/"/>
      <url>/2025/09/23/my-blog28/</url>
      
        <content type="html"><![CDATA[<h2 id="补档九月十七"><a href="#补档九月十七" class="headerlink" title="补档九月十七"></a>补档九月十七</h2><h2 id="title-my-blog28date-2025-09-23-22-06-00tags"><a href="#title-my-blog28date-2025-09-23-22-06-00tags" class="headerlink" title="title: my-blog28date: 2025-09-23 22:06:00tags:"></a>title: my-blog28<br>date: 2025-09-23 22:06:00<br>tags:</h2><p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>void hanoi(int n, char a, char b, char c) {<br>    if (n &#x3D;&#x3D; 1) {<br>        cout &lt;&lt; a &lt;&lt; &quot;--&gt;&quot; &lt;&lt; b &lt;&lt; endl;<br>        return;<br>    }<br>    hanoi(n - 1, a, c, b);<br>    cout &lt;&lt; a &lt;&lt; &quot;--&gt;&quot; &lt;&lt; b &lt;&lt; endl;<br>    hanoi(n - 1, c, b, a);<br>}</p><p>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    hanoi(n, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;);<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog27</title>
      <link href="/2025/09/16/my-blog27/"/>
      <url>/2025/09/16/my-blog27/</url>
      
        <content type="html"><![CDATA[<p>#include <iostream><br>#include <vector><br>#include <string><br>using namespace std;<br>struct Student {<br>    string id, name;<br>    int scores[3];</p><pre><code>int total() &#123;    return scores[0] + scores[1] + scores[2];&#125;</code></pre><p>};<br>int main() {<br>    int n;<br>    cin &gt;&gt; n;<br>    vector<Student> students(n);<br>    int max &#x3D; 0;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        cin &gt;&gt; students[i].id &gt;&gt; students[i].name;<br>        for (int j &#x3D; 0; j &lt; 3; j++) {<br>            cin &gt;&gt; students[i].scores[j];<br>        }<br>        if (students[i].total() &gt; students[max].total()) {<br>            max &#x3D; i;<br>        }<br>    }</p><pre><code>cout &lt;&lt; students[max].name &lt;&lt; &quot; &quot;      &lt;&lt; students[max].id &lt;&lt; &quot; &quot;      &lt;&lt; students[max].total() &lt;&lt; endl;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog26</title>
      <link href="/2025/09/15/my-blog26/"/>
      <url>/2025/09/15/my-blog26/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br>int main() {<br>    int t;<br>    cin &gt;&gt; t;<br>    while (t--) {<br>        int n;<br>        cin &gt;&gt; n;<br>        vector<ll> arr;<br>        for (int i &#x3D; 0; i &lt; n; i++) {<br>            ll shi;<br>            cin &gt;&gt; shi;<br>            arr.push_back(shi);<br>        }<br>        string s;<br>        cin &gt;&gt; s;<br>        vector<int> brr, crr;<br>        for (int i &#x3D; 0; i &lt; n; i++) {<br>            if (s[i] &#x3D;&#x3D; &#39;L&#39;) {<br>                brr.push_back(i);<br>            } else if (s[i] &#x3D;&#x3D; &#39;R&#39;) {<br>                crr.push_back(i);<br>            }<br>        }<br>        vector<ll> drr(n + 1, 0);<br>        for (int i &#x3D; 0; i &lt; n; i++) {<br>            drr[i + 1] &#x3D; drr[i] + arr[i];<br>        }<br>        ll sum &#x3D; 0;<br>        int count &#x3D; min(brr.size(), crr.size());<br>        sort(brr.begin(), brr.end());<br>        sort(crr.begin(), crr.end());<br>        for (int i &#x3D; 0; i &lt; count; i++) {<br>            int L &#x3D; brr[i];<br>            int R &#x3D; crr[crr.size() - 1 - i];<br>            if (L &lt; R) {<br>                ll num &#x3D; drr[R + 1] - drr[L];<br>                sum +&#x3D; num;<br>            } else {<br>                break;<br>            }<br>        }<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog25</title>
      <link href="/2025/09/14/my-blog25/"/>
      <url>/2025/09/14/my-blog25/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;</p><p>int main() {<br>    string s;<br>    cin &gt;&gt; s;<br>    string d;<br>    int a_count &#x3D; 0;</p><pre><code>for (char c : s) &#123;    if (c == &#39;a&#39;) &#123;        a_count++;    &#125; else &#123;        d += c;    &#125;&#125;string com;int add = 0;if (!d.empty()) &#123;    com += d[0];    int group = 1;        for (int i = 1; i &lt; d.size(); i++) &#123;        if (d[i] == d[i-1]) &#123;            group++;        &#125; else &#123;            if (group &gt; 1) &#123;                add++;            &#125;            com += d[i];            group = 1;        &#125;    &#125;    if (group &gt; 1) &#123;        add++;    &#125;&#125;string result = com + string(a_count, &#39;a&#39;) + string(add, &#39;a&#39;);cout &lt;&lt; result &lt;&lt; endl;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog24</title>
      <link href="/2025/09/14/my-blog24/"/>
      <url>/2025/09/14/my-blog24/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef string str;<br>int main() {<br>str a, b;<br>getline(cin, a);<br>getline(cin, b);<br>bool stl[1000] &#x3D; { false };<br>for (char c : b) {<br>stl[(unsigned char)c] &#x3D; true;<br>}<br>for (char c : a) {<br>if (!stl[(unsigned char)c]) {<br>cout &lt;&lt; c;<br>}<br>}<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog23</title>
      <link href="/2025/09/12/my-blog23/"/>
      <url>/2025/09/12/my-blog23/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>typedef vector<int>arr;<br>int main(){<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cout.tie(nullptr);<br>    int N;<br>    cin&gt;&gt;N;<br>    arr ptr;<br>    for(int i &#x3D; 0;i &lt; 2<em>N; i++){<br>        int a;<br>        cin&gt;&gt;a;<br>        ptr.push_back(a);<br>    }<br>    int sum &#x3D; 0;<br>    for(int j &#x3D; 0; j &lt; N; j++){<br>        int n  &#x3D; ptr[2</em>j+1]&#x2F;ptr[2<em>j];<br>        sum &#x3D; ptr[2</em>j+1] - n;<br>        cout&lt;&lt;sum&lt;&lt;&quot;\n&quot;;<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog22</title>
      <link href="/2025/09/12/my-blog22/"/>
      <url>/2025/09/12/my-blog22/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;bits&#x2F;stdc++.h&gt;<br>typedef long long ll ;<br>using namespace std;<br>typedef vector<string> arr;</p><p>int main(){<br>    ios::sync_with_stdio(false);<br>    cin.tie(nullptr);<br>    cout.tie(nullptr);<br>    ll n ;<br>    cin&gt;&gt;n;<br>    string mi &#x3D;&quot;&quot;;<br>    arr shuzu;<br>    ll count_L &#x3D; 0, count_E &#x3D; 0, count_C &#x3D; 0, count_W &#x3D; 0;<br>    for (int i &#x3D; 0; i &lt; n; i++) {<br>        string a;<br>        cin &gt;&gt; a;<br>        char first_char &#x3D; a[0];<br>        if (first_char &#x3D;&#x3D; &#39;L&#39;) {<br>            count_L++;<br>        } else if (first_char &#x3D;&#x3D; &#39;E&#39;) {<br>            count_E++;<br>        } else if (first_char &#x3D;&#x3D; &#39;C&#39;) {<br>            count_C++;<br>        } else if (first_char &#x3D;&#x3D; &#39;W&#39;) {<br>            count_W++;<br>        }<br>    }<br>    ll total &#x3D; count_L * count_E * count_C<br>             + count_L * count_E * count_W<br>             + count_L * count_C * count_W<br>             + count_E * count_C * count_W;<br>    cout &lt;&lt; total &lt;&lt; endl;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog21</title>
      <link href="/2025/09/12/my-blog21/"/>
      <url>/2025/09/12/my-blog21/</url>
      
        <content type="html"><![CDATA[<p>三天邪修C++<br>#include&lt;bits&#x2F;stdc++.h&gt;<br>typedef  long long  ll;</p><p>using namespace std;</p><p>int main(){<br>    ll n;<br>    cin&gt;&gt;n;<br>    for(int i &#x3D; 0; i &lt; n; i++) {<br>        char str[5];<br>        scanf(&quot;%s&quot;,str);<br>        ll sec &#x3D; 0;<br>        int current &#x3D; 0;<br>        int count &#x3D; 0;  </p><pre><code>    for(char c : str) &#123;          if(count &gt;= 4) break;          int target = c - &#39;0&#39;;        sec += abs(target - current);         sec++;         current = target;        count++;      &#125;    printf(&quot;%lld\n&quot;,sec);&#125;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog20</title>
      <link href="/2025/09/09/my-blog20/"/>
      <url>/2025/09/09/my-blog20/</url>
      
        <content type="html"><![CDATA[<p>#include<algorithm><br>#include<iostream><br>using namespace std;<br>int main(){<br>    vector<int>arr;<br>    for(int i &#x3D; 0;i &lt; 3; i++){<br>        int num;<br>        cin&gt;&gt;num;<br>        arr.push_back(num);<br>    }<br>    sort(arr.begin(),arr.end());<br>    cout&lt;&lt;arr[0]&lt;&lt;&quot;-&gt;&quot;&lt;&lt;arr[1]&lt;&lt;&quot;-&gt;&quot;&lt;&lt;arr[2];  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-blog19</title>
      <link href="/2025/09/08/my-blog19/"/>
      <url>/2025/09/08/my-blog19/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;</p><p>int main() {<br>    int n;<br>    float life &#x3D; 10.0;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    float total_exp &#x3D; 0.0;<br>    int valid_operations &#x3D; n;  </p><pre><code>for (int i = 0; i &lt; n; i++) &#123;    float x, a;    scanf(&quot;%f %f&quot;, &amp;x, &amp;a);    if (life &lt;= 0) &#123;        valid_operations = i;        break;    &#125;    life -= x;    if (life &gt; 10.0) &#123;        life = 10.0;    &#125;    if (life &lt; 0.0) &#123;        life = 0.0;    &#125;            if (life &gt; 0 &amp;&amp; a &gt; 0) &#123;        total_exp += a;    &#125;&#125;int level = 0;double remain = total_exp;while (remain&gt;= pow(2, level)) &#123;    remain -= pow(2, level);    level++;&#125;printf(&quot;%d %.0lf\n&quot;, level, remain);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/07/my-blog18/"/>
      <url>/2025/09/07/my-blog18/</url>
      
        <content type="html"><![CDATA[<h2 id="四叶玫瑰花"><a href="#四叶玫瑰花" class="headerlink" title="四叶玫瑰花"></a>四叶玫瑰花</h2><h2 id="title-my-blog18date-2025-09-07-15-44-19tags"><a href="#title-my-blog18date-2025-09-07-15-44-19tags" class="headerlink" title="title: my-blog18date: 2025-09-07 15:44:19tags:"></a>title: my-blog18<br>date: 2025-09-07 15:44:19<br>tags:</h2><p>int func(int n);<br>int main(){<br>    int n;<br>    int arr[5];<br>    scanf(&quot;%d&quot;,&amp;n);<br>    int b[n];<br>    int cnt &#x3D; 0;<br>    for(int j &#x3D; 1000;j &lt;&#x3D; n ; j++){<br>        int k &#x3D; j;<br>        for(int i &#x3D; 0; i &lt;&#x3D; 4;i++){<br>            arr[i] &#x3D; k % 10;<br>            k &#x3D; k &#x2F; 10;<br>        }<br>    int sum;<br>    sum &#x3D; func(arr[0])+func(arr[1])+func(arr[2])+func(arr[3])+func(arr[4]);<br>    if(sum &#x3D;&#x3D; j){<br>        b[cnt] &#x3D; j;<br>        cnt++;<br>    }</p><pre><code>&#125;for(int i= 0;i&lt;cnt; i++)&#123;    printf(&quot;%d&quot;,b[i]);    if(i != cnt-1)&#123;        printf(&quot; &quot;);    &#125;&#125;return 0;</code></pre><p>}</p><p>int func(int n){<br>    return n<em>n</em>n*n;<br>}</p><p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>int main(){<br>    long long count &#x3D;0;<br>    long long total &#x3D;0;<br>    char a[100001];<br>    scanf(&quot;%s&quot;,&amp;a);<br>    int n &#x3D; strlen(a);<br>    for(int i &#x3D; 0; i &lt; n; i++){<br>        if(a[i] &#x3D;&#x3D; &#39;1&#39;){<br>            count++;<br>        } else{<br>            total +&#x3D; count*(count+1)&#x2F;2;<br>            count &#x3D; 0;<br>      }<br>    }<br>    total +&#x3D; count*(count+1)&#x2F;2;<br>    printf(&quot;%lld&quot;,total);<br>    return 0 ;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog17</title>
      <link href="/2025/09/06/my-blog17/"/>
      <url>/2025/09/06/my-blog17/</url>
      
        <content type="html"><![CDATA[<p>计算奇数和偶数个数<br>#include&lt;stdio.h&gt;<br>int main(){<br>    int n ;<br>    int count1 &#x3D; 0;<br>    int count2 &#x3D; 0;<br>    int arr[1000];<br>scanf(&quot;%d&quot;,&amp;n);<br>for(int i &#x3D; 0;i&lt;n;i++){<br>    scanf(&quot;%d&quot;,&amp;arr[i]);<br>    if(arr[i]%2&#x3D;&#x3D;1){<br>        count1++;<br>    }<br>    else{<br>        count2++;<br>    }<br>}<br>printf(&quot;%d %d&quot;,count1,count2);<br>    return 0;</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog16</title>
      <link href="/2025/09/06/my-blog16/"/>
      <url>/2025/09/06/my-blog16/</url>
      
        <content type="html"><![CDATA[<p>补发一下 昨天的<br>#include &lt;stdio.h&gt;</p><p>int main() {<br>    int num;<br>    scanf(&quot;%d&quot;, &amp;num);<br>    int hundreds &#x3D; num &#x2F; 100;<br>    int tens &#x3D; (num &#x2F; 10) % 10;<br>    int units &#x3D; num % 10;<br>    int reversed &#x3D; units * 100 + tens * 10 + hundreds;<br>    printf(&quot;%d\n&quot;, reversed);</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog15</title>
      <link href="/2025/09/03/my-blog15/"/>
      <url>/2025/09/03/my-blog15/</url>
      
        <content type="html"><![CDATA[<p>九九乘法表</p><p>#include &lt;stdio.h&gt;<br>int main() {<br>    int n;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        for (int j &#x3D; 1; j &lt;&#x3D; i; j++) {<br>            printf(&quot;%d*%d&#x3D;%-4d&quot;, j, i, j * i);<br>        }<br>        printf(&quot;\n&quot;);<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog14</title>
      <link href="/2025/09/02/my-blog14/"/>
      <url>/2025/09/02/my-blog14/</url>
      
        <content type="html"><![CDATA[<p>找出水仙花数并从小到大打印<br>#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;</p><p>int narcissistic(int number) {<br>    int a &#x3D; number;<br>    int n &#x3D; 0;<br>    int sum &#x3D; 0;</p><pre><code>int temp = number;while (temp != 0) &#123;    n++;    temp /= 10;&#125;temp = number;while (temp != 0) &#123;    int digit = temp % 10;    sum += pow(digit, n);    temp /= 10;&#125;if (sum == a) &#123;    return 1;&#125; else &#123;    return 0;&#125;</code></pre><p>}</p><p>void PrintN(int m, int n) {<br>    for (int i &#x3D; m + 1; i &lt; n; i++) {<br>        if (narcissistic(i)) {<br>            printf(&quot;%d\n&quot;, i);<br>        }<br>    }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog13</title>
      <link href="/2025/09/01/my-blog13/"/>
      <url>/2025/09/01/my-blog13/</url>
      
        <content type="html"><![CDATA[<p>int CountDigit(int number, int digit) {<br>    if (number &#x3D;&#x3D; 0 &amp;&amp; digit &#x3D;&#x3D; 0){<br>    return 1;<br>}<br>    int count &#x3D; 0;<br>    long long n &#x3D; number;<br>    if (n &lt; 0) {<br>        n &#x3D; -n;<br>    }<br>    while (n &gt; 0) {<br>        int d &#x3D; n % 10;<br>        if (d &#x3D;&#x3D; digit) {<br>            count++;<br>        }<br>        n &#x2F;&#x3D; 10;<br>    }<br>    return count;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog12</title>
      <link href="/2025/08/31/my-blog12/"/>
      <url>/2025/08/31/my-blog12/</url>
      
        <content type="html"><![CDATA[<p>public class my_blog12{<br>  public static void main(String[] args){<br>  System.out.println(&quot;Hello Wrold&quot;);<br>  }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my_blog11</title>
      <link href="/2025/08/30/my-blog11/"/>
      <url>/2025/08/30/my-blog11/</url>
      
        <content type="html"><![CDATA[<p>开始学习java<br>public class my_blog11{<br>  public static void main(String[] args){<br>  System.out.println(&quot;你好时间&quot;);<br>  }<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog 10</title>
      <link href="/2025/08/29/blog-10/"/>
      <url>/2025/08/29/blog-10/</url>
      
        <content type="html"><![CDATA[<p>计算素数和素数和：<br>#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;</p><p>int prime(int p) {<br>    if (p &lt; 2) return 0;<br>    if (p &#x3D;&#x3D; 2) return 1;<br>    if (p % 2 &#x3D;&#x3D; 0) return 0; </p><pre><code>int limit = (int)sqrt(p);for (int i = 3; i &lt;= limit; i += 2) &#123;    if (p % i == 0) &#123;        return 0;    &#125;&#125;return 1;</code></pre><p>}</p><p>int PrimeSum(int m, int n) {<br>    int sum &#x3D; 0;<br>    for (int i &#x3D; m; i &lt;&#x3D; n; i++) {<br>        if (prime(i)) {<br>            sum +&#x3D; i;<br>        }<br>    }<br>    return sum;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog 9</title>
      <link href="/2025/08/28/blog-9/"/>
      <url>/2025/08/28/blog-9/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;&#x2F;冒泡排序<br>void func1(int arr[], int n) {<br>int i, j;<br>for (i &#x3D; 0; i &lt; n - 1; i++) {<br>for (j &#x3D; 0; j &lt; n - 1 - i; j++) {<br>if (arr[j] &gt; arr[j + 1]) {<br>int num &#x3D; arr[j];<br>arr[j] &#x3D; arr[j+1];<br>arr[j + 1] &#x3D; num;<br>}<br>}<br>}<br>}</p><p>&#x2F;&#x2F;二分查找<br>int func2(int n, int arr[],int x) {<br>int left &#x3D; 0;<br>int right &#x3D; n - 1;<br>while (left &lt;&#x3D; right) {<br>int mid &#x3D; left +(right - left) &#x2F; 2;<br>if (arr[mid] &#x3D;&#x3D; x) {<br>return mid;<br>}<br>else if (arr[mid] &lt; x) {<br>left &#x3D; mid + 1;<br>}<br>else right &#x3D; mid - 1;<br>}<br>return -1;<br>}</p><p>&#x2F;&#x2F;希尔排序<br>void func3(int arr[], int n) {<br>int i, j, num,gap;<br>for (gap &#x3D; n &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2) {<br>for (i &#x3D; gap; i&lt;n; i++) {<br>num &#x3D; arr[i];<br>for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; num &lt; arr[j - gap]; j -&#x3D; gap) {<br>arr[j] &#x3D; arr[j - gap];<br>}<br>arr[j] &#x3D; num;<br>}<br>}<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my blog 8</title>
      <link href="/2025/08/27/my-blog-8/"/>
      <url>/2025/08/27/my-blog-8/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;stdio.h&gt;</p><p>int main() {<br>    int apples[10];  &#x2F;&#x2F; 存储10个苹果的高度<br>    int tao_height;  &#x2F;&#x2F; 陶陶的伸手高度<br>    int count &#x3D; 0;   &#x2F;&#x2F; 能够摘到的苹果数量</p><pre><code>// 读取10个苹果的高度for(int i = 0; i &lt; 10; i++) &#123;    scanf(&quot;%d&quot;, &amp;apples[i]);&#125;// 读取陶陶的伸手高度scanf(&quot;%d&quot;, &amp;tao_height);// 计算陶陶能够到的高度（加上板凳高度）int reach_height = tao_height + 30;// 统计能够摘到的苹果数量for(int i = 0; i &lt; 10; i++) &#123;    if(apples[i] &lt;= reach_height) &#123;        count++;    &#125;&#125;// 输出结果printf(&quot;%d\n&quot;, count);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my blog 7</title>
      <link href="/2025/08/26/my-blog-7/"/>
      <url>/2025/08/26/my-blog-7/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>int arr2(int k,int i ,double j){<br>    if(j&gt;k){<br>       return i-1;<br>    }<br>        return arr2(k,i+1,j + 1.0&#x2F;i);<br>    }<br>int main(){<br>    int k ;<br>    scanf(&quot;%d&quot;,&amp;k);<br>    int s &#x3D; arr2(k,1,0.0);<br>    printf(&quot;%d&quot;,s);<br>     return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog 6</title>
      <link href="/2025/08/25/blog-6/"/>
      <url>/2025/08/25/blog-6/</url>
      
        <content type="html"><![CDATA[<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;</p><p>#define MAX_NAME_LENGTH 50<br>#define MAX_NAMES 100000</p><p>typedef struct {<br>    char name[MAX_NAME_LENGTH];<br>    int count;<br>} Child;</p><p>Child children[MAX_NAMES];<br>int child_count &#x3D; 0;<br>int find_or_add_child(const char *name) {<br>    for (int i &#x3D; 0; i &lt; child_count; i++) {<br>        if (strcmp(children[i].name, name) &#x3D;&#x3D; 0) {<br>            return i;<br>        }<br>    }<br>    strcpy(children[child_count].name, name);<br>    children[child_count].count &#x3D; 0;<br>    return child_count++;<br>}</p><p>int main() {<br>    int n;<br>    scanf(&quot;%d&quot;, &amp;n);</p><pre><code>int total = 0;int ans = 0;for (int i = 0; i &lt; n; i++) &#123;    char name[MAX_NAME_LENGTH];    scanf(&quot;%s&quot;, name);        int idx = find_or_add_child(name);        if (children[idx].count &gt; total - children[idx].count) &#123;        ans++;    &#125;        children[idx].count++;    total++;&#125;printf(&quot;%d\n&quot;, ans);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog   5</title>
      <link href="/2025/08/24/blog5/"/>
      <url>/2025/08/24/blog5/</url>
      
        <content type="html"><![CDATA[<p>include &lt;stdio.h&gt;<br>#include &lt;stdbool.h&gt;</p><p>int main() {<br>    int n, m, horse_x, horse_y;<br>    scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;horse_x, &amp;horse_y);</p><pre><code>// 马的控制点偏移量int dx[] = &#123;1, 1, -1, -1, 2, 2, -2, -2, 0&#125;;int dy[] = &#123;2, -2, 2, -2, 1, -1, 1, -1, 0&#125;;// 创建障碍物网格bool obstacle[n + 1][m + 1];for (int i = 0; i &lt;= n; i++) &#123;    for (int j = 0; j &lt;= m; j++) &#123;        obstacle[i][j] = false;    &#125;&#125;// 标记马的控制点为障碍物for (int i = 0; i &lt; 9; i++) &#123;    int nx = horse_x + dx[i];    int ny = horse_y + dy[i];    if (nx &gt;= 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt;= m) &#123;        obstacle[nx][ny] = true;    &#125;&#125;// 如果起点是障碍物，直接输出0if (obstacle[0][0]) &#123;    printf(&quot;0\n&quot;);    return 0;&#125;// 初始化DP数组long long dp[n + 1][m + 1];for (int i = 0; i &lt;= n; i++) &#123;    for (int j = 0; j &lt;= m; j++) &#123;        dp[i][j] = 0;    &#125;&#125;dp[0][0] = 1;// 动态规划计算路径数for (int i = 0; i &lt;= n; i++) &#123;    for (int j = 0; j &lt;= m; j++) &#123;        if (obstacle[i][j]) &#123;            continue;        &#125;        if (i &gt; 0 &amp;&amp; !obstacle[i - 1][j]) &#123;            dp[i][j] += dp[i - 1][j];        &#125;        if (j &gt; 0 &amp;&amp; !obstacle[i][j - 1]) &#123;            dp[i][j] += dp[i][j - 1];        &#125;    &#125;&#125;printf(&quot;%lld\n&quot;, dp[n][m]);return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog4</title>
      <link href="/2025/08/23/blog4/"/>
      <url>/2025/08/23/blog4/</url>
      
        <content type="html"><![CDATA[<p>实现数字反转<br>#include &lt;stdio.h&gt;</p><p>int add2(int a, int c) {<br>    if (a &#x3D;&#x3D; 0) {<br>        return c;<br>    }<br>    return add2(a &#x2F; 10, c * 10 + a % 10);<br>}</p><p>int main() {<br>    int x &#x3D; 0;<br>    int y &#x3D; 0;<br>    scanf(&quot;%d&quot;,&amp;x);<br>    if (x &lt; 0) {<br>        x &#x3D; -x;<br>        y &#x3D; add2(x, 0);<br>        printf(&quot;-%d&quot;, y);<br>    } else {<br>        y &#x3D; add2(x, 0);<br>        printf(&quot;%d&quot;, y);<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my blog3</title>
      <link href="/2025/08/21/my-blog3/"/>
      <url>/2025/08/21/my-blog3/</url>
      
        <content type="html"><![CDATA[<p>python  crawler:import os<br>import requests<br>from lxml import etree</p><p>headers &#x3D; {<br>    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;121.0.0.0 Safari&#x2F;537.36&#39;,<br>}<br>index_url &#x3D; &#39;<a href="https://music.163.com/discover/toplist?id=19723756">https://music.163.com/discover/toplist?id=19723756</a>&#39;<br>response &#x3D; requests.get(index_url, headers&#x3D;headers)<br>html &#x3D; etree.HTML(response.text)<br>id_info_list &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@class&#x3D;&quot;f-hide&quot;]&#x2F;li&#x2F;a&#x2F;@href&#39;)<br>name_list &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@class&#x3D;&quot;f-hide&quot;]&#x2F;li&#x2F;a&#x2F;text()&#39;)<br>if not os.path.exists(&#39;网易云音乐&#39;):<br>    os.mkdir(&#39;网易云音乐&#39;)<br>for id_info, name in zip(id_info_list, name_list):<br>    music_id &#x3D; id_info.split(&#39;&#x3D;&#39;)[1]<br>    music_url &#x3D; &#39;<a href="https://music.163.com/song/media/outer/url?id=">https://music.163.com/song/media/outer/url?id=</a>&#39; + music_id<br>    response &#x3D; requests.get(music_url, headers&#x3D;headers)<br>    name &#x3D; name.replace(&#39;&#x2F;&#39;, &#39;-&#39;)<br>    with open(f&#39;.&#x2F;网易云音乐&#x2F;{name}.mp3&#39;, &#39;wb&#39;) as file:<br>        file.write(response.content)</p><pre><code>print(f&#39;音乐名称：&#123;name&#125;  下载链接：&#123;music_url&#125; 下载完毕&#39;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog2</title>
      <link href="/2025/08/20/blog2/"/>
      <url>/2025/08/20/blog2/</url>
      
        <content type="html"><![CDATA[<p>实现扫雷游戏：<br>game.c:<br>#include &quot;game.h&quot;</p><p>void in_board(char board[ROWS][COLS], int rows, int cols, char set) {<br>int i &#x3D; 0;<br>int j &#x3D; 0;<br>for (i &#x3D; 0; i &lt; rows; i++) {<br>for (j &#x3D; 0; j &lt; cols; j++) {<br>board[i][j] &#x3D; set;<br>}<br>}<br>}</p><p>void paly_board(char board[ROWS][COLS], int row, int col) {<br>int i &#x3D; 0;<br>int j &#x3D; 0;<br>printf(&quot;----------------扫雷游戏-------------------\n&quot;);<br>for (j &#x3D; 0; j &lt;&#x3D; col; j++) {<br>printf(&quot;%d &quot;, j);<br>}<br>printf(&quot;\n&quot;);<br>for (i &#x3D; 1; i &lt;&#x3D; row; i++) {<br>printf(&quot;%d &quot;, i);<br>for (j &#x3D; 1; j &lt;&#x3D; col; j++) {<br>printf(&quot;%c &quot;, board[i][j]);<br>}<br>printf(&quot;\n&quot;);<br>}<br>printf(&quot;----------------扫雷游戏-------------------\n&quot;);<br>}</p><p>void setmine(char board[ROWS][COLS], int row, int col) {<br>int count &#x3D; MINE_COUNT;<br>while (count) {<br>int x &#x3D; rand() % row + 1;<br>int y &#x3D; rand() % col + 1;<br>if (board[x][y] &#x3D;&#x3D; &#39;0&#39;) {<br>board[x][y] &#x3D; &#39;1&#39;;<br>count--;<br>}<br>}<br>}</p><p>int get_mine_count(char board[ROWS][COLS], int x, int y) {<br>return (board[x - 1][y] +<br>board[x - 1][y - 1] +<br>board[x - 1][y + 1] +<br>board[x][y - 1] +<br>board[x][y + 1] +<br>board[x + 1][y - 1] +<br>board[x + 1][y + 1] +<br>board[x + 1][y] - 8 * &#39;0&#39;);<br>}</p><p>&#x2F;&#x2F; 扩展空白区域的递归函数<br>void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win) {<br>&#x2F;&#x2F; 检查坐标是否越界<br>if (x &lt; 1 || x &gt; ROW || y &lt; 1 || y &gt; COL) {<br>return;<br>}</p><pre><code>// 如果该位置已经展开或者是地雷，则返回if (show[x][y] != &#39;*&#39; || mine[x][y] == &#39;1&#39;) &#123;return;&#125;// 计算周围地雷数量int count = get_mine_count(mine, x, y);show[x][y] = count + &#39;0&#39;;(*win)++;// 如果周围没有地雷，则递归展开周围的8个格子if (count == 0) &#123;expand(mine, show, x - 1, y - 1, win);expand(mine, show, x - 1, y, win);expand(mine, show, x - 1, y + 1, win);expand(mine, show, x, y - 1, win);expand(mine, show, x, y + 1, win);expand(mine, show, x + 1, y - 1, win);expand(mine, show, x + 1, y, win);expand(mine, show, x + 1, y + 1, win);&#125;</code></pre><p>}</p><p>void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col) {<br>int x &#x3D; 0;<br>int y &#x3D; 0;<br>int win &#x3D; 0;</p><pre><code>while (win &lt; row * col - MINE_COUNT) &#123;printf(&quot;牢底祝你这次不会被炸死，坐标&gt;&quot;);scanf_s(&quot;%d %d&quot;, &amp;x, &amp;y);if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col) &#123;if (show[x][y] != &#39;*&#39;) &#123;printf(&quot;会玩不这已经有了\n&quot;);&#125;else &#123;if (mine[x][y] == &#39;1&#39;) &#123;printf(&quot;很遗憾，您踩到地雷了！游戏结束\n&quot;);paly_board(mine, ROW, COL);break;&#125;else &#123;// 使用扩展函数而不是直接显示数字expand(mine, show, x, y, &amp;win);paly_board(show, ROW, COL);&#125;&#125;&#125;else &#123;printf(&quot;牢底会不会玩，重新输入！\n&quot;);&#125;if (win == row * col - MINE_COUNT) &#123;printf(&quot;牢底你会玩，赢了\n&quot;);paly_board(show, ROW, COL);&#125;&#125;</code></pre><p>}</p><p>game.h:<br>#pragma once</p><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;time.h&gt;</p><p>#define ROW 9<br>#define COL 9</p><p>#define ROWS ROW+2<br>#define COLS COL+2</p><p>#define MINE_COUNT 10</p><p>&#x2F;&#x2F; 初始化棋盘<br>void in_board(char board[ROWS][COLS], int rows, int cols, char set);</p><p>&#x2F;&#x2F; 打印棋盘<br>void paly_board(char board[ROWS][COLS], int row, int col);</p><p>&#x2F;&#x2F; 布置雷<br>void setmine(char board[ROWS][COLS], int row, int col);</p><p>&#x2F;&#x2F; 排雷<br>void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);</p><p>&#x2F;&#x2F; 扩展空白区域 - 新增函数<br>void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win);</p><p>test.c:<br>#include &quot;game.h&quot;</p><p>void menu() {<br>printf(&quot;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>\n&quot;);<br>printf(&quot;</strong></strong></strong>*   1. 牢底来扫雷了       <em><strong><strong><strong>\n&quot;);<br>printf(&quot;</strong></strong></strong></em>   2. 不想玩就输这个     *******\n&quot;);<br>printf(&quot;******</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>\n&quot;);<br>}</p><p>void game() {<br>char mine[ROWS][COLS] &#x3D; {0};&#x2F;&#x2F;存放布置好的雷<br>char show[ROWS][COLS] &#x3D; {0};&#x2F;&#x2F;存放排查出的雷的信息<br>&#x2F;&#x2F;初始化棋盘<br>in_board(mine, ROWS, COLS, &#39;0&#39;);&#x2F;&#x2F;&#39;0&#39;<br>in_board(show, ROWS, COLS, &#39;<em>&#39;);&#x2F;&#x2F;&#39;</em>&#39;<br>&#x2F;&#x2F;布置雷<br>setmine(mine, ROW, COL);<br>&#x2F;&#x2F;打印棋盘<br>&#x2F;&#x2F;paly_board(mine, ROW, COL);<br>paly_board(show, ROW, COL);<br>&#x2F;&#x2F;排查雷<br>FindMine(mine, show, ROW, COL);<br>}</p><p>int main() {<br>int input &#x3D; 0;<br>srand((unsigned int)time(NULL));<br>do {<br>menu();<br>printf(&quot;请选择:&gt;&quot;);<br>scanf_s(&quot;%d&quot;, &amp;input);<br>switch (input) {<br>case 1:<br>game();<br>break;<br>case 2:<br>printf(&quot;退出游戏\n&quot;);<br>break;<br>default:<br>printf(&quot;选择错误，重新选择！\n&quot;);<br>break;<br>}<br>} while (input);<br>return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>the first program</title>
      <link href="/2025/08/19/the-first-program/"/>
      <url>/2025/08/19/the-first-program/</url>
      
        <content type="html"><![CDATA[<p>game.c:<br>&#x2F;&#x2F;具体实现函数运营<br>#include &quot;game.h&quot;<br>#include &lt;stdio.h&gt;<br>void in_board(char board[ROW][COL], int row, int col){<br>int i &#x3D; 0;<br>int j &#x3D; 0;<br>for (i &#x3D; 0; i &lt; row; i++)      &#x2F;&#x2F;实现二维数组<br>{<br>for (j &#x3D; 0; j &lt; col; j++)<br>{<br>board[i][j] &#x3D; &#39; &#39;;        &#x2F;&#x2F;空格为字符占位<br>}</p><pre><code>&#125;</code></pre><p>}<br>void out_board(char board[ROW][COL], int row, int col) {<br>int i &#x3D; 0;<br>for (i &#x3D;0; i&lt;row ; i++){<br>&#x2F;&#x2F;printf(&quot; %c | %c | %c \n&quot;, board[i][0], board[i][1], board[i][2]);    &#x2F;&#x2F;打印数据<br>int j &#x3D; 0;<br>for (j &#x3D; 0; j &lt; col; j++) {<br>printf(&quot; %c &quot;, board[i][j]);<br>if (j &lt; col-1)<br>printf(&quot;|&quot;);</p><pre><code>&#125;printf(&quot;\n&quot;);if (i &lt; row - 1) &#123;int j = 0;for (j = 0; j &lt; col; j++) &#123;printf(&quot;---&quot;);if (j &lt; col - 1)printf(&quot;|&quot;);&#125;printf(&quot;\n&quot;);&#125;&#125;</code></pre><p>}<br>void people(char board[ROW][COL], int row, int col) {<br>int x &#x3D; 0;<br>int y &#x3D; 0;<br>printf(&quot;牢底轮你了\n&quot;);<br>while (1) {<br>printf(&quot;输入坐标\n&quot;);<br>scanf_s(&quot;%d %d&quot;, &amp;x, &amp;y);<br>if (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col) {<br>if (board[x - 1][y - 1] &#x3D;&#x3D; &#39; &#39;) {<br>board[x - 1][y - 1] &#x3D; &#39;*&#39;;<br>break;<br>}<br>else {<br>printf(&quot;牢底重复下了&quot;);<br>}<br>}<br>else {<br>printf(&quot;牢底别瞎玩\n&quot;);<br>}<br>}</p><p>}<br>void computer(char board[ROW][COL], int row, int col) {<br>printf(&quot;电脑该你下了\n&quot;);<br>int x &#x3D; 0;<br>    int y &#x3D; 0;<br>while (1) {<br>x &#x3D; rand() % row;<br>y &#x3D; rand() % col;<br>if (board[x][y] &#x3D;&#x3D; &#39; &#39;) {<br>board[x][y] &#x3D; &#39;#&#39;;<br>break;<br>}<br>}</p><p>}<br>int ping(char board[ROW][COL], int row, int col) {<br>int i &#x3D; 0;<br>int j &#x3D; 0;<br>for (i &#x3D; 0; i &lt; col; i++) {<br>for (j &#x3D; 0; j &lt; col; j++) {<br>if (board[i][j] &#x3D;&#x3D; &#39; &#39;) {<br>return 0;<br>}<br>}<br>}<br>return 1;<br>}<br>char win(char board[ROW][COL], int row, int col) {<br>int i &#x3D; 0;        &#x2F;&#x2F;行<br>for (i &#x3D; 0; i &lt; row; i++) {<br>if (board[i][0] &#x3D;&#x3D; board[i][1] &amp;&amp; board[i][2] &amp;&amp; board[i][1] !&#x3D; &#39; &#39;) {<br>return board[i][1];<br>}<br>}<br>int j &#x3D; 0;        &#x2F;&#x2F;列<br>for (j &#x3D; 0; j &lt; row; j++) {<br>if (board[0][j] &#x3D;&#x3D; board[1][j] &amp;&amp; board[2][j] &amp;&amp; board[1][j] !&#x3D; &#39; &#39;) {<br>return board[1][j];<br>}<br>}<br>if(board[0][2] &#x3D;&#x3D; board[1][1] &amp;&amp; board[2][0] &#x3D;&#x3D; board[1][1] &amp;&amp; board[1][1] !&#x3D; &#39; &#39;){<br>return board[1][1]; }                          &#x2F;&#x2F;对角线<br><br>if (ping(board, row, col)) {<br>return&#39;Q&#39;;<br>}<br>return&#39;C&#39;;<br>}</p><p>test.c:<br>#include &lt;stdio.h&gt;<br>#include &quot;game.h&quot;<br>void menu() {<br>printf(&quot;########################################\n&quot;);<br>printf(&quot;################1.开始玩耍###############\n&quot;);<br>printf(&quot;################2.离开游戏###############\n&quot;);<br>           }   &#x2F;&#x2F;设计个菜单<br>void game() {<br>char ret &#x3D; 0;          &#x2F;&#x2F;加个变量接收值<br>char board[ROW][COL] &#x3D; { 0 };<br>in_board(board, ROW, COL);  &#x2F;&#x2F;初始化棋盘<br>out_board(board, ROW, COL);        &#x2F;&#x2F;耍时候打印的棋盘<br>while (1) {                    &#x2F;&#x2F;下棋<br>people(board, ROW, COL);<br>ret &#x3D; win(board, ROW, COL);     &#x2F;&#x2F;判断输赢<br>if (ret !&#x3D; &#39;C&#39;) {<br>break;<br>}<br>out_board(board, ROW, COL);<br>computer(board, ROW, COL);<br>ret &#x3D; win(board, ROW, COL);<br>if (ret !&#x3D; &#39;C&#39;) {<br>break;<br>}<br>out_board(board, ROW, COL);<br>}<br>if (ret &#x3D;&#x3D; &#39;*&#39;) {<br>printf(&quot;牢底666赢了\n&quot;);<br>}<br>else if (ret &#x3D;&#x3D; &#39;#&#39;) {<br>printf(&quot;牢底你没下过电脑\n&quot;);<br>}<br>else {<br>printf(&quot;这都能平局，菜！&quot;);<br>}<br>out_board(board, ROW, COL);<br>}<br>int main() {<br>srand((unsigned int)time(NULL));    &#x2F;&#x2F;利用时间栈制作随机数<br>int input &#x3D; 0;<br>do {<br>menu();                     &#x2F;&#x2F;设置循环，方便玩耍<br>printf(&quot;你想选啥？&gt;&quot;);<br>scanf_s(&quot;%d&quot;, &amp;input);<br>switch (input) {<br>case 1:<br>printf(&quot;下棋了牢弟\n&quot;);<br>game();    &#x2F;&#x2F;设计游戏<br>break;<br>case 2:<br>printf(&quot;想退选这&quot;);<br>break;<br>default:<br>printf(&quot;选个数字都不会，菜！&quot;);<br>break;<br>}<br>} while (input);<br>return 0;<br>}</p><p>game.h:<br>#include &lt;stdio.h&gt;<br>#pragma once           &#x2F;&#x2F;只用来声明函数<br>#define ROW 3            &#x2F;&#x2F;定义下实现n子棋<br>#define COL 3<br>#include &lt;stdlib.h&gt;<br>#include &lt;time.h&gt;<br>void in_board(char board[ROW][COL], int row, int col);    &#x2F;&#x2F;初始棋盘<br>void out_board(char board[ROW][COL], int row, int col);     &#x2F;&#x2F;打印棋盘<br>void people(char board[ROW][COL], int row, int col);    &#x2F;&#x2F;玩家游玩参数<br>void computer(char board[ROW][COL], int row, int col);    &#x2F;&#x2F;电脑参数<br>&#x2F;&#x2F;“ * ”   玩家赢<br>&#x2F;&#x2F;“ # ”   电脑赢<br>&#x2F;&#x2F;“ Q ”  平局<br>&#x2F;&#x2F;“ C ”    继续<br>char win(char board[ROW][COL], int row, int col);</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>new jounary</title>
      <link href="/2025/08/19/new-jounary/"/>
      <url>/2025/08/19/new-jounary/</url>
      
        <content type="html"><![CDATA[<p>This is my blog!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/08/19/hello-world/"/>
      <url>/2025/08/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
